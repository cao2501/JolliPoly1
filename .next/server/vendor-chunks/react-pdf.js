"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-pdf";
exports.ids = ["vendor-chunks/react-pdf"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.css":
/*!******************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.css ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"acc6f0c1f165\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvQW5ub3RhdGlvbkxheWVyLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcmVlci1ndWlkYW5jZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUGFnZS9Bbm5vdGF0aW9uTGF5ZXIuY3NzP2I1ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJhY2M2ZjBjMWYxNjVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Page/AnnotationLayer.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/dist/esm/Page/TextLayer.css":
/*!************************************************************!*\
  !*** ./node_modules/react-pdf/dist/esm/Page/TextLayer.css ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"65eac2ffe29d\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL2Rpc3QvZXNtL1BhZ2UvVGV4dExheWVyLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcmVlci1ndWlkYW5jZS8uL25vZGVfbW9kdWxlcy9yZWFjdC1wZGYvZGlzdC9lc20vUGFnZS9UZXh0TGF5ZXIuY3NzPzg2OTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI2NWVhYzJmZmUyOWRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/dist/esm/Page/TextLayer.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ __webpack_exports__AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ __webpack_exports__AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ __webpack_exports__AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ __webpack_exports__AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ __webpack_exports__AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ __webpack_exports__AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ __webpack_exports__AnnotationMode),\n/* harmony export */   ColorPicker: () => (/* binding */ __webpack_exports__ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ __webpack_exports__DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ __webpack_exports__DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ __webpack_exports__FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ __webpack_exports__GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ __webpack_exports__ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ __webpack_exports__InvalidPDFException),\n/* harmony export */   MissingPDFException: () => (/* binding */ __webpack_exports__MissingPDFException),\n/* harmony export */   OPS: () => (/* binding */ __webpack_exports__OPS),\n/* harmony export */   OutputScale: () => (/* binding */ __webpack_exports__OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ __webpack_exports__PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ __webpack_exports__PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ __webpack_exports__PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ __webpack_exports__PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ __webpack_exports__PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ __webpack_exports__PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ __webpack_exports__RenderingCancelledException),\n/* harmony export */   TextLayer: () => (/* binding */ __webpack_exports__TextLayer),\n/* harmony export */   UnexpectedResponseException: () => (/* binding */ __webpack_exports__UnexpectedResponseException),\n/* harmony export */   Util: () => (/* binding */ __webpack_exports__Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ __webpack_exports__VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ __webpack_exports__XfaLayer),\n/* harmony export */   build: () => (/* binding */ __webpack_exports__build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ __webpack_exports__createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ __webpack_exports__fetchData),\n/* harmony export */   getDocument: () => (/* binding */ __webpack_exports__getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ __webpack_exports__getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ __webpack_exports__getPdfFilenameFromUrl),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ __webpack_exports__getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ __webpack_exports__isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ __webpack_exports__isPdfFile),\n/* harmony export */   noContextMenu: () => (/* binding */ __webpack_exports__noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ __webpack_exports__normalizeUnicode),\n/* harmony export */   setLayerDimensions: () => (/* binding */ __webpack_exports__setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ __webpack_exports__shadow),\n/* harmony export */   version: () => (/* binding */ __webpack_exports__version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */ /******/ // The require scope\n/******/ var __nested_webpack_require_838__ = {};\n/******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n    /******/ // define getter functions for harmony exports\n    /******/ __nested_webpack_require_838__.d = (exports, definition)=>{\n        /******/ for(var key in definition){\n            /******/ if (__nested_webpack_require_838__.o(definition, key) && !__nested_webpack_require_838__.o(exports, key)) {\n                /******/ Object.defineProperty(exports, key, {\n                    enumerable: true,\n                    get: definition[key]\n                });\n            /******/ }\n        /******/ }\n    /******/ };\n/******/ })();\n/******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n    /******/ __nested_webpack_require_838__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n/******/ })();\n/******/ /************************************************************************/ var __nested_webpack_exports__ = globalThis.pdfjsLib = {};\n// EXPORTS\n__nested_webpack_require_838__.d(__nested_webpack_exports__, {\n    AbortException: ()=>/* reexport */ AbortException,\n    AnnotationEditorLayer: ()=>/* reexport */ AnnotationEditorLayer,\n    AnnotationEditorParamsType: ()=>/* reexport */ AnnotationEditorParamsType,\n    AnnotationEditorType: ()=>/* reexport */ AnnotationEditorType,\n    AnnotationEditorUIManager: ()=>/* reexport */ AnnotationEditorUIManager,\n    AnnotationLayer: ()=>/* reexport */ AnnotationLayer,\n    AnnotationMode: ()=>/* reexport */ AnnotationMode,\n    ColorPicker: ()=>/* reexport */ ColorPicker,\n    DOMSVGFactory: ()=>/* reexport */ DOMSVGFactory,\n    DrawLayer: ()=>/* reexport */ DrawLayer,\n    FeatureTest: ()=>/* reexport */ util_FeatureTest,\n    GlobalWorkerOptions: ()=>/* reexport */ GlobalWorkerOptions,\n    ImageKind: ()=>/* reexport */ util_ImageKind,\n    InvalidPDFException: ()=>/* reexport */ InvalidPDFException,\n    MissingPDFException: ()=>/* reexport */ MissingPDFException,\n    OPS: ()=>/* reexport */ OPS,\n    OutputScale: ()=>/* reexport */ OutputScale,\n    PDFDataRangeTransport: ()=>/* reexport */ PDFDataRangeTransport,\n    PDFDateString: ()=>/* reexport */ PDFDateString,\n    PDFWorker: ()=>/* reexport */ PDFWorker,\n    PasswordResponses: ()=>/* reexport */ PasswordResponses,\n    PermissionFlag: ()=>/* reexport */ PermissionFlag,\n    PixelsPerInch: ()=>/* reexport */ PixelsPerInch,\n    RenderingCancelledException: ()=>/* reexport */ RenderingCancelledException,\n    TextLayer: ()=>/* reexport */ TextLayer,\n    UnexpectedResponseException: ()=>/* reexport */ UnexpectedResponseException,\n    Util: ()=>/* reexport */ Util,\n    VerbosityLevel: ()=>/* reexport */ VerbosityLevel,\n    XfaLayer: ()=>/* reexport */ XfaLayer,\n    build: ()=>/* reexport */ build,\n    createValidAbsoluteUrl: ()=>/* reexport */ createValidAbsoluteUrl,\n    fetchData: ()=>/* reexport */ fetchData,\n    getDocument: ()=>/* reexport */ getDocument,\n    getFilenameFromUrl: ()=>/* reexport */ getFilenameFromUrl,\n    getPdfFilenameFromUrl: ()=>/* reexport */ getPdfFilenameFromUrl,\n    getXfaPageViewport: ()=>/* reexport */ getXfaPageViewport,\n    isDataScheme: ()=>/* reexport */ isDataScheme,\n    isPdfFile: ()=>/* reexport */ isPdfFile,\n    noContextMenu: ()=>/* reexport */ noContextMenu,\n    normalizeUnicode: ()=>/* reexport */ normalizeUnicode,\n    setLayerDimensions: ()=>/* reexport */ setLayerDimensions,\n    shadow: ()=>/* reexport */ shadow,\n    version: ()=>/* reexport */ version\n});\n; // ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst IDENTITY_MATRIX = [\n    1,\n    0,\n    0,\n    1,\n    0,\n    0\n];\nconst FONT_IDENTITY_MATRIX = [\n    0.001,\n    0,\n    0,\n    0.001,\n    0,\n    0\n];\nconst MAX_IMAGE_SIZE_TO_CACHE = 10e6;\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n    ANY: 0x01,\n    DISPLAY: 0x02,\n    PRINT: 0x04,\n    SAVE: 0x08,\n    ANNOTATIONS_FORMS: 0x10,\n    ANNOTATIONS_STORAGE: 0x20,\n    ANNOTATIONS_DISABLE: 0x40,\n    IS_EDITING: 0x80,\n    OPLIST: 0x100\n};\nconst AnnotationMode = {\n    DISABLE: 0,\n    ENABLE: 1,\n    ENABLE_FORMS: 2,\n    ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n    DISABLE: -1,\n    NONE: 0,\n    FREETEXT: 3,\n    HIGHLIGHT: 9,\n    STAMP: 13,\n    INK: 15\n};\nconst AnnotationEditorParamsType = {\n    RESIZE: 1,\n    CREATE: 2,\n    FREETEXT_SIZE: 11,\n    FREETEXT_COLOR: 12,\n    FREETEXT_OPACITY: 13,\n    INK_COLOR: 21,\n    INK_THICKNESS: 22,\n    INK_OPACITY: 23,\n    HIGHLIGHT_COLOR: 31,\n    HIGHLIGHT_DEFAULT_COLOR: 32,\n    HIGHLIGHT_THICKNESS: 33,\n    HIGHLIGHT_FREE: 34,\n    HIGHLIGHT_SHOW_ALL: 35\n};\nconst PermissionFlag = {\n    PRINT: 0x04,\n    MODIFY_CONTENTS: 0x08,\n    COPY: 0x10,\n    MODIFY_ANNOTATIONS: 0x20,\n    FILL_INTERACTIVE_FORMS: 0x100,\n    COPY_FOR_ACCESSIBILITY: 0x200,\n    ASSEMBLE: 0x400,\n    PRINT_HIGH_QUALITY: 0x800\n};\nconst TextRenderingMode = {\n    FILL: 0,\n    STROKE: 1,\n    FILL_STROKE: 2,\n    INVISIBLE: 3,\n    FILL_ADD_TO_PATH: 4,\n    STROKE_ADD_TO_PATH: 5,\n    FILL_STROKE_ADD_TO_PATH: 6,\n    ADD_TO_PATH: 7,\n    FILL_STROKE_MASK: 3,\n    ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n    GRAYSCALE_1BPP: 1,\n    RGB_24BPP: 2,\n    RGBA_32BPP: 3\n};\nconst AnnotationType = {\n    TEXT: 1,\n    LINK: 2,\n    FREETEXT: 3,\n    LINE: 4,\n    SQUARE: 5,\n    CIRCLE: 6,\n    POLYGON: 7,\n    POLYLINE: 8,\n    HIGHLIGHT: 9,\n    UNDERLINE: 10,\n    SQUIGGLY: 11,\n    STRIKEOUT: 12,\n    STAMP: 13,\n    CARET: 14,\n    INK: 15,\n    POPUP: 16,\n    FILEATTACHMENT: 17,\n    SOUND: 18,\n    MOVIE: 19,\n    WIDGET: 20,\n    SCREEN: 21,\n    PRINTERMARK: 22,\n    TRAPNET: 23,\n    WATERMARK: 24,\n    THREED: 25,\n    REDACT: 26\n};\nconst AnnotationReplyType = {\n    GROUP: \"Group\",\n    REPLY: \"R\"\n};\nconst AnnotationFlag = {\n    INVISIBLE: 0x01,\n    HIDDEN: 0x02,\n    PRINT: 0x04,\n    NOZOOM: 0x08,\n    NOROTATE: 0x10,\n    NOVIEW: 0x20,\n    READONLY: 0x40,\n    LOCKED: 0x80,\n    TOGGLENOVIEW: 0x100,\n    LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n    READONLY: 0x0000001,\n    REQUIRED: 0x0000002,\n    NOEXPORT: 0x0000004,\n    MULTILINE: 0x0001000,\n    PASSWORD: 0x0002000,\n    NOTOGGLETOOFF: 0x0004000,\n    RADIO: 0x0008000,\n    PUSHBUTTON: 0x0010000,\n    COMBO: 0x0020000,\n    EDIT: 0x0040000,\n    SORT: 0x0080000,\n    FILESELECT: 0x0100000,\n    MULTISELECT: 0x0200000,\n    DONOTSPELLCHECK: 0x0400000,\n    DONOTSCROLL: 0x0800000,\n    COMB: 0x1000000,\n    RICHTEXT: 0x2000000,\n    RADIOSINUNISON: 0x2000000,\n    COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n    SOLID: 1,\n    DASHED: 2,\n    BEVELED: 3,\n    INSET: 4,\n    UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n    E: \"Mouse Enter\",\n    X: \"Mouse Exit\",\n    D: \"Mouse Down\",\n    U: \"Mouse Up\",\n    Fo: \"Focus\",\n    Bl: \"Blur\",\n    PO: \"PageOpen\",\n    PC: \"PageClose\",\n    PV: \"PageVisible\",\n    PI: \"PageInvisible\",\n    K: \"Keystroke\",\n    F: \"Format\",\n    V: \"Validate\",\n    C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n    WC: \"WillClose\",\n    WS: \"WillSave\",\n    DS: \"DidSave\",\n    WP: \"WillPrint\",\n    DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n    O: \"PageOpen\",\n    C: \"PageClose\"\n};\nconst VerbosityLevel = {\n    ERRORS: 0,\n    WARNINGS: 1,\n    INFOS: 5\n};\nconst OPS = {\n    dependency: 1,\n    setLineWidth: 2,\n    setLineCap: 3,\n    setLineJoin: 4,\n    setMiterLimit: 5,\n    setDash: 6,\n    setRenderingIntent: 7,\n    setFlatness: 8,\n    setGState: 9,\n    save: 10,\n    restore: 11,\n    transform: 12,\n    moveTo: 13,\n    lineTo: 14,\n    curveTo: 15,\n    curveTo2: 16,\n    curveTo3: 17,\n    closePath: 18,\n    rectangle: 19,\n    stroke: 20,\n    closeStroke: 21,\n    fill: 22,\n    eoFill: 23,\n    fillStroke: 24,\n    eoFillStroke: 25,\n    closeFillStroke: 26,\n    closeEOFillStroke: 27,\n    endPath: 28,\n    clip: 29,\n    eoClip: 30,\n    beginText: 31,\n    endText: 32,\n    setCharSpacing: 33,\n    setWordSpacing: 34,\n    setHScale: 35,\n    setLeading: 36,\n    setFont: 37,\n    setTextRenderingMode: 38,\n    setTextRise: 39,\n    moveText: 40,\n    setLeadingMoveText: 41,\n    setTextMatrix: 42,\n    nextLine: 43,\n    showText: 44,\n    showSpacedText: 45,\n    nextLineShowText: 46,\n    nextLineSetSpacingShowText: 47,\n    setCharWidth: 48,\n    setCharWidthAndBounds: 49,\n    setStrokeColorSpace: 50,\n    setFillColorSpace: 51,\n    setStrokeColor: 52,\n    setStrokeColorN: 53,\n    setFillColor: 54,\n    setFillColorN: 55,\n    setStrokeGray: 56,\n    setFillGray: 57,\n    setStrokeRGBColor: 58,\n    setFillRGBColor: 59,\n    setStrokeCMYKColor: 60,\n    setFillCMYKColor: 61,\n    shadingFill: 62,\n    beginInlineImage: 63,\n    beginImageData: 64,\n    endInlineImage: 65,\n    paintXObject: 66,\n    markPoint: 67,\n    markPointProps: 68,\n    beginMarkedContent: 69,\n    beginMarkedContentProps: 70,\n    endMarkedContent: 71,\n    beginCompat: 72,\n    endCompat: 73,\n    paintFormXObjectBegin: 74,\n    paintFormXObjectEnd: 75,\n    beginGroup: 76,\n    endGroup: 77,\n    beginAnnotation: 80,\n    endAnnotation: 81,\n    paintImageMaskXObject: 83,\n    paintImageMaskXObjectGroup: 84,\n    paintImageXObject: 85,\n    paintInlineImageXObject: 86,\n    paintInlineImageXObjectGroup: 87,\n    paintImageXObjectRepeat: 88,\n    paintImageMaskXObjectRepeat: 89,\n    paintSolidColorImageMask: 90,\n    constructPath: 91,\n    setStrokeTransparent: 92,\n    setFillTransparent: 93\n};\nconst PasswordResponses = {\n    NEED_PASSWORD: 1,\n    INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n    if (Number.isInteger(level)) {\n        verbosity = level;\n    }\n}\nfunction getVerbosityLevel() {\n    return verbosity;\n}\nfunction info(msg) {\n    if (verbosity >= VerbosityLevel.INFOS) {\n        console.log(`Info: ${msg}`);\n    }\n}\nfunction warn(msg) {\n    if (verbosity >= VerbosityLevel.WARNINGS) {\n        console.log(`Warning: ${msg}`);\n    }\n}\nfunction unreachable(msg) {\n    throw new Error(msg);\n}\nfunction assert(cond, msg) {\n    if (!cond) {\n        unreachable(msg);\n    }\n}\nfunction _isValidProtocol(url) {\n    switch(url?.protocol){\n        case \"http:\":\n        case \"https:\":\n        case \"ftp:\":\n        case \"mailto:\":\n        case \"tel:\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n    if (!url) {\n        return null;\n    }\n    try {\n        if (options && typeof url === \"string\") {\n            if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n                const dots = url.match(/\\./g);\n                if (dots?.length >= 2) {\n                    url = `http://${url}`;\n                }\n            }\n            if (options.tryConvertEncoding) {\n                try {\n                    url = stringToUTF8String(url);\n                } catch  {}\n            }\n        }\n        const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n        if (_isValidProtocol(absoluteUrl)) {\n            return absoluteUrl;\n        }\n    } catch  {}\n    return null;\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n    Object.defineProperty(obj, prop, {\n        value,\n        enumerable: !nonSerializable,\n        configurable: true,\n        writable: false\n    });\n    return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n    function BaseException(message, name) {\n        this.message = message;\n        this.name = name;\n    }\n    BaseException.prototype = new Error();\n    BaseException.constructor = BaseException;\n    return BaseException;\n}();\nclass PasswordException extends BaseException {\n    constructor(msg, code){\n        super(msg, \"PasswordException\");\n        this.code = code;\n    }\n}\nclass UnknownErrorException extends BaseException {\n    constructor(msg, details){\n        super(msg, \"UnknownErrorException\");\n        this.details = details;\n    }\n}\nclass InvalidPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"InvalidPDFException\");\n    }\n}\nclass MissingPDFException extends BaseException {\n    constructor(msg){\n        super(msg, \"MissingPDFException\");\n    }\n}\nclass UnexpectedResponseException extends BaseException {\n    constructor(msg, status){\n        super(msg, \"UnexpectedResponseException\");\n        this.status = status;\n    }\n}\nclass FormatError extends BaseException {\n    constructor(msg){\n        super(msg, \"FormatError\");\n    }\n}\nclass AbortException extends BaseException {\n    constructor(msg){\n        super(msg, \"AbortException\");\n    }\n}\nfunction bytesToString(bytes) {\n    if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n        unreachable(\"Invalid argument for bytesToString\");\n    }\n    const length = bytes.length;\n    const MAX_ARGUMENT_COUNT = 8192;\n    if (length < MAX_ARGUMENT_COUNT) {\n        return String.fromCharCode.apply(null, bytes);\n    }\n    const strBuf = [];\n    for(let i = 0; i < length; i += MAX_ARGUMENT_COUNT){\n        const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n        const chunk = bytes.subarray(i, chunkEnd);\n        strBuf.push(String.fromCharCode.apply(null, chunk));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n    if (typeof str !== \"string\") {\n        unreachable(\"Invalid argument for stringToBytes\");\n    }\n    const length = str.length;\n    const bytes = new Uint8Array(length);\n    for(let i = 0; i < length; ++i){\n        bytes[i] = str.charCodeAt(i) & 0xff;\n    }\n    return bytes;\n}\nfunction string32(value) {\n    return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n    return Object.keys(obj).length;\n}\nfunction objectFromMap(map) {\n    const obj = Object.create(null);\n    for (const [key, value] of map){\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction isLittleEndian() {\n    const buffer8 = new Uint8Array(4);\n    buffer8[0] = 1;\n    const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n    return view32[0] === 1;\n}\nfunction isEvalSupported() {\n    try {\n        new Function(\"\");\n        return true;\n    } catch  {\n        return false;\n    }\n}\nclass util_FeatureTest {\n    static get isLittleEndian() {\n        return shadow(this, \"isLittleEndian\", isLittleEndian());\n    }\n    static get isEvalSupported() {\n        return shadow(this, \"isEvalSupported\", isEvalSupported());\n    }\n    static get isOffscreenCanvasSupported() {\n        return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n    }\n    static get platform() {\n        if (typeof navigator !== \"undefined\" && typeof navigator?.platform === \"string\") {\n            return shadow(this, \"platform\", {\n                isMac: navigator.platform.includes(\"Mac\"),\n                isWindows: navigator.platform.includes(\"Win\"),\n                isFirefox: typeof navigator?.userAgent === \"string\" && navigator.userAgent.includes(\"Firefox\")\n            });\n        }\n        return shadow(this, \"platform\", {\n            isMac: false,\n            isWindows: false,\n            isFirefox: false\n        });\n    }\n    static get isCSSRoundSupported() {\n        return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n    }\n}\nconst hexNumbers = Array.from(Array(256).keys(), (n)=>n.toString(16).padStart(2, \"0\"));\nclass Util {\n    static makeHexColor(r, g, b) {\n        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n    }\n    static scaleMinMax(transform, minMax) {\n        let temp;\n        if (transform[0]) {\n            if (transform[0] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[0];\n            minMax[2] *= transform[0];\n            if (transform[3] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[3];\n            minMax[3] *= transform[3];\n        } else {\n            temp = minMax[0];\n            minMax[0] = minMax[1];\n            minMax[1] = temp;\n            temp = minMax[2];\n            minMax[2] = minMax[3];\n            minMax[3] = temp;\n            if (transform[1] < 0) {\n                temp = minMax[1];\n                minMax[1] = minMax[3];\n                minMax[3] = temp;\n            }\n            minMax[1] *= transform[1];\n            minMax[3] *= transform[1];\n            if (transform[2] < 0) {\n                temp = minMax[0];\n                minMax[0] = minMax[2];\n                minMax[2] = temp;\n            }\n            minMax[0] *= transform[2];\n            minMax[2] *= transform[2];\n        }\n        minMax[0] += transform[4];\n        minMax[1] += transform[5];\n        minMax[2] += transform[4];\n        minMax[3] += transform[5];\n    }\n    static transform(m1, m2) {\n        return [\n            m1[0] * m2[0] + m1[2] * m2[1],\n            m1[1] * m2[0] + m1[3] * m2[1],\n            m1[0] * m2[2] + m1[2] * m2[3],\n            m1[1] * m2[2] + m1[3] * m2[3],\n            m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n            m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n        ];\n    }\n    static applyTransform(p, m) {\n        const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n        const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n        return [\n            xt,\n            yt\n        ];\n    }\n    static applyInverseTransform(p, m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n        const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n        return [\n            xt,\n            yt\n        ];\n    }\n    static getAxialAlignedBoundingBox(r, m) {\n        const p1 = this.applyTransform(r, m);\n        const p2 = this.applyTransform(r.slice(2, 4), m);\n        const p3 = this.applyTransform([\n            r[0],\n            r[3]\n        ], m);\n        const p4 = this.applyTransform([\n            r[2],\n            r[1]\n        ], m);\n        return [\n            Math.min(p1[0], p2[0], p3[0], p4[0]),\n            Math.min(p1[1], p2[1], p3[1], p4[1]),\n            Math.max(p1[0], p2[0], p3[0], p4[0]),\n            Math.max(p1[1], p2[1], p3[1], p4[1])\n        ];\n    }\n    static inverseTransform(m) {\n        const d = m[0] * m[3] - m[1] * m[2];\n        return [\n            m[3] / d,\n            -m[1] / d,\n            -m[2] / d,\n            m[0] / d,\n            (m[2] * m[5] - m[4] * m[3]) / d,\n            (m[4] * m[1] - m[5] * m[0]) / d\n        ];\n    }\n    static singularValueDecompose2dScale(m) {\n        const transpose = [\n            m[0],\n            m[2],\n            m[1],\n            m[3]\n        ];\n        const a = m[0] * transpose[0] + m[1] * transpose[2];\n        const b = m[0] * transpose[1] + m[1] * transpose[3];\n        const c = m[2] * transpose[0] + m[3] * transpose[2];\n        const d = m[2] * transpose[1] + m[3] * transpose[3];\n        const first = (a + d) / 2;\n        const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n        const sx = first + second || 1;\n        const sy = first - second || 1;\n        return [\n            Math.sqrt(sx),\n            Math.sqrt(sy)\n        ];\n    }\n    static normalizeRect(rect) {\n        const r = rect.slice(0);\n        if (rect[0] > rect[2]) {\n            r[0] = rect[2];\n            r[2] = rect[0];\n        }\n        if (rect[1] > rect[3]) {\n            r[1] = rect[3];\n            r[3] = rect[1];\n        }\n        return r;\n    }\n    static intersect(rect1, rect2) {\n        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n        if (xLow > xHigh) {\n            return null;\n        }\n        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n        if (yLow > yHigh) {\n            return null;\n        }\n        return [\n            xLow,\n            yLow,\n            xHigh,\n            yHigh\n        ];\n    }\n    static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n        if (t <= 0 || t >= 1) {\n            return;\n        }\n        const mt = 1 - t;\n        const tt = t * t;\n        const ttt = tt * t;\n        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n        minMax[0] = Math.min(minMax[0], x);\n        minMax[1] = Math.min(minMax[1], y);\n        minMax[2] = Math.max(minMax[2], x);\n        minMax[3] = Math.max(minMax[3], y);\n    }\n    static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n        if (Math.abs(a) < 1e-12) {\n            if (Math.abs(b) >= 1e-12) {\n                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n            }\n            return;\n        }\n        const delta = b ** 2 - 4 * c * a;\n        if (delta < 0) {\n            return;\n        }\n        const sqrtDelta = Math.sqrt(delta);\n        const a2 = 2 * a;\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n    }\n    static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        if (minMax) {\n            minMax[0] = Math.min(minMax[0], x0, x3);\n            minMax[1] = Math.min(minMax[1], y0, y3);\n            minMax[2] = Math.max(minMax[2], x0, x3);\n            minMax[3] = Math.max(minMax[3], y0, y3);\n        } else {\n            minMax = [\n                Math.min(x0, x3),\n                Math.min(y0, y3),\n                Math.max(x0, x3),\n                Math.max(y0, y3)\n            ];\n        }\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n        return minMax;\n    }\n}\nconst PDFStringTranslateTable = /* unused pure expression or super */ null && 0;\nfunction stringToPDFString(str) {\n    if (str[0] >= \"\\xef\") {\n        let encoding;\n        if (str[0] === \"\\xfe\" && str[1] === \"\\xff\") {\n            encoding = \"utf-16be\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xff\" && str[1] === \"\\xfe\") {\n            encoding = \"utf-16le\";\n            if (str.length % 2 === 1) {\n                str = str.slice(0, -1);\n            }\n        } else if (str[0] === \"\\xef\" && str[1] === \"\\xbb\" && str[2] === \"\\xbf\") {\n            encoding = \"utf-8\";\n        }\n        if (encoding) {\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(str);\n                const decoded = decoder.decode(buffer);\n                if (!decoded.includes(\"\\x1b\")) {\n                    return decoded;\n                }\n                return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n            } catch (ex) {\n                warn(`stringToPDFString: \"${ex}\".`);\n            }\n        }\n    }\n    const strBuf = [];\n    for(let i = 0, ii = str.length; i < ii; i++){\n        const charCode = str.charCodeAt(i);\n        if (charCode === 0x1b) {\n            while(++i < ii && str.charCodeAt(i) !== 0x1b){}\n            continue;\n        }\n        const code = PDFStringTranslateTable[charCode];\n        strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n    return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n    return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n    return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for(let i = 0, ii = arr1.length; i < ii; i++){\n        if (arr1[i] !== arr2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getModificationDate(date = new Date()) {\n    const buffer = [\n        date.getUTCFullYear().toString(),\n        (date.getUTCMonth() + 1).toString().padStart(2, \"0\"),\n        date.getUTCDate().toString().padStart(2, \"0\"),\n        date.getUTCHours().toString().padStart(2, \"0\"),\n        date.getUTCMinutes().toString().padStart(2, \"0\"),\n        date.getUTCSeconds().toString().padStart(2, \"0\")\n    ];\n    return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n    if (!NormalizeRegex) {\n        NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n        NormalizationMap = new Map([\n            [\n                \"ﬅ\",\n                \"ſt\"\n            ]\n        ]);\n    }\n    return str.replaceAll(NormalizeRegex, (_, p1, p2)=>p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n    if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n        return crypto.randomUUID();\n    }\n    const buf = new Uint8Array(32);\n    if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n        crypto.getRandomValues(buf);\n    } else {\n        for(let i = 0; i < 32; i++){\n            buf[i] = Math.floor(Math.random() * 255);\n        }\n    }\n    return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nconst FontRenderOps = {\n    BEZIER_CURVE_TO: 0,\n    MOVE_TO: 1,\n    LINE_TO: 2,\n    QUADRATIC_CURVE_TO: 3,\n    RESTORE: 4,\n    SAVE: 5,\n    SCALE: 6,\n    TRANSFORM: 7,\n    TRANSLATE: 8\n};\nfunction toHexUtil(arr) {\n    if (Uint8Array.prototype.toHex) {\n        return arr.toHex();\n    }\n    return Array.from(arr, (num)=>hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n    if (Uint8Array.prototype.toBase64) {\n        return arr.toBase64();\n    }\n    return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n    if (Uint8Array.fromBase64) {\n        return Uint8Array.fromBase64(str);\n    }\n    return stringToBytes(atob(str));\n}\n; // ./src/display/display_utils.js\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n    static{\n        this.CSS = 96.0;\n    }\n    static{\n        this.PDF = 72.0;\n    }\n    static{\n        this.PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n    }\n}\nasync function fetchData(url, type = \"text\") {\n    if (isValidFetchUrl(url, document.baseURI)) {\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(response.statusText);\n        }\n        switch(type){\n            case \"arraybuffer\":\n                return response.arrayBuffer();\n            case \"blob\":\n                return response.blob();\n            case \"json\":\n                return response.json();\n        }\n        return response.text();\n    }\n    return new Promise((resolve, reject)=>{\n        const request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n        request.responseType = type;\n        request.onreadystatechange = ()=>{\n            if (request.readyState !== XMLHttpRequest.DONE) {\n                return;\n            }\n            if (request.status === 200 || request.status === 0) {\n                switch(type){\n                    case \"arraybuffer\":\n                    case \"blob\":\n                    case \"json\":\n                        resolve(request.response);\n                        return;\n                }\n                resolve(request.responseText);\n                return;\n            }\n            reject(new Error(request.statusText));\n        };\n        request.send(null);\n    });\n}\nclass PageViewport {\n    constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }){\n        this.viewBox = viewBox;\n        this.scale = scale;\n        this.rotation = rotation;\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        const centerX = (viewBox[2] + viewBox[0]) / 2;\n        const centerY = (viewBox[3] + viewBox[1]) / 2;\n        let rotateA, rotateB, rotateC, rotateD;\n        rotation %= 360;\n        if (rotation < 0) {\n            rotation += 360;\n        }\n        switch(rotation){\n            case 180:\n                rotateA = -1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = 1;\n                break;\n            case 90:\n                rotateA = 0;\n                rotateB = 1;\n                rotateC = 1;\n                rotateD = 0;\n                break;\n            case 270:\n                rotateA = 0;\n                rotateB = -1;\n                rotateC = -1;\n                rotateD = 0;\n                break;\n            case 0:\n                rotateA = 1;\n                rotateB = 0;\n                rotateC = 0;\n                rotateD = -1;\n                break;\n            default:\n                throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n        }\n        if (dontFlip) {\n            rotateC = -rotateC;\n            rotateD = -rotateD;\n        }\n        let offsetCanvasX, offsetCanvasY;\n        let width, height;\n        if (rotateA === 0) {\n            offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n            width = (viewBox[3] - viewBox[1]) * scale;\n            height = (viewBox[2] - viewBox[0]) * scale;\n        } else {\n            offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n            offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n            width = (viewBox[2] - viewBox[0]) * scale;\n            height = (viewBox[3] - viewBox[1]) * scale;\n        }\n        this.transform = [\n            rotateA * scale,\n            rotateB * scale,\n            rotateC * scale,\n            rotateD * scale,\n            offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n            offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n        ];\n        this.width = width;\n        this.height = height;\n    }\n    get rawDims() {\n        const { viewBox } = this;\n        return shadow(this, \"rawDims\", {\n            pageWidth: viewBox[2] - viewBox[0],\n            pageHeight: viewBox[3] - viewBox[1],\n            pageX: viewBox[0],\n            pageY: viewBox[1]\n        });\n    }\n    clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.viewBox.slice(),\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    convertToViewportPoint(x, y) {\n        return Util.applyTransform([\n            x,\n            y\n        ], this.transform);\n    }\n    convertToViewportRectangle(rect) {\n        const topLeft = Util.applyTransform([\n            rect[0],\n            rect[1]\n        ], this.transform);\n        const bottomRight = Util.applyTransform([\n            rect[2],\n            rect[3]\n        ], this.transform);\n        return [\n            topLeft[0],\n            topLeft[1],\n            bottomRight[0],\n            bottomRight[1]\n        ];\n    }\n    convertToPdfPoint(x, y) {\n        return Util.applyInverseTransform([\n            x,\n            y\n        ], this.transform);\n    }\n}\nclass RenderingCancelledException extends BaseException {\n    constructor(msg, extraDelay = 0){\n        super(msg, \"RenderingCancelledException\");\n        this.extraDelay = extraDelay;\n    }\n}\nfunction isDataScheme(url) {\n    const ii = url.length;\n    let i = 0;\n    while(i < ii && url[i].trim() === \"\"){\n        i++;\n    }\n    return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n    return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n    [url] = url.split(/[#?]/, 1);\n    return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n    if (typeof url !== \"string\") {\n        return defaultFilename;\n    }\n    if (isDataScheme(url)) {\n        warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n        return defaultFilename;\n    }\n    const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const splitURI = reURI.exec(url);\n    let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n    if (suggestedFilename) {\n        suggestedFilename = suggestedFilename[0];\n        if (suggestedFilename.includes(\"%\")) {\n            try {\n                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n            } catch  {}\n        }\n    }\n    return suggestedFilename || defaultFilename;\n}\nclass StatTimer {\n    time(name) {\n        if (name in this.started) {\n            warn(`Timer is already running for ${name}`);\n        }\n        this.started[name] = Date.now();\n    }\n    timeEnd(name) {\n        if (!(name in this.started)) {\n            warn(`Timer has not been started for ${name}`);\n        }\n        this.times.push({\n            name,\n            start: this.started[name],\n            end: Date.now()\n        });\n        delete this.started[name];\n    }\n    toString() {\n        const outBuf = [];\n        let longest = 0;\n        for (const { name } of this.times){\n            longest = Math.max(name.length, longest);\n        }\n        for (const { name, start, end } of this.times){\n            outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n        }\n        return outBuf.join(\"\");\n    }\n    constructor(){\n        this.started = Object.create(null);\n        this.times = [];\n    }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n    try {\n        const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n        return protocol === \"http:\" || protocol === \"https:\";\n    } catch  {\n        return false;\n    }\n}\nfunction noContextMenu(e) {\n    e.preventDefault();\n}\nfunction deprecated(details) {\n    console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n    static #regex;\n    static toDateObject(input) {\n        if (!input || typeof input !== \"string\") {\n            return null;\n        }\n        this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n        const matches = this.#regex.exec(input);\n        if (!matches) {\n            return null;\n        }\n        const year = parseInt(matches[1], 10);\n        let month = parseInt(matches[2], 10);\n        month = month >= 1 && month <= 12 ? month - 1 : 0;\n        let day = parseInt(matches[3], 10);\n        day = day >= 1 && day <= 31 ? day : 1;\n        let hour = parseInt(matches[4], 10);\n        hour = hour >= 0 && hour <= 23 ? hour : 0;\n        let minute = parseInt(matches[5], 10);\n        minute = minute >= 0 && minute <= 59 ? minute : 0;\n        let second = parseInt(matches[6], 10);\n        second = second >= 0 && second <= 59 ? second : 0;\n        const universalTimeRelation = matches[7] || \"Z\";\n        let offsetHour = parseInt(matches[8], 10);\n        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n        let offsetMinute = parseInt(matches[9], 10) || 0;\n        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n        if (universalTimeRelation === \"-\") {\n            hour += offsetHour;\n            minute += offsetMinute;\n        } else if (universalTimeRelation === \"+\") {\n            hour -= offsetHour;\n            minute -= offsetMinute;\n        }\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n}\nfunction getXfaPageViewport(xfaPage, { scale = 1, rotation = 0 }) {\n    const { width, height } = xfaPage.attributes.style;\n    const viewBox = [\n        0,\n        0,\n        parseInt(width),\n        parseInt(height)\n    ];\n    return new PageViewport({\n        viewBox,\n        scale,\n        rotation\n    });\n}\nfunction getRGB(color) {\n    if (color.startsWith(\"#\")) {\n        const colorRGB = parseInt(color.slice(1), 16);\n        return [\n            (colorRGB & 0xff0000) >> 16,\n            (colorRGB & 0x00ff00) >> 8,\n            colorRGB & 0x0000ff\n        ];\n    }\n    if (color.startsWith(\"rgb(\")) {\n        return color.slice(4, -1).split(\",\").map((x)=>parseInt(x));\n    }\n    if (color.startsWith(\"rgba(\")) {\n        return color.slice(5, -1).split(\",\").map((x)=>parseInt(x)).slice(0, 3);\n    }\n    warn(`Not a valid color format: \"${color}\"`);\n    return [\n        0,\n        0,\n        0\n    ];\n}\nfunction getColorValues(colors) {\n    const span = document.createElement(\"span\");\n    span.style.visibility = \"hidden\";\n    document.body.append(span);\n    for (const name of colors.keys()){\n        span.style.color = name;\n        const computedColor = window.getComputedStyle(span).color;\n        colors.set(name, getRGB(computedColor));\n    }\n    span.remove();\n}\nfunction getCurrentTransform(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction getCurrentTransformInverse(ctx) {\n    const { a, b, c, d, e, f } = ctx.getTransform().invertSelf();\n    return [\n        a,\n        b,\n        c,\n        d,\n        e,\n        f\n    ];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n    if (viewport instanceof PageViewport) {\n        const { pageWidth, pageHeight } = viewport.rawDims;\n        const { style } = div;\n        const useRound = util_FeatureTest.isCSSRoundSupported;\n        const w = `var(--scale-factor) * ${pageWidth}px`, h = `var(--scale-factor) * ${pageHeight}px`;\n        const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x, 1px))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y, 1px))` : `calc(${h})`;\n        if (!mustFlip || viewport.rotation % 180 === 0) {\n            style.width = widthStr;\n            style.height = heightStr;\n        } else {\n            style.width = heightStr;\n            style.height = widthStr;\n        }\n    }\n    if (mustRotate) {\n        div.setAttribute(\"data-main-rotation\", viewport.rotation);\n    }\n}\nclass OutputScale {\n    constructor(){\n        const pixelRatio = window.devicePixelRatio || 1;\n        this.sx = pixelRatio;\n        this.sy = pixelRatio;\n    }\n    get scaled() {\n        return this.sx !== 1 || this.sy !== 1;\n    }\n    get symmetric() {\n        return this.sx === this.sy;\n    }\n}\n; // ./src/display/editor/toolbar.js\nclass EditorToolbar {\n    #toolbar;\n    #colorPicker;\n    #editor;\n    #buttons;\n    #altText;\n    static #l10nRemove = null;\n    constructor(editor){\n        this.#toolbar = null;\n        this.#colorPicker = null;\n        this.#buttons = null;\n        this.#altText = null;\n        this.#editor = editor;\n        EditorToolbar.#l10nRemove ||= Object.freeze({\n            freetext: \"pdfjs-editor-remove-freetext-button\",\n            highlight: \"pdfjs-editor-remove-highlight-button\",\n            ink: \"pdfjs-editor-remove-ink-button\",\n            stamp: \"pdfjs-editor-remove-stamp-button\"\n        });\n    }\n    render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.classList.add(\"editToolbar\", \"hidden\");\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        const signal = this.#editor._uiManager._signal;\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n            signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        const position = this.#editor.toolbarPosition;\n        if (position) {\n            const { style } = editToolbar;\n            const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n            style.insetInlineEnd = `${100 * x}%`;\n            style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n        }\n        this.#addDeleteButton();\n        return editToolbar;\n    }\n    get div() {\n        return this.#toolbar;\n    }\n    static #pointerDown(e) {\n        e.stopPropagation();\n    }\n    #focusIn(e) {\n        this.#editor._focusEventsAllowed = false;\n        e.preventDefault();\n        e.stopPropagation();\n    }\n    #focusOut(e) {\n        this.#editor._focusEventsAllowed = true;\n        e.preventDefault();\n        e.stopPropagation();\n    }\n    #addListenersToElement(element) {\n        const signal = this.#editor._uiManager._signal;\n        element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n            capture: true,\n            signal\n        });\n        element.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n    }\n    hide() {\n        this.#toolbar.classList.add(\"hidden\");\n        this.#colorPicker?.hideDropdown();\n    }\n    show() {\n        this.#toolbar.classList.remove(\"hidden\");\n        this.#altText?.shown();\n    }\n    #addDeleteButton() {\n        const { editorType, _uiManager } = this.#editor;\n        const button = document.createElement(\"button\");\n        button.className = \"delete\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n        this.#addListenersToElement(button);\n        button.addEventListener(\"click\", (e)=>{\n            _uiManager.delete();\n        }, {\n            signal: _uiManager._signal\n        });\n        this.#buttons.append(button);\n    }\n    get #divider() {\n        const divider = document.createElement(\"div\");\n        divider.className = \"divider\";\n        return divider;\n    }\n    async addAltText(altText) {\n        const button = await altText.render();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n        this.#altText = altText;\n    }\n    addColorPicker(colorPicker) {\n        this.#colorPicker = colorPicker;\n        const button = colorPicker.renderButton();\n        this.#addListenersToElement(button);\n        this.#buttons.prepend(button, this.#divider);\n    }\n    remove() {\n        this.#toolbar.remove();\n        this.#colorPicker?.destroy();\n        this.#colorPicker = null;\n    }\n}\nclass HighlightToolbar {\n    #buttons;\n    #toolbar;\n    #uiManager;\n    constructor(uiManager){\n        this.#buttons = null;\n        this.#toolbar = null;\n        this.#uiManager = uiManager;\n    }\n    #render() {\n        const editToolbar = this.#toolbar = document.createElement(\"div\");\n        editToolbar.className = \"editToolbar\";\n        editToolbar.setAttribute(\"role\", \"toolbar\");\n        editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n            signal: this.#uiManager._signal\n        });\n        const buttons = this.#buttons = document.createElement(\"div\");\n        buttons.className = \"buttons\";\n        editToolbar.append(buttons);\n        this.#addHighlightButton();\n        return editToolbar;\n    }\n    #getLastPoint(boxes, isLTR) {\n        let lastY = 0;\n        let lastX = 0;\n        for (const box of boxes){\n            const y = box.y + box.height;\n            if (y < lastY) {\n                continue;\n            }\n            const x = box.x + (isLTR ? box.width : 0);\n            if (y > lastY) {\n                lastX = x;\n                lastY = y;\n                continue;\n            }\n            if (isLTR) {\n                if (x > lastX) {\n                    lastX = x;\n                }\n            } else if (x < lastX) {\n                lastX = x;\n            }\n        }\n        return [\n            isLTR ? 1 - lastX : lastX,\n            lastY\n        ];\n    }\n    show(parent, boxes, isLTR) {\n        const [x, y] = this.#getLastPoint(boxes, isLTR);\n        const { style } = this.#toolbar ||= this.#render();\n        parent.append(this.#toolbar);\n        style.insetInlineEnd = `${100 * x}%`;\n        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n    }\n    hide() {\n        this.#toolbar.remove();\n    }\n    #addHighlightButton() {\n        const button = document.createElement(\"button\");\n        button.className = \"highlightButton\";\n        button.tabIndex = 0;\n        button.setAttribute(\"data-l10n-id\", `pdfjs-highlight-floating-button1`);\n        const span = document.createElement(\"span\");\n        button.append(span);\n        span.className = \"visuallyHidden\";\n        span.setAttribute(\"data-l10n-id\", \"pdfjs-highlight-floating-button-label\");\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        button.addEventListener(\"click\", ()=>{\n            this.#uiManager.highlightSelection(\"floating_button\");\n        }, {\n            signal\n        });\n        this.#buttons.append(button);\n    }\n}\n; // ./src/display/editor/tools.js\nfunction bindEvents(obj, element, names) {\n    for (const name of names){\n        element.addEventListener(name, obj[name].bind(obj));\n    }\n}\nfunction opacityToHex(opacity) {\n    return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\nclass IdManager {\n    #id;\n    get id() {\n        return `${AnnotationEditorPrefix}${this.#id++}`;\n    }\n    constructor(){\n        this.#id = 0;\n    }\n}\nclass ImageManager {\n    #baseId;\n    #id;\n    #cache;\n    static get _isSVGFittingCanvas() {\n        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n        const canvas = new OffscreenCanvas(1, 3);\n        const ctx = canvas.getContext(\"2d\", {\n            willReadFrequently: true\n        });\n        const image = new Image();\n        image.src = svg;\n        const promise = image.decode().then(()=>{\n            ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n            return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n        });\n        return shadow(this, \"_isSVGFittingCanvas\", promise);\n    }\n    async #get(key, rawData) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(key);\n        if (data === null) {\n            return null;\n        }\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        try {\n            data ||= {\n                bitmap: null,\n                id: `image_${this.#baseId}_${this.#id++}`,\n                refCounter: 0,\n                isSvg: false\n            };\n            let image;\n            if (typeof rawData === \"string\") {\n                data.url = rawData;\n                image = await fetchData(rawData, \"blob\");\n            } else if (rawData instanceof File) {\n                image = data.file = rawData;\n            } else if (rawData instanceof Blob) {\n                image = rawData;\n            }\n            if (image.type === \"image/svg+xml\") {\n                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n                const fileReader = new FileReader();\n                const imageElement = new Image();\n                const imagePromise = new Promise((resolve, reject)=>{\n                    imageElement.onload = ()=>{\n                        data.bitmap = imageElement;\n                        data.isSvg = true;\n                        resolve();\n                    };\n                    fileReader.onload = async ()=>{\n                        const url = data.svgUrl = fileReader.result;\n                        imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;\n                    };\n                    imageElement.onerror = fileReader.onerror = reject;\n                });\n                fileReader.readAsDataURL(image);\n                await imagePromise;\n            } else {\n                data.bitmap = await createImageBitmap(image);\n            }\n            data.refCounter = 1;\n        } catch (e) {\n            console.error(e);\n            data = null;\n        }\n        this.#cache.set(key, data);\n        if (data) {\n            this.#cache.set(data.id, data);\n        }\n        return data;\n    }\n    async getFromFile(file) {\n        const { lastModified, name, size, type } = file;\n        return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n    }\n    async getFromUrl(url) {\n        return this.#get(url, url);\n    }\n    async getFromBlob(id, blobPromise) {\n        const blob = await blobPromise;\n        return this.#get(id, blob);\n    }\n    async getFromId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return null;\n        }\n        if (data.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        if (data.file) {\n            return this.getFromFile(data.file);\n        }\n        if (data.blobPromise) {\n            const { blobPromise } = data;\n            delete data.blobPromise;\n            return this.getFromBlob(data.id, blobPromise);\n        }\n        return this.getFromUrl(data.url);\n    }\n    getFromCanvas(id, canvas) {\n        this.#cache ||= new Map();\n        let data = this.#cache.get(id);\n        if (data?.bitmap) {\n            data.refCounter += 1;\n            return data;\n        }\n        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(canvas, 0, 0);\n        data = {\n            bitmap: offscreen.transferToImageBitmap(),\n            id: `image_${this.#baseId}_${this.#id++}`,\n            refCounter: 1,\n            isSvg: false\n        };\n        this.#cache.set(id, data);\n        this.#cache.set(data.id, data);\n        return data;\n    }\n    getSvgUrl(id) {\n        const data = this.#cache.get(id);\n        if (!data?.isSvg) {\n            return null;\n        }\n        return data.svgUrl;\n    }\n    deleteId(id) {\n        this.#cache ||= new Map();\n        const data = this.#cache.get(id);\n        if (!data) {\n            return;\n        }\n        data.refCounter -= 1;\n        if (data.refCounter !== 0) {\n            return;\n        }\n        const { bitmap } = data;\n        if (!data.url && !data.file) {\n            const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n            const ctx = canvas.getContext(\"bitmaprenderer\");\n            ctx.transferFromImageBitmap(bitmap);\n            data.blobPromise = canvas.convertToBlob();\n        }\n        bitmap.close?.();\n        data.bitmap = null;\n    }\n    isValidId(id) {\n        return id.startsWith(`image_${this.#baseId}_`);\n    }\n    constructor(){\n        this.#baseId = getUuid();\n        this.#id = 0;\n        this.#cache = null;\n    }\n}\nclass CommandManager {\n    #commands;\n    #locked;\n    #maxSize;\n    #position;\n    constructor(maxSize = 128){\n        this.#commands = [];\n        this.#locked = false;\n        this.#position = -1;\n        this.#maxSize = maxSize;\n    }\n    add({ cmd, undo, post, mustExec, type = NaN, overwriteIfSameType = false, keepUndo = false }) {\n        if (mustExec) {\n            cmd();\n        }\n        if (this.#locked) {\n            return;\n        }\n        const save = {\n            cmd,\n            undo,\n            post,\n            type\n        };\n        if (this.#position === -1) {\n            if (this.#commands.length > 0) {\n                this.#commands.length = 0;\n            }\n            this.#position = 0;\n            this.#commands.push(save);\n            return;\n        }\n        if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n            if (keepUndo) {\n                save.undo = this.#commands[this.#position].undo;\n            }\n            this.#commands[this.#position] = save;\n            return;\n        }\n        const next = this.#position + 1;\n        if (next === this.#maxSize) {\n            this.#commands.splice(0, 1);\n        } else {\n            this.#position = next;\n            if (next < this.#commands.length) {\n                this.#commands.splice(next);\n            }\n        }\n        this.#commands.push(save);\n    }\n    undo() {\n        if (this.#position === -1) {\n            return;\n        }\n        this.#locked = true;\n        const { undo, post } = this.#commands[this.#position];\n        undo();\n        post?.();\n        this.#locked = false;\n        this.#position -= 1;\n    }\n    redo() {\n        if (this.#position < this.#commands.length - 1) {\n            this.#position += 1;\n            this.#locked = true;\n            const { cmd, post } = this.#commands[this.#position];\n            cmd();\n            post?.();\n            this.#locked = false;\n        }\n    }\n    hasSomethingToUndo() {\n        return this.#position !== -1;\n    }\n    hasSomethingToRedo() {\n        return this.#position < this.#commands.length - 1;\n    }\n    destroy() {\n        this.#commands = null;\n    }\n}\nclass KeyboardManager {\n    constructor(callbacks){\n        this.buffer = [];\n        this.callbacks = new Map();\n        this.allKeys = new Set();\n        const { isMac } = util_FeatureTest.platform;\n        for (const [keys, callback, options = {}] of callbacks){\n            for (const key of keys){\n                const isMacKey = key.startsWith(\"mac+\");\n                if (isMac && isMacKey) {\n                    this.callbacks.set(key.slice(4), {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                } else if (!isMac && !isMacKey) {\n                    this.callbacks.set(key, {\n                        callback,\n                        options\n                    });\n                    this.allKeys.add(key.split(\"+\").at(-1));\n                }\n            }\n        }\n    }\n    #serialize(event) {\n        if (event.altKey) {\n            this.buffer.push(\"alt\");\n        }\n        if (event.ctrlKey) {\n            this.buffer.push(\"ctrl\");\n        }\n        if (event.metaKey) {\n            this.buffer.push(\"meta\");\n        }\n        if (event.shiftKey) {\n            this.buffer.push(\"shift\");\n        }\n        this.buffer.push(event.key);\n        const str = this.buffer.join(\"+\");\n        this.buffer.length = 0;\n        return str;\n    }\n    exec(self, event) {\n        if (!this.allKeys.has(event.key)) {\n            return;\n        }\n        const info = this.callbacks.get(this.#serialize(event));\n        if (!info) {\n            return;\n        }\n        const { callback, options: { bubbles = false, args = [], checker = null } } = info;\n        if (checker && !checker(self, event)) {\n            return;\n        }\n        callback.bind(self, ...args, event)();\n        if (!bubbles) {\n            event.stopPropagation();\n            event.preventDefault();\n        }\n    }\n}\nclass ColorManager {\n    static{\n        this._colorsMapping = new Map([\n            [\n                \"CanvasText\",\n                [\n                    0,\n                    0,\n                    0\n                ]\n            ],\n            [\n                \"Canvas\",\n                [\n                    255,\n                    255,\n                    255\n                ]\n            ]\n        ]);\n    }\n    get _colors() {\n        const colors = new Map([\n            [\n                \"CanvasText\",\n                null\n            ],\n            [\n                \"Canvas\",\n                null\n            ]\n        ]);\n        getColorValues(colors);\n        return shadow(this, \"_colors\", colors);\n    }\n    convert(color) {\n        const rgb = getRGB(color);\n        if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n            return rgb;\n        }\n        for (const [name, RGB] of this._colors){\n            if (RGB.every((x, i)=>x === rgb[i])) {\n                return ColorManager._colorsMapping.get(name);\n            }\n        }\n        return rgb;\n    }\n    getHexCode(name) {\n        const rgb = this._colors.get(name);\n        if (!rgb) {\n            return name;\n        }\n        return Util.makeHexColor(...rgb);\n    }\n}\nclass AnnotationEditorUIManager {\n    #abortController;\n    #activeEditor;\n    #allEditors;\n    #allLayers;\n    #altTextManager;\n    #annotationStorage;\n    #changedExistingAnnotations;\n    #commandManager;\n    #copyPasteAC;\n    #currentPageIndex;\n    #deletedAnnotationsElementIds;\n    #draggingEditors;\n    #editorTypes;\n    #editorsToRescale;\n    #enableHighlightFloatingButton;\n    #enableUpdatedAddImage;\n    #enableNewAltTextWhenAddingImage;\n    #filterFactory;\n    #focusMainContainerTimeoutId;\n    #focusManagerAC;\n    #highlightColors;\n    #highlightWhenShiftUp;\n    #highlightToolbar;\n    #idManager;\n    #isEnabled;\n    #isWaiting;\n    #keyboardManagerAC;\n    #lastActiveElement;\n    #mainHighlightColorPicker;\n    #mlManager;\n    #mode;\n    #selectedEditors;\n    #selectedTextNode;\n    #pageColors;\n    #showAllStates;\n    #previousStates;\n    #translation;\n    #translationTimeoutId;\n    #container;\n    #viewer;\n    #updateModeCapability;\n    static{\n        this.TRANSLATE_SMALL = 1;\n    }\n    static{\n        this.TRANSLATE_BIG = 10;\n    }\n    static get _keyboardManager() {\n        const proto = AnnotationEditorUIManager.prototype;\n        const arrowChecker = (self)=>self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n        const textInputChecker = (_self, { target: el })=>{\n            if (el instanceof HTMLInputElement) {\n                const { type } = el;\n                return type !== \"text\" && type !== \"number\";\n            }\n            return true;\n        };\n        const small = this.TRANSLATE_SMALL;\n        const big = this.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+a\",\n                    \"mac+meta+a\"\n                ],\n                proto.selectAll,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+z\",\n                    \"mac+meta+z\"\n                ],\n                proto.undo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+y\",\n                    \"ctrl+shift+z\",\n                    \"mac+meta+shift+z\",\n                    \"ctrl+shift+Z\",\n                    \"mac+meta+shift+Z\"\n                ],\n                proto.redo,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Backspace\",\n                    \"alt+Backspace\",\n                    \"ctrl+Backspace\",\n                    \"shift+Backspace\",\n                    \"mac+Backspace\",\n                    \"mac+alt+Backspace\",\n                    \"mac+ctrl+Backspace\",\n                    \"Delete\",\n                    \"ctrl+Delete\",\n                    \"shift+Delete\",\n                    \"mac+Delete\"\n                ],\n                proto.delete,\n                {\n                    checker: textInputChecker\n                }\n            ],\n            [\n                [\n                    \"Enter\",\n                    \"mac+Enter\"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n                }\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                proto.addNewEditorFromKeyboard,\n                {\n                    checker: (self, { target: el })=>!(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.unselectAll\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto.translateSelectedEditors,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager){\n        this.#abortController = new AbortController();\n        this.#activeEditor = null;\n        this.#allEditors = new Map();\n        this.#allLayers = new Map();\n        this.#altTextManager = null;\n        this.#annotationStorage = null;\n        this.#changedExistingAnnotations = null;\n        this.#commandManager = new CommandManager();\n        this.#copyPasteAC = null;\n        this.#currentPageIndex = 0;\n        this.#deletedAnnotationsElementIds = new Set();\n        this.#draggingEditors = null;\n        this.#editorTypes = null;\n        this.#editorsToRescale = new Set();\n        this.#enableHighlightFloatingButton = false;\n        this.#enableUpdatedAddImage = false;\n        this.#enableNewAltTextWhenAddingImage = false;\n        this.#filterFactory = null;\n        this.#focusMainContainerTimeoutId = null;\n        this.#focusManagerAC = null;\n        this.#highlightColors = null;\n        this.#highlightWhenShiftUp = false;\n        this.#highlightToolbar = null;\n        this.#idManager = new IdManager();\n        this.#isEnabled = false;\n        this.#isWaiting = false;\n        this.#keyboardManagerAC = null;\n        this.#lastActiveElement = null;\n        this.#mainHighlightColorPicker = null;\n        this.#mlManager = null;\n        this.#mode = AnnotationEditorType.NONE;\n        this.#selectedEditors = new Set();\n        this.#selectedTextNode = null;\n        this.#pageColors = null;\n        this.#showAllStates = null;\n        this.#previousStates = {\n            isEditing: false,\n            isEmpty: true,\n            hasSomethingToUndo: false,\n            hasSomethingToRedo: false,\n            hasSelectedEditor: false,\n            hasSelectedText: false\n        };\n        this.#translation = [\n            0,\n            0\n        ];\n        this.#translationTimeoutId = null;\n        this.#container = null;\n        this.#viewer = null;\n        this.#updateModeCapability = null;\n        const signal = this._signal = this.#abortController.signal;\n        this.#container = container;\n        this.#viewer = viewer;\n        this.#altTextManager = altTextManager;\n        this._eventBus = eventBus;\n        eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n            signal\n        });\n        eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n            signal\n        });\n        eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n            signal\n        });\n        eventBus._on(\"switchannotationeditorparams\", (evt)=>this.updateParams(evt.type, evt.value), {\n            signal\n        });\n        this.#addSelectionListener();\n        this.#addDragAndDropListeners();\n        this.#addKeyboardManager();\n        this.#annotationStorage = pdfDocument.annotationStorage;\n        this.#filterFactory = pdfDocument.filterFactory;\n        this.#pageColors = pageColors;\n        this.#highlightColors = highlightColors || null;\n        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n        this.#enableUpdatedAddImage = enableUpdatedAddImage;\n        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n        this.#mlManager = mlManager || null;\n        this.viewParameters = {\n            realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n            rotation: 0\n        };\n        this.isShiftKeyDown = false;\n    }\n    destroy() {\n        this.#updateModeCapability?.resolve();\n        this.#updateModeCapability = null;\n        this.#abortController?.abort();\n        this.#abortController = null;\n        this._signal = null;\n        for (const layer of this.#allLayers.values()){\n            layer.destroy();\n        }\n        this.#allLayers.clear();\n        this.#allEditors.clear();\n        this.#editorsToRescale.clear();\n        this.#activeEditor = null;\n        this.#selectedEditors.clear();\n        this.#commandManager.destroy();\n        this.#altTextManager?.destroy();\n        this.#highlightToolbar?.hide();\n        this.#highlightToolbar = null;\n        if (this.#focusMainContainerTimeoutId) {\n            clearTimeout(this.#focusMainContainerTimeoutId);\n            this.#focusMainContainerTimeoutId = null;\n        }\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n            this.#translationTimeoutId = null;\n        }\n    }\n    combinedSignal(ac) {\n        return AbortSignal.any([\n            this._signal,\n            ac.signal\n        ]);\n    }\n    get mlManager() {\n        return this.#mlManager;\n    }\n    get useNewAltTextFlow() {\n        return this.#enableUpdatedAddImage;\n    }\n    get useNewAltTextWhenAddingImage() {\n        return this.#enableNewAltTextWhenAddingImage;\n    }\n    get hcmFilter() {\n        return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n    }\n    get direction() {\n        return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n    }\n    get highlightColors() {\n        return shadow(this, \"highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map((pair)=>pair.split(\"=\").map((x)=>x.trim()))) : null);\n    }\n    get highlightColorNames() {\n        return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, (e)=>e.reverse())) : null);\n    }\n    setMainHighlightColorPicker(colorPicker) {\n        this.#mainHighlightColorPicker = colorPicker;\n    }\n    editAltText(editor, firstTime = false) {\n        this.#altTextManager?.editAltText(this, editor, firstTime);\n    }\n    switchToMode(mode, callback) {\n        this._eventBus.on(\"annotationeditormodechanged\", callback, {\n            once: true,\n            signal: this._signal\n        });\n        this._eventBus.dispatch(\"showannotationeditorui\", {\n            source: this,\n            mode\n        });\n    }\n    setPreference(name, value) {\n        this._eventBus.dispatch(\"setpreference\", {\n            source: this,\n            name,\n            value\n        });\n    }\n    onSetPreference({ name, value }) {\n        switch(name){\n            case \"enableNewAltTextWhenAddingImage\":\n                this.#enableNewAltTextWhenAddingImage = value;\n                break;\n        }\n    }\n    onPageChanging({ pageNumber }) {\n        this.#currentPageIndex = pageNumber - 1;\n    }\n    focusMainContainer() {\n        this.#container.focus();\n    }\n    findParent(x, y) {\n        for (const layer of this.#allLayers.values()){\n            const { x: layerX, y: layerY, width, height } = layer.div.getBoundingClientRect();\n            if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    disableUserSelect(value = false) {\n        this.#viewer.classList.toggle(\"noUserSelect\", value);\n    }\n    addShouldRescale(editor) {\n        this.#editorsToRescale.add(editor);\n    }\n    removeShouldRescale(editor) {\n        this.#editorsToRescale.delete(editor);\n    }\n    onScaleChanging({ scale }) {\n        this.commitOrRemove();\n        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n        for (const editor of this.#editorsToRescale){\n            editor.onScaleChanging();\n        }\n    }\n    onRotationChanging({ pagesRotation }) {\n        this.commitOrRemove();\n        this.viewParameters.rotation = pagesRotation;\n    }\n    #getAnchorElementForSelection({ anchorNode }) {\n        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n    }\n    #getLayerForTextLayer(textLayer) {\n        const { currentLayer } = this;\n        if (currentLayer.hasTextLayer(textLayer)) {\n            return currentLayer;\n        }\n        for (const layer of this.#allLayers.values()){\n            if (layer.hasTextLayer(textLayer)) {\n                return layer;\n            }\n        }\n        return null;\n    }\n    highlightSelection(methodOfCreation = \"\") {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const { anchorNode, anchorOffset, focusNode, focusOffset } = selection;\n        const text = selection.toString();\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        selection.empty();\n        const layer = this.#getLayerForTextLayer(textLayer);\n        const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n        const callback = ()=>{\n            layer?.createAndAddNewEditor({\n                x: 0,\n                y: 0\n            }, false, {\n                methodOfCreation,\n                boxes,\n                anchorNode,\n                anchorOffset,\n                focusNode,\n                focusOffset,\n                text\n            });\n            if (isNoneMode) {\n                this.showAllEditors(\"highlight\", true, true);\n            }\n        };\n        if (isNoneMode) {\n            this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n            return;\n        }\n        callback();\n    }\n    #displayHighlightToolbar() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        const boxes = this.getSelectionBoxes(textLayer);\n        if (!boxes) {\n            return;\n        }\n        this.#highlightToolbar ||= new HighlightToolbar(this);\n        this.#highlightToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n    }\n    addToAnnotationStorage(editor) {\n        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n            this.#annotationStorage.setValue(editor.id, editor);\n        }\n    }\n    #selectionChange() {\n        const selection = document.getSelection();\n        if (!selection || selection.isCollapsed) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        const { anchorNode } = selection;\n        if (anchorNode === this.#selectedTextNode) {\n            return;\n        }\n        const anchorElement = this.#getAnchorElementForSelection(selection);\n        const textLayer = anchorElement.closest(\".textLayer\");\n        if (!textLayer) {\n            if (this.#selectedTextNode) {\n                this.#highlightToolbar?.hide();\n                this.#selectedTextNode = null;\n                this.#dispatchUpdateStates({\n                    hasSelectedText: false\n                });\n            }\n            return;\n        }\n        this.#highlightToolbar?.hide();\n        this.#selectedTextNode = anchorNode;\n        this.#dispatchUpdateStates({\n            hasSelectedText: true\n        });\n        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.showAllEditors(\"highlight\", true, true);\n        }\n        this.#highlightWhenShiftUp = this.isShiftKeyDown;\n        if (!this.isShiftKeyDown) {\n            const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n            activeLayer?.toggleDrawing();\n            const ac = new AbortController();\n            const signal = this.combinedSignal(ac);\n            const pointerup = (e)=>{\n                if (e.type === \"pointerup\" && e.button !== 0) {\n                    return;\n                }\n                ac.abort();\n                activeLayer?.toggleDrawing(true);\n                if (e.type === \"pointerup\") {\n                    this.#onSelectEnd(\"main_toolbar\");\n                }\n            };\n            window.addEventListener(\"pointerup\", pointerup, {\n                signal\n            });\n            window.addEventListener(\"blur\", pointerup, {\n                signal\n            });\n        }\n    }\n    #onSelectEnd(methodOfCreation = \"\") {\n        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n            this.highlightSelection(methodOfCreation);\n        } else if (this.#enableHighlightFloatingButton) {\n            this.#displayHighlightToolbar();\n        }\n    }\n    #addSelectionListener() {\n        document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n            signal: this._signal\n        });\n    }\n    #addFocusManager() {\n        if (this.#focusManagerAC) {\n            return;\n        }\n        this.#focusManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#focusManagerAC);\n        window.addEventListener(\"focus\", this.focus.bind(this), {\n            signal\n        });\n        window.addEventListener(\"blur\", this.blur.bind(this), {\n            signal\n        });\n    }\n    #removeFocusManager() {\n        this.#focusManagerAC?.abort();\n        this.#focusManagerAC = null;\n    }\n    blur() {\n        this.isShiftKeyDown = false;\n        if (this.#highlightWhenShiftUp) {\n            this.#highlightWhenShiftUp = false;\n            this.#onSelectEnd(\"main_toolbar\");\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        const { activeElement } = document;\n        for (const editor of this.#selectedEditors){\n            if (editor.div.contains(activeElement)) {\n                this.#lastActiveElement = [\n                    editor,\n                    activeElement\n                ];\n                editor._focusEventsAllowed = false;\n                break;\n            }\n        }\n    }\n    focus() {\n        if (!this.#lastActiveElement) {\n            return;\n        }\n        const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n        this.#lastActiveElement = null;\n        lastActiveElement.addEventListener(\"focusin\", ()=>{\n            lastEditor._focusEventsAllowed = true;\n        }, {\n            once: true,\n            signal: this._signal\n        });\n        lastActiveElement.focus();\n    }\n    #addKeyboardManager() {\n        if (this.#keyboardManagerAC) {\n            return;\n        }\n        this.#keyboardManagerAC = new AbortController();\n        const signal = this.combinedSignal(this.#keyboardManagerAC);\n        window.addEventListener(\"keydown\", this.keydown.bind(this), {\n            signal\n        });\n        window.addEventListener(\"keyup\", this.keyup.bind(this), {\n            signal\n        });\n    }\n    #removeKeyboardManager() {\n        this.#keyboardManagerAC?.abort();\n        this.#keyboardManagerAC = null;\n    }\n    #addCopyPasteListeners() {\n        if (this.#copyPasteAC) {\n            return;\n        }\n        this.#copyPasteAC = new AbortController();\n        const signal = this.combinedSignal(this.#copyPasteAC);\n        document.addEventListener(\"copy\", this.copy.bind(this), {\n            signal\n        });\n        document.addEventListener(\"cut\", this.cut.bind(this), {\n            signal\n        });\n        document.addEventListener(\"paste\", this.paste.bind(this), {\n            signal\n        });\n    }\n    #removeCopyPasteListeners() {\n        this.#copyPasteAC?.abort();\n        this.#copyPasteAC = null;\n    }\n    #addDragAndDropListeners() {\n        const signal = this._signal;\n        document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n            signal\n        });\n        document.addEventListener(\"drop\", this.drop.bind(this), {\n            signal\n        });\n    }\n    addEditListeners() {\n        this.#addKeyboardManager();\n        this.#addCopyPasteListeners();\n    }\n    removeEditListeners() {\n        this.#removeKeyboardManager();\n        this.#removeCopyPasteListeners();\n    }\n    dragOver(event) {\n        for (const { type } of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(type)) {\n                    event.dataTransfer.dropEffect = \"copy\";\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    drop(event) {\n        for (const item of event.dataTransfer.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    event.preventDefault();\n                    return;\n                }\n            }\n        }\n    }\n    copy(event) {\n        event.preventDefault();\n        this.#activeEditor?.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [];\n        for (const editor of this.#selectedEditors){\n            const serialized = editor.serialize(true);\n            if (serialized) {\n                editors.push(serialized);\n            }\n        }\n        if (editors.length === 0) {\n            return;\n        }\n        event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n    }\n    cut(event) {\n        this.copy(event);\n        this.delete();\n    }\n    async paste(event) {\n        event.preventDefault();\n        const { clipboardData } = event;\n        for (const item of clipboardData.items){\n            for (const editorType of this.#editorTypes){\n                if (editorType.isHandlingMimeForPasting(item.type)) {\n                    editorType.paste(item, this.currentLayer);\n                    return;\n                }\n            }\n        }\n        let data = clipboardData.getData(\"application/pdfjs\");\n        if (!data) {\n            return;\n        }\n        try {\n            data = JSON.parse(data);\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n            return;\n        }\n        if (!Array.isArray(data)) {\n            return;\n        }\n        this.unselectAll();\n        const layer = this.currentLayer;\n        try {\n            const newEditors = [];\n            for (const editor of data){\n                const deserializedEditor = await layer.deserialize(editor);\n                if (!deserializedEditor) {\n                    return;\n                }\n                newEditors.push(deserializedEditor);\n            }\n            const cmd = ()=>{\n                for (const editor of newEditors){\n                    this.#addEditorToLayer(editor);\n                }\n                this.#selectEditors(newEditors);\n            };\n            const undo = ()=>{\n                for (const editor of newEditors){\n                    editor.remove();\n                }\n            };\n            this.addCommands({\n                cmd,\n                undo,\n                mustExec: true\n            });\n        } catch (ex) {\n            warn(`paste: \"${ex.message}\".`);\n        }\n    }\n    keydown(event) {\n        if (!this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = true;\n        }\n        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n            AnnotationEditorUIManager._keyboardManager.exec(this, event);\n        }\n    }\n    keyup(event) {\n        if (this.isShiftKeyDown && event.key === \"Shift\") {\n            this.isShiftKeyDown = false;\n            if (this.#highlightWhenShiftUp) {\n                this.#highlightWhenShiftUp = false;\n                this.#onSelectEnd(\"main_toolbar\");\n            }\n        }\n    }\n    onEditingAction({ name }) {\n        switch(name){\n            case \"undo\":\n            case \"redo\":\n            case \"delete\":\n            case \"selectAll\":\n                this[name]();\n                break;\n            case \"highlightSelection\":\n                this.highlightSelection(\"context_menu\");\n                break;\n        }\n    }\n    #dispatchUpdateStates(details) {\n        const hasChanged = Object.entries(details).some(([key, value])=>this.#previousStates[key] !== value);\n        if (hasChanged) {\n            this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n                source: this,\n                details: Object.assign(this.#previousStates, details)\n            });\n            if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n                this.#dispatchUpdateUI([\n                    [\n                        AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                        true\n                    ]\n                ]);\n            }\n        }\n    }\n    #dispatchUpdateUI(details) {\n        this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n            source: this,\n            details\n        });\n    }\n    setEditingState(isEditing) {\n        if (isEditing) {\n            this.#addFocusManager();\n            this.#addCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: this.#mode !== AnnotationEditorType.NONE,\n                isEmpty: this.#isEmpty(),\n                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n                hasSelectedEditor: false\n            });\n        } else {\n            this.#removeFocusManager();\n            this.#removeCopyPasteListeners();\n            this.#dispatchUpdateStates({\n                isEditing: false\n            });\n            this.disableUserSelect(false);\n        }\n    }\n    registerEditorTypes(types) {\n        if (this.#editorTypes) {\n            return;\n        }\n        this.#editorTypes = types;\n        for (const editorType of this.#editorTypes){\n            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n        }\n    }\n    getId() {\n        return this.#idManager.id;\n    }\n    get currentLayer() {\n        return this.#allLayers.get(this.#currentPageIndex);\n    }\n    getLayer(pageIndex) {\n        return this.#allLayers.get(pageIndex);\n    }\n    get currentPageIndex() {\n        return this.#currentPageIndex;\n    }\n    addLayer(layer) {\n        this.#allLayers.set(layer.pageIndex, layer);\n        if (this.#isEnabled) {\n            layer.enable();\n        } else {\n            layer.disable();\n        }\n    }\n    removeLayer(layer) {\n        this.#allLayers.delete(layer.pageIndex);\n    }\n    async updateMode(mode, editId = null, isFromKeyboard = false) {\n        if (this.#mode === mode) {\n            return;\n        }\n        if (this.#updateModeCapability) {\n            await this.#updateModeCapability.promise;\n            if (!this.#updateModeCapability) {\n                return;\n            }\n        }\n        this.#updateModeCapability = Promise.withResolvers();\n        this.#mode = mode;\n        if (mode === AnnotationEditorType.NONE) {\n            this.setEditingState(false);\n            this.#disableAll();\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        this.setEditingState(true);\n        await this.#enableAll();\n        this.unselectAll();\n        for (const layer of this.#allLayers.values()){\n            layer.updateMode(mode);\n        }\n        if (!editId) {\n            if (isFromKeyboard) {\n                this.addNewEditorFromKeyboard();\n            }\n            this.#updateModeCapability.resolve();\n            return;\n        }\n        for (const editor of this.#allEditors.values()){\n            if (editor.annotationElementId === editId) {\n                this.setSelected(editor);\n                editor.enterInEditMode();\n            } else {\n                editor.unselect();\n            }\n        }\n        this.#updateModeCapability.resolve();\n    }\n    addNewEditorFromKeyboard() {\n        if (this.currentLayer.canCreateNewEmptyEditor()) {\n            this.currentLayer.addNewEditor();\n        }\n    }\n    updateToolbar(mode) {\n        if (mode === this.#mode) {\n            return;\n        }\n        this._eventBus.dispatch(\"switchannotationeditormode\", {\n            source: this,\n            mode\n        });\n    }\n    updateParams(type, value) {\n        if (!this.#editorTypes) {\n            return;\n        }\n        switch(type){\n            case AnnotationEditorParamsType.CREATE:\n                this.currentLayer.addNewEditor();\n                return;\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                this.#mainHighlightColorPicker?.updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n                this._eventBus.dispatch(\"reporttelemetry\", {\n                    source: this,\n                    details: {\n                        type: \"editing\",\n                        data: {\n                            type: \"highlight\",\n                            action: \"toggle_visibility\"\n                        }\n                    }\n                });\n                (this.#showAllStates ||= new Map()).set(type, value);\n                this.showAllEditors(\"highlight\", value);\n                break;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.updateParams(type, value);\n        }\n        for (const editorType of this.#editorTypes){\n            editorType.updateDefaultParams(type, value);\n        }\n    }\n    showAllEditors(type, visible, updateButton = false) {\n        for (const editor of this.#allEditors.values()){\n            if (editor.editorType === type) {\n                editor.show(visible);\n            }\n        }\n        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n        if (state !== visible) {\n            this.#dispatchUpdateUI([\n                [\n                    AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL,\n                    visible\n                ]\n            ]);\n        }\n    }\n    enableWaiting(mustWait = false) {\n        if (this.#isWaiting === mustWait) {\n            return;\n        }\n        this.#isWaiting = mustWait;\n        for (const layer of this.#allLayers.values()){\n            if (mustWait) {\n                layer.disableClick();\n            } else {\n                layer.enableClick();\n            }\n            layer.div.classList.toggle(\"waiting\", mustWait);\n        }\n    }\n    async #enableAll() {\n        if (!this.#isEnabled) {\n            this.#isEnabled = true;\n            const promises = [];\n            for (const layer of this.#allLayers.values()){\n                promises.push(layer.enable());\n            }\n            await Promise.all(promises);\n            for (const editor of this.#allEditors.values()){\n                editor.enable();\n            }\n        }\n    }\n    #disableAll() {\n        this.unselectAll();\n        if (this.#isEnabled) {\n            this.#isEnabled = false;\n            for (const layer of this.#allLayers.values()){\n                layer.disable();\n            }\n            for (const editor of this.#allEditors.values()){\n                editor.disable();\n            }\n        }\n    }\n    getEditors(pageIndex) {\n        const editors = [];\n        for (const editor of this.#allEditors.values()){\n            if (editor.pageIndex === pageIndex) {\n                editors.push(editor);\n            }\n        }\n        return editors;\n    }\n    getEditor(id) {\n        return this.#allEditors.get(id);\n    }\n    addEditor(editor) {\n        this.#allEditors.set(editor.id, editor);\n    }\n    removeEditor(editor) {\n        if (editor.div.contains(document.activeElement)) {\n            if (this.#focusMainContainerTimeoutId) {\n                clearTimeout(this.#focusMainContainerTimeoutId);\n            }\n            this.#focusMainContainerTimeoutId = setTimeout(()=>{\n                this.focusMainContainer();\n                this.#focusMainContainerTimeoutId = null;\n            }, 0);\n        }\n        this.#allEditors.delete(editor.id);\n        this.unselect(editor);\n        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n            this.#annotationStorage?.remove(editor.id);\n        }\n    }\n    addDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n        this.addChangedExistingAnnotation(editor);\n        editor.deleted = true;\n    }\n    isDeletedAnnotationElement(annotationElementId) {\n        return this.#deletedAnnotationsElementIds.has(annotationElementId);\n    }\n    removeDeletedAnnotationElement(editor) {\n        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n        this.removeChangedExistingAnnotation(editor);\n        editor.deleted = false;\n    }\n    #addEditorToLayer(editor) {\n        const layer = this.#allLayers.get(editor.pageIndex);\n        if (layer) {\n            layer.addOrRebuild(editor);\n        } else {\n            this.addEditor(editor);\n            this.addToAnnotationStorage(editor);\n        }\n    }\n    setActiveEditor(editor) {\n        if (this.#activeEditor === editor) {\n            return;\n        }\n        this.#activeEditor = editor;\n        if (editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    get #lastSelectedEditor() {\n        let ed = null;\n        for (ed of this.#selectedEditors){}\n        return ed;\n    }\n    updateUI(editor) {\n        if (this.#lastSelectedEditor === editor) {\n            this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        }\n    }\n    toggleSelected(editor) {\n        if (this.#selectedEditors.has(editor)) {\n            this.#selectedEditors.delete(editor);\n            editor.unselect();\n            this.#dispatchUpdateStates({\n                hasSelectedEditor: this.hasSelection\n            });\n            return;\n        }\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    setSelected(editor) {\n        for (const ed of this.#selectedEditors){\n            if (ed !== editor) {\n                ed.unselect();\n            }\n        }\n        this.#selectedEditors.clear();\n        this.#selectedEditors.add(editor);\n        editor.select();\n        this.#dispatchUpdateUI(editor.propertiesToUpdate);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: true\n        });\n    }\n    isSelected(editor) {\n        return this.#selectedEditors.has(editor);\n    }\n    get firstSelectedEditor() {\n        return this.#selectedEditors.values().next().value;\n    }\n    unselect(editor) {\n        editor.unselect();\n        this.#selectedEditors.delete(editor);\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    get hasSelection() {\n        return this.#selectedEditors.size !== 0;\n    }\n    get isEnterHandled() {\n        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n    }\n    undo() {\n        this.#commandManager.undo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n            hasSomethingToRedo: true,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    redo() {\n        this.#commandManager.redo();\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n            isEmpty: this.#isEmpty()\n        });\n    }\n    addCommands(params) {\n        this.#commandManager.add(params);\n        this.#dispatchUpdateStates({\n            hasSomethingToUndo: true,\n            hasSomethingToRedo: false,\n            isEmpty: this.#isEmpty()\n        });\n    }\n    #isEmpty() {\n        if (this.#allEditors.size === 0) {\n            return true;\n        }\n        if (this.#allEditors.size === 1) {\n            for (const editor of this.#allEditors.values()){\n                return editor.isEmpty();\n            }\n        }\n        return false;\n    }\n    delete() {\n        this.commitOrRemove();\n        if (!this.hasSelection) {\n            return;\n        }\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const cmd = ()=>{\n            for (const editor of editors){\n                editor.remove();\n            }\n        };\n        const undo = ()=>{\n            for (const editor of editors){\n                this.#addEditorToLayer(editor);\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    commitOrRemove() {\n        this.#activeEditor?.commitOrRemove();\n    }\n    hasSomethingToControl() {\n        return this.#activeEditor || this.hasSelection;\n    }\n    #selectEditors(editors) {\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        for (const editor of editors){\n            if (editor.isEmpty()) {\n                continue;\n            }\n            this.#selectedEditors.add(editor);\n            editor.select();\n        }\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: this.hasSelection\n        });\n    }\n    selectAll() {\n        for (const editor of this.#selectedEditors){\n            editor.commit();\n        }\n        this.#selectEditors(this.#allEditors.values());\n    }\n    unselectAll() {\n        if (this.#activeEditor) {\n            this.#activeEditor.commitOrRemove();\n            if (this.#mode !== AnnotationEditorType.NONE) {\n                return;\n            }\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        for (const editor of this.#selectedEditors){\n            editor.unselect();\n        }\n        this.#selectedEditors.clear();\n        this.#dispatchUpdateStates({\n            hasSelectedEditor: false\n        });\n    }\n    translateSelectedEditors(x, y, noCommit = false) {\n        if (!noCommit) {\n            this.commitOrRemove();\n        }\n        if (!this.hasSelection) {\n            return;\n        }\n        this.#translation[0] += x;\n        this.#translation[1] += y;\n        const [totalX, totalY] = this.#translation;\n        const editors = [\n            ...this.#selectedEditors\n        ];\n        const TIME_TO_WAIT = 1000;\n        if (this.#translationTimeoutId) {\n            clearTimeout(this.#translationTimeoutId);\n        }\n        this.#translationTimeoutId = setTimeout(()=>{\n            this.#translationTimeoutId = null;\n            this.#translation[0] = this.#translation[1] = 0;\n            this.addCommands({\n                cmd: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(totalX, totalY);\n                        }\n                    }\n                },\n                undo: ()=>{\n                    for (const editor of editors){\n                        if (this.#allEditors.has(editor.id)) {\n                            editor.translateInPage(-totalX, -totalY);\n                        }\n                    }\n                },\n                mustExec: false\n            });\n        }, TIME_TO_WAIT);\n        for (const editor of editors){\n            editor.translateInPage(x, y);\n        }\n    }\n    setUpDragSession() {\n        if (!this.hasSelection) {\n            return;\n        }\n        this.disableUserSelect(true);\n        this.#draggingEditors = new Map();\n        for (const editor of this.#selectedEditors){\n            this.#draggingEditors.set(editor, {\n                savedX: editor.x,\n                savedY: editor.y,\n                savedPageIndex: editor.pageIndex,\n                newX: 0,\n                newY: 0,\n                newPageIndex: -1\n            });\n        }\n    }\n    endDragSession() {\n        if (!this.#draggingEditors) {\n            return false;\n        }\n        this.disableUserSelect(false);\n        const map = this.#draggingEditors;\n        this.#draggingEditors = null;\n        let mustBeAddedInUndoStack = false;\n        for (const [{ x, y, pageIndex }, value] of map){\n            value.newX = x;\n            value.newY = y;\n            value.newPageIndex = pageIndex;\n            mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n        }\n        if (!mustBeAddedInUndoStack) {\n            return false;\n        }\n        const move = (editor, x, y, pageIndex)=>{\n            if (this.#allEditors.has(editor.id)) {\n                const parent = this.#allLayers.get(pageIndex);\n                if (parent) {\n                    editor._setParentAndPosition(parent, x, y);\n                } else {\n                    editor.pageIndex = pageIndex;\n                    editor.x = x;\n                    editor.y = y;\n                }\n            }\n        };\n        this.addCommands({\n            cmd: ()=>{\n                for (const [editor, { newX, newY, newPageIndex }] of map){\n                    move(editor, newX, newY, newPageIndex);\n                }\n            },\n            undo: ()=>{\n                for (const [editor, { savedX, savedY, savedPageIndex }] of map){\n                    move(editor, savedX, savedY, savedPageIndex);\n                }\n            },\n            mustExec: true\n        });\n        return true;\n    }\n    dragSelectedEditors(tx, ty) {\n        if (!this.#draggingEditors) {\n            return;\n        }\n        for (const editor of this.#draggingEditors.keys()){\n            editor.drag(tx, ty);\n        }\n    }\n    rebuild(editor) {\n        if (editor.parent === null) {\n            const parent = this.getLayer(editor.pageIndex);\n            if (parent) {\n                parent.changeParent(editor);\n                parent.addOrRebuild(editor);\n            } else {\n                this.addEditor(editor);\n                this.addToAnnotationStorage(editor);\n                editor.rebuild();\n            }\n        } else {\n            editor.parent.addOrRebuild(editor);\n        }\n    }\n    get isEditorHandlingKeyboard() {\n        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n    }\n    isActive(editor) {\n        return this.#activeEditor === editor;\n    }\n    getActive() {\n        return this.#activeEditor;\n    }\n    getMode() {\n        return this.#mode;\n    }\n    get imageManager() {\n        return shadow(this, \"imageManager\", new ImageManager());\n    }\n    getSelectionBoxes(textLayer) {\n        if (!textLayer) {\n            return null;\n        }\n        const selection = document.getSelection();\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n                return null;\n            }\n        }\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        let rotator;\n        switch(textLayer.getAttribute(\"data-main-rotation\")){\n            case \"90\":\n                rotator = (x, y, w, h)=>({\n                        x: (y - layerY) / parentHeight,\n                        y: 1 - (x + w - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            case \"180\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (x + w - layerX) / parentWidth,\n                        y: 1 - (y + h - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n            case \"270\":\n                rotator = (x, y, w, h)=>({\n                        x: 1 - (y + h - layerY) / parentHeight,\n                        y: (x - layerX) / parentWidth,\n                        width: h / parentHeight,\n                        height: w / parentWidth\n                    });\n                break;\n            default:\n                rotator = (x, y, w, h)=>({\n                        x: (x - layerX) / parentWidth,\n                        y: (y - layerY) / parentHeight,\n                        width: w / parentWidth,\n                        height: h / parentHeight\n                    });\n                break;\n        }\n        const boxes = [];\n        for(let i = 0, ii = selection.rangeCount; i < ii; i++){\n            const range = selection.getRangeAt(i);\n            if (range.collapsed) {\n                continue;\n            }\n            for (const { x, y, width, height } of range.getClientRects()){\n                if (width === 0 || height === 0) {\n                    continue;\n                }\n                boxes.push(rotator(x, y, width, height));\n            }\n        }\n        return boxes.length === 0 ? null : boxes;\n    }\n    addChangedExistingAnnotation({ annotationElementId, id }) {\n        (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n    }\n    removeChangedExistingAnnotation({ annotationElementId }) {\n        this.#changedExistingAnnotations?.delete(annotationElementId);\n    }\n    renderAnnotationElement(annotation) {\n        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n        if (!editorId) {\n            return;\n        }\n        const editor = this.#annotationStorage.getRawValue(editorId);\n        if (!editor) {\n            return;\n        }\n        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n            return;\n        }\n        editor.renderAnnotationElement(annotation);\n    }\n}\n; // ./src/display/editor/alt_text.js\nclass AltText {\n    #altText;\n    #altTextDecorative;\n    #altTextButton;\n    #altTextButtonLabel;\n    #altTextTooltip;\n    #altTextTooltipTimeout;\n    #altTextWasFromKeyBoard;\n    #badge;\n    #editor;\n    #guessedText;\n    #textWithDisclaimer;\n    #useNewAltTextFlow;\n    static #l10nNewButton = null;\n    static{\n        this._l10n = null;\n    }\n    constructor(editor){\n        this.#altText = null;\n        this.#altTextDecorative = false;\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#altTextTooltipTimeout = null;\n        this.#altTextWasFromKeyBoard = false;\n        this.#badge = null;\n        this.#editor = null;\n        this.#guessedText = null;\n        this.#textWithDisclaimer = null;\n        this.#useNewAltTextFlow = false;\n        this.#editor = editor;\n        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n        AltText.#l10nNewButton ||= Object.freeze({\n            added: \"pdfjs-editor-new-alt-text-added-button\",\n            \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n            missing: \"pdfjs-editor-new-alt-text-missing-button\",\n            \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n            review: \"pdfjs-editor-new-alt-text-to-review-button\",\n            \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n        });\n    }\n    static initialize(l10n) {\n        AltText._l10n ??= l10n;\n    }\n    async render() {\n        const altText = this.#altTextButton = document.createElement(\"button\");\n        altText.className = \"altText\";\n        altText.tabIndex = \"0\";\n        const label = this.#altTextButtonLabel = document.createElement(\"span\");\n        altText.append(label);\n        if (this.#useNewAltTextFlow) {\n            altText.classList.add(\"new\");\n            altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n            label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n        } else {\n            altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n            label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n        }\n        const signal = this.#editor._uiManager._signal;\n        altText.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        altText.addEventListener(\"pointerdown\", (event)=>event.stopPropagation(), {\n            signal\n        });\n        const onClick = (event)=>{\n            event.preventDefault();\n            this.#editor._uiManager.editAltText(this.#editor);\n            if (this.#useNewAltTextFlow) {\n                this.#editor._reportTelemetry({\n                    action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n                    data: {\n                        label: this.#label\n                    }\n                });\n            }\n        };\n        altText.addEventListener(\"click\", onClick, {\n            capture: true,\n            signal\n        });\n        altText.addEventListener(\"keydown\", (event)=>{\n            if (event.target === altText && event.key === \"Enter\") {\n                this.#altTextWasFromKeyBoard = true;\n                onClick(event);\n            }\n        }, {\n            signal\n        });\n        await this.#setState();\n        return altText;\n    }\n    get #label() {\n        return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n    }\n    finish() {\n        if (!this.#altTextButton) {\n            return;\n        }\n        this.#altTextButton.focus({\n            focusVisible: this.#altTextWasFromKeyBoard\n        });\n        this.#altTextWasFromKeyBoard = false;\n    }\n    isEmpty() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText === null;\n        }\n        return !this.#altText && !this.#altTextDecorative;\n    }\n    hasData() {\n        if (this.#useNewAltTextFlow) {\n            return this.#altText !== null || !!this.#guessedText;\n        }\n        return this.isEmpty();\n    }\n    get guessedText() {\n        return this.#guessedText;\n    }\n    async setGuessedText(guessedText) {\n        if (this.#altText !== null) {\n            return;\n        }\n        this.#guessedText = guessedText;\n        this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n            generatedAltText: guessedText\n        });\n        this.#setState();\n    }\n    toggleAltTextBadge(visibility = false) {\n        if (!this.#useNewAltTextFlow || this.#altText) {\n            this.#badge?.remove();\n            this.#badge = null;\n            return;\n        }\n        if (!this.#badge) {\n            const badge = this.#badge = document.createElement(\"div\");\n            badge.className = \"noAltTextBadge\";\n            this.#editor.div.append(badge);\n        }\n        this.#badge.classList.toggle(\"hidden\", !visibility);\n    }\n    serialize(isForCopying) {\n        let altText = this.#altText;\n        if (!isForCopying && this.#guessedText === altText) {\n            altText = this.#textWithDisclaimer;\n        }\n        return {\n            altText,\n            decorative: this.#altTextDecorative,\n            guessedText: this.#guessedText,\n            textWithDisclaimer: this.#textWithDisclaimer\n        };\n    }\n    get data() {\n        return {\n            altText: this.#altText,\n            decorative: this.#altTextDecorative\n        };\n    }\n    set data({ altText, decorative, guessedText, textWithDisclaimer, cancel = false }) {\n        if (guessedText) {\n            this.#guessedText = guessedText;\n            this.#textWithDisclaimer = textWithDisclaimer;\n        }\n        if (this.#altText === altText && this.#altTextDecorative === decorative) {\n            return;\n        }\n        if (!cancel) {\n            this.#altText = altText;\n            this.#altTextDecorative = decorative;\n        }\n        this.#setState();\n    }\n    toggle(enabled = false) {\n        if (!this.#altTextButton) {\n            return;\n        }\n        if (!enabled && this.#altTextTooltipTimeout) {\n            clearTimeout(this.#altTextTooltipTimeout);\n            this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextButton.disabled = !enabled;\n    }\n    shown() {\n        this.#editor._reportTelemetry({\n            action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n            data: {\n                label: this.#label\n            }\n        });\n    }\n    destroy() {\n        this.#altTextButton?.remove();\n        this.#altTextButton = null;\n        this.#altTextButtonLabel = null;\n        this.#altTextTooltip = null;\n        this.#badge?.remove();\n        this.#badge = null;\n    }\n    async #setState() {\n        const button = this.#altTextButton;\n        if (!button) {\n            return;\n        }\n        if (this.#useNewAltTextFlow) {\n            button.classList.toggle(\"done\", !!this.#altText);\n            button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n            this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n            if (!this.#altText) {\n                this.#altTextTooltip?.remove();\n                return;\n            }\n        } else {\n            if (!this.#altText && !this.#altTextDecorative) {\n                button.classList.remove(\"done\");\n                this.#altTextTooltip?.remove();\n                return;\n            }\n            button.classList.add(\"done\");\n            button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n        }\n        let tooltip = this.#altTextTooltip;\n        if (!tooltip) {\n            this.#altTextTooltip = tooltip = document.createElement(\"span\");\n            tooltip.className = \"tooltip\";\n            tooltip.setAttribute(\"role\", \"tooltip\");\n            tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n            const DELAY_TO_SHOW_TOOLTIP = 100;\n            const signal = this.#editor._uiManager._signal;\n            signal.addEventListener(\"abort\", ()=>{\n                clearTimeout(this.#altTextTooltipTimeout);\n                this.#altTextTooltipTimeout = null;\n            }, {\n                once: true\n            });\n            button.addEventListener(\"mouseenter\", ()=>{\n                this.#altTextTooltipTimeout = setTimeout(()=>{\n                    this.#altTextTooltipTimeout = null;\n                    this.#altTextTooltip.classList.add(\"show\");\n                    this.#editor._reportTelemetry({\n                        action: \"alt_text_tooltip\"\n                    });\n                }, DELAY_TO_SHOW_TOOLTIP);\n            }, {\n                signal\n            });\n            button.addEventListener(\"mouseleave\", ()=>{\n                if (this.#altTextTooltipTimeout) {\n                    clearTimeout(this.#altTextTooltipTimeout);\n                    this.#altTextTooltipTimeout = null;\n                }\n                this.#altTextTooltip?.classList.remove(\"show\");\n            }, {\n                signal\n            });\n        }\n        if (this.#altTextDecorative) {\n            tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n        } else {\n            tooltip.removeAttribute(\"data-l10n-id\");\n            tooltip.textContent = this.#altText;\n        }\n        if (!tooltip.parentNode) {\n            button.append(tooltip);\n        }\n        const element = this.#editor.getImageForAltText();\n        element?.setAttribute(\"aria-describedby\", tooltip.id);\n    }\n}\n; // ./src/display/editor/editor.js\nclass AnnotationEditor {\n    #accessibilityData;\n    #allResizerDivs;\n    #altText;\n    #disabled;\n    #keepAspectRatio;\n    #resizersDiv;\n    #savedDimensions;\n    #focusAC;\n    #focusedResizerName;\n    #hasBeenClicked;\n    #initialPosition;\n    #isEditing;\n    #isInEditMode;\n    #isResizerEnabledForKeyboard;\n    #moveInDOMTimeout;\n    #prevDragX;\n    #prevDragY;\n    #telemetryTimeouts;\n    static{\n        this._l10n = null;\n    }\n    static{\n        this._l10nResizer = null;\n    }\n    #isDraggable;\n    #zIndex;\n    static{\n        this._borderLineWidth = -1;\n    }\n    static{\n        this._colorManager = new ColorManager();\n    }\n    static{\n        this._zIndex = 1;\n    }\n    static{\n        this._telemetryTimeout = 1000;\n    }\n    static get _resizerKeyboardManager() {\n        const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                resize,\n                {\n                    args: [\n                        -big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        small,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                resize,\n                {\n                    args: [\n                        big,\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        -big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        small\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                resize,\n                {\n                    args: [\n                        0,\n                        big\n                    ]\n                }\n            ],\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                AnnotationEditor.prototype._stopResizingWithKeyboard\n            ]\n        ]));\n    }\n    constructor(parameters){\n        this.#accessibilityData = null;\n        this.#allResizerDivs = null;\n        this.#altText = null;\n        this.#disabled = false;\n        this.#keepAspectRatio = false;\n        this.#resizersDiv = null;\n        this.#savedDimensions = null;\n        this.#focusAC = null;\n        this.#focusedResizerName = \"\";\n        this.#hasBeenClicked = false;\n        this.#initialPosition = null;\n        this.#isEditing = false;\n        this.#isInEditMode = false;\n        this.#isResizerEnabledForKeyboard = false;\n        this.#moveInDOMTimeout = null;\n        this.#prevDragX = 0;\n        this.#prevDragY = 0;\n        this.#telemetryTimeouts = null;\n        this._editToolbar = null;\n        this._initialOptions = Object.create(null);\n        this._initialData = null;\n        this._isVisible = true;\n        this._uiManager = null;\n        this._focusEventsAllowed = true;\n        this.#isDraggable = false;\n        this.#zIndex = AnnotationEditor._zIndex++;\n        this.parent = parameters.parent;\n        this.id = parameters.id;\n        this.width = this.height = null;\n        this.pageIndex = parameters.parent.pageIndex;\n        this.name = parameters.name;\n        this.div = null;\n        this._uiManager = parameters.uiManager;\n        this.annotationElementId = null;\n        this._willKeepAspectRatio = false;\n        this._initialOptions.isCentered = parameters.isCentered;\n        this._structTreeParentId = null;\n        const { rotation, rawDims: { pageWidth, pageHeight, pageX, pageY } } = this.parent.viewport;\n        this.rotation = rotation;\n        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n        this.pageDimensions = [\n            pageWidth,\n            pageHeight\n        ];\n        this.pageTranslation = [\n            pageX,\n            pageY\n        ];\n        const [width, height] = this.parentDimensions;\n        this.x = parameters.x / width;\n        this.y = parameters.y / height;\n        this.isAttachedToDOM = false;\n        this.deleted = false;\n    }\n    get editorType() {\n        return Object.getPrototypeOf(this).constructor._type;\n    }\n    static get _defaultLineColor() {\n        return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n    }\n    static deleteAnnotationElement(editor) {\n        const fakeEditor = new FakeEditor({\n            id: editor.parent.getNextId(),\n            parent: editor.parent,\n            uiManager: editor._uiManager\n        });\n        fakeEditor.annotationElementId = editor.annotationElementId;\n        fakeEditor.deleted = true;\n        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n    }\n    static initialize(l10n, _uiManager) {\n        AnnotationEditor._l10n ??= l10n;\n        AnnotationEditor._l10nResizer ||= Object.freeze({\n            topLeft: \"pdfjs-editor-resizer-top-left\",\n            topMiddle: \"pdfjs-editor-resizer-top-middle\",\n            topRight: \"pdfjs-editor-resizer-top-right\",\n            middleRight: \"pdfjs-editor-resizer-middle-right\",\n            bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n            bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n            bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n            middleLeft: \"pdfjs-editor-resizer-middle-left\"\n        });\n        if (AnnotationEditor._borderLineWidth !== -1) {\n            return;\n        }\n        const style = getComputedStyle(document.documentElement);\n        AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n    }\n    static updateDefaultParams(_type, _value) {}\n    static get defaultPropertiesToUpdate() {\n        return [];\n    }\n    static isHandlingMimeForPasting(mime) {\n        return false;\n    }\n    static paste(item, parent) {\n        unreachable(\"Not implemented\");\n    }\n    get propertiesToUpdate() {\n        return [];\n    }\n    get _isDraggable() {\n        return this.#isDraggable;\n    }\n    set _isDraggable(value) {\n        this.#isDraggable = value;\n        this.div?.classList.toggle(\"draggable\", value);\n    }\n    get isEnterHandled() {\n        return true;\n    }\n    center() {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        switch(this.parentRotation){\n            case 90:\n                this.x -= this.height * pageHeight / (pageWidth * 2);\n                this.y += this.width * pageWidth / (pageHeight * 2);\n                break;\n            case 180:\n                this.x += this.width / 2;\n                this.y += this.height / 2;\n                break;\n            case 270:\n                this.x += this.height * pageHeight / (pageWidth * 2);\n                this.y -= this.width * pageWidth / (pageHeight * 2);\n                break;\n            default:\n                this.x -= this.width / 2;\n                this.y -= this.height / 2;\n                break;\n        }\n        this.fixAndSetPosition();\n    }\n    addCommands(params) {\n        this._uiManager.addCommands(params);\n    }\n    get currentLayer() {\n        return this._uiManager.currentLayer;\n    }\n    setInBackground() {\n        this.div.style.zIndex = 0;\n    }\n    setInForeground() {\n        this.div.style.zIndex = this.#zIndex;\n    }\n    setParent(parent) {\n        if (parent !== null) {\n            this.pageIndex = parent.pageIndex;\n            this.pageDimensions = parent.pageDimensions;\n        } else {\n            this.#stopResizing();\n        }\n        this.parent = parent;\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.#hasBeenClicked) {\n            this.parent.setSelected(this);\n        } else {\n            this.#hasBeenClicked = false;\n        }\n    }\n    focusout(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            return;\n        }\n        const target = event.relatedTarget;\n        if (target?.closest(`#${this.id}`)) {\n            return;\n        }\n        event.preventDefault();\n        if (!this.parent?.isMultipleSelection) {\n            this.commitOrRemove();\n        }\n    }\n    commitOrRemove() {\n        if (this.isEmpty()) {\n            this.remove();\n        } else {\n            this.commit();\n        }\n    }\n    commit() {\n        this.addToAnnotationStorage();\n    }\n    addToAnnotationStorage() {\n        this._uiManager.addToAnnotationStorage(this);\n    }\n    setAt(x, y, tx, ty) {\n        const [width, height] = this.parentDimensions;\n        [tx, ty] = this.screenToPageTranslation(tx, ty);\n        this.x = (x + tx) / width;\n        this.y = (y + ty) / height;\n        this.fixAndSetPosition();\n    }\n    #translate([width, height], x, y) {\n        [x, y] = this.screenToPageTranslation(x, y);\n        this.x += x / width;\n        this.y += y / height;\n        this.fixAndSetPosition();\n    }\n    translate(x, y) {\n        this.#translate(this.parentDimensions, x, y);\n    }\n    translateInPage(x, y) {\n        this.#initialPosition ||= [\n            this.x,\n            this.y\n        ];\n        this.#translate(this.pageDimensions, x, y);\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    drag(tx, ty) {\n        this.#initialPosition ||= [\n            this.x,\n            this.y\n        ];\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.x += tx / parentWidth;\n        this.y += ty / parentHeight;\n        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n            const { x, y } = this.div.getBoundingClientRect();\n            if (this.parent.findNewParent(this, x, y)) {\n                this.x -= Math.floor(this.x);\n                this.y -= Math.floor(this.y);\n            }\n        }\n        let { x, y } = this;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        this.div.style.left = `${(100 * x).toFixed(2)}%`;\n        this.div.style.top = `${(100 * y).toFixed(2)}%`;\n        this.div.scrollIntoView({\n            block: \"nearest\"\n        });\n    }\n    get _hasBeenMoved() {\n        return !!this.#initialPosition && (this.#initialPosition[0] !== this.x || this.#initialPosition[1] !== this.y);\n    }\n    getBaseTranslation() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const { _borderLineWidth } = AnnotationEditor;\n        const x = _borderLineWidth / parentWidth;\n        const y = _borderLineWidth / parentHeight;\n        switch(this.rotation){\n            case 90:\n                return [\n                    -x,\n                    y\n                ];\n            case 180:\n                return [\n                    x,\n                    y\n                ];\n            case 270:\n                return [\n                    x,\n                    -y\n                ];\n            default:\n                return [\n                    -x,\n                    -y\n                ];\n        }\n    }\n    get _mustFixPosition() {\n        return true;\n    }\n    fixAndSetPosition(rotation = this.rotation) {\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        let { x, y, width, height } = this;\n        width *= pageWidth;\n        height *= pageHeight;\n        x *= pageWidth;\n        y *= pageHeight;\n        if (this._mustFixPosition) {\n            switch(rotation){\n                case 0:\n                    x = Math.max(0, Math.min(pageWidth - width, x));\n                    y = Math.max(0, Math.min(pageHeight - height, y));\n                    break;\n                case 90:\n                    x = Math.max(0, Math.min(pageWidth - height, x));\n                    y = Math.min(pageHeight, Math.max(width, y));\n                    break;\n                case 180:\n                    x = Math.min(pageWidth, Math.max(width, x));\n                    y = Math.min(pageHeight, Math.max(height, y));\n                    break;\n                case 270:\n                    x = Math.min(pageWidth, Math.max(height, x));\n                    y = Math.max(0, Math.min(pageHeight - width, y));\n                    break;\n            }\n        }\n        this.x = x /= pageWidth;\n        this.y = y /= pageHeight;\n        const [bx, by] = this.getBaseTranslation();\n        x += bx;\n        y += by;\n        const { style } = this.div;\n        style.left = `${(100 * x).toFixed(2)}%`;\n        style.top = `${(100 * y).toFixed(2)}%`;\n        this.moveInDOM();\n    }\n    static #rotatePoint(x, y, angle) {\n        switch(angle){\n            case 90:\n                return [\n                    y,\n                    -x\n                ];\n            case 180:\n                return [\n                    -x,\n                    -y\n                ];\n            case 270:\n                return [\n                    -y,\n                    x\n                ];\n            default:\n                return [\n                    x,\n                    y\n                ];\n        }\n    }\n    screenToPageTranslation(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n    }\n    pageTranslationToScreen(x, y) {\n        return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n    }\n    #getRotationMatrix(rotation) {\n        switch(rotation){\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        -pageWidth / pageHeight,\n                        pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            case 180:\n                return [\n                    -1,\n                    0,\n                    0,\n                    -1\n                ];\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.pageDimensions;\n                    return [\n                        0,\n                        pageWidth / pageHeight,\n                        -pageHeight / pageWidth,\n                        0\n                    ];\n                }\n            default:\n                return [\n                    1,\n                    0,\n                    0,\n                    1\n                ];\n        }\n    }\n    get parentScale() {\n        return this._uiManager.viewParameters.realScale;\n    }\n    get parentRotation() {\n        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n    }\n    get parentDimensions() {\n        const { parentScale, pageDimensions: [pageWidth, pageHeight] } = this;\n        return [\n            pageWidth * parentScale,\n            pageHeight * parentScale\n        ];\n    }\n    setDims(width, height) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n        if (!this.#keepAspectRatio) {\n            this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n        }\n    }\n    fixDims() {\n        const { style } = this.div;\n        const { height, width } = style;\n        const widthPercent = width.endsWith(\"%\");\n        const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n        if (widthPercent && heightPercent) {\n            return;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (!widthPercent) {\n            style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n        }\n        if (!this.#keepAspectRatio && !heightPercent) {\n            style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n        }\n    }\n    getInitialTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    #createResizers() {\n        if (this.#resizersDiv) {\n            return;\n        }\n        this.#resizersDiv = document.createElement(\"div\");\n        this.#resizersDiv.classList.add(\"resizers\");\n        const classes = this._willKeepAspectRatio ? [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomRight\",\n            \"bottomLeft\"\n        ] : [\n            \"topLeft\",\n            \"topMiddle\",\n            \"topRight\",\n            \"middleRight\",\n            \"bottomRight\",\n            \"bottomMiddle\",\n            \"bottomLeft\",\n            \"middleLeft\"\n        ];\n        const signal = this._uiManager._signal;\n        for (const name of classes){\n            const div = document.createElement(\"div\");\n            this.#resizersDiv.append(div);\n            div.classList.add(\"resizer\", name);\n            div.setAttribute(\"data-resizer-name\", name);\n            div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n                signal\n            });\n            div.addEventListener(\"contextmenu\", noContextMenu, {\n                signal\n            });\n            div.tabIndex = -1;\n        }\n        this.div.prepend(this.#resizersDiv);\n    }\n    #resizerPointerdown(name, event) {\n        event.preventDefault();\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        this.#altText?.toggle(false);\n        const savedDraggable = this._isDraggable;\n        this._isDraggable = false;\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        this.parent.togglePointerEvents(false);\n        window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n            passive: true,\n            capture: true,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const savedParentCursor = this.parent.div.style.cursor;\n        const savedCursor = this.div.style.cursor;\n        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            this.parent.togglePointerEvents(true);\n            this.#altText?.toggle(true);\n            this._isDraggable = savedDraggable;\n            this.parent.div.style.cursor = savedParentCursor;\n            this.div.style.cursor = savedCursor;\n            this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    #addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight) {\n        const newX = this.x;\n        const newY = this.y;\n        const newWidth = this.width;\n        const newHeight = this.height;\n        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n            return;\n        }\n        this.addCommands({\n            cmd: ()=>{\n                this.width = newWidth;\n                this.height = newHeight;\n                this.x = newX;\n                this.y = newY;\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n                this.fixAndSetPosition();\n            },\n            undo: ()=>{\n                this.width = savedWidth;\n                this.height = savedHeight;\n                this.x = savedX;\n                this.y = savedY;\n                const [parentWidth, parentHeight] = this.parentDimensions;\n                this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);\n                this.fixAndSetPosition();\n            },\n            mustExec: true\n        });\n    }\n    #resizerPointermove(name, event) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const savedX = this.x;\n        const savedY = this.y;\n        const savedWidth = this.width;\n        const savedHeight = this.height;\n        const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n        const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n        const round = (x)=>Math.round(x * 10000) / 10000;\n        const rotationMatrix = this.#getRotationMatrix(this.rotation);\n        const transf = (x, y)=>[\n                rotationMatrix[0] * x + rotationMatrix[2] * y,\n                rotationMatrix[1] * x + rotationMatrix[3] * y\n            ];\n        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n        const invTransf = (x, y)=>[\n                invRotationMatrix[0] * x + invRotationMatrix[2] * y,\n                invRotationMatrix[1] * x + invRotationMatrix[3] * y\n            ];\n        let getPoint;\n        let getOpposite;\n        let isDiagonal = false;\n        let isHorizontal = false;\n        switch(name){\n            case \"topLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h\n                    ];\n                break;\n            case \"topMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                break;\n            case \"topRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        0\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h\n                    ];\n                break;\n            case \"middleRight\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                break;\n            case \"bottomRight\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        w,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        0,\n                        0\n                    ];\n                break;\n            case \"bottomMiddle\":\n                getPoint = (w, h)=>[\n                        w / 2,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w / 2,\n                        0\n                    ];\n                break;\n            case \"bottomLeft\":\n                isDiagonal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        0\n                    ];\n                break;\n            case \"middleLeft\":\n                isHorizontal = true;\n                getPoint = (w, h)=>[\n                        0,\n                        h / 2\n                    ];\n                getOpposite = (w, h)=>[\n                        w,\n                        h / 2\n                    ];\n                break;\n        }\n        const point = getPoint(savedWidth, savedHeight);\n        const oppositePoint = getOpposite(savedWidth, savedHeight);\n        let transfOppositePoint = transf(...oppositePoint);\n        const oppositeX = round(savedX + transfOppositePoint[0]);\n        const oppositeY = round(savedY + transfOppositePoint[1]);\n        let ratioX = 1;\n        let ratioY = 1;\n        let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);\n        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n        if (isDiagonal) {\n            const oldDiag = Math.hypot(savedWidth, savedHeight);\n            ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n        } else if (isHorizontal) {\n            ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n        } else {\n            ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n        }\n        const newWidth = round(savedWidth * ratioX);\n        const newHeight = round(savedHeight * ratioY);\n        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n        const newX = oppositeX - transfOppositePoint[0];\n        const newY = oppositeY - transfOppositePoint[1];\n        this.width = newWidth;\n        this.height = newHeight;\n        this.x = newX;\n        this.y = newY;\n        this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n        this.fixAndSetPosition();\n    }\n    altTextFinish() {\n        this.#altText?.finish();\n    }\n    async addEditToolbar() {\n        if (this._editToolbar || this.#isInEditMode) {\n            return this._editToolbar;\n        }\n        this._editToolbar = new EditorToolbar(this);\n        this.div.append(this._editToolbar.render());\n        if (this.#altText) {\n            await this._editToolbar.addAltText(this.#altText);\n        }\n        return this._editToolbar;\n    }\n    removeEditToolbar() {\n        if (!this._editToolbar) {\n            return;\n        }\n        this._editToolbar.remove();\n        this._editToolbar = null;\n        this.#altText?.destroy();\n    }\n    addContainer(container) {\n        const editToolbarDiv = this._editToolbar?.div;\n        if (editToolbarDiv) {\n            editToolbarDiv.before(container);\n        } else {\n            this.div.append(container);\n        }\n    }\n    getClientDimensions() {\n        return this.div.getBoundingClientRect();\n    }\n    async addAltTextButton() {\n        if (this.#altText) {\n            return;\n        }\n        AltText.initialize(AnnotationEditor._l10n);\n        this.#altText = new AltText(this);\n        if (this.#accessibilityData) {\n            this.#altText.data = this.#accessibilityData;\n            this.#accessibilityData = null;\n        }\n        await this.addEditToolbar();\n    }\n    get altTextData() {\n        return this.#altText?.data;\n    }\n    set altTextData(data) {\n        if (!this.#altText) {\n            return;\n        }\n        this.#altText.data = data;\n    }\n    get guessedAltText() {\n        return this.#altText?.guessedText;\n    }\n    async setGuessedAltText(text) {\n        await this.#altText?.setGuessedText(text);\n    }\n    serializeAltText(isForCopying) {\n        return this.#altText?.serialize(isForCopying);\n    }\n    hasAltText() {\n        return !!this.#altText && !this.#altText.isEmpty();\n    }\n    hasAltTextData() {\n        return this.#altText?.hasData() ?? false;\n    }\n    render() {\n        this.div = document.createElement(\"div\");\n        this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n        this.div.className = this.name;\n        this.div.setAttribute(\"id\", this.id);\n        this.div.tabIndex = this.#disabled ? -1 : 0;\n        if (!this._isVisible) {\n            this.div.classList.add(\"hidden\");\n        }\n        this.setInForeground();\n        this.#addFocusListeners();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        if (this.parentRotation % 180 !== 0) {\n            this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n            this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n        }\n        const [tx, ty] = this.getInitialTranslation();\n        this.translate(tx, ty);\n        bindEvents(this, this.div, [\n            \"pointerdown\"\n        ]);\n        return this.div;\n    }\n    pointerdown(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            event.preventDefault();\n            return;\n        }\n        this.#hasBeenClicked = true;\n        if (this._isDraggable) {\n            this.#setUpDragSession(event);\n            return;\n        }\n        this.#selectOnPointerEvent(event);\n    }\n    get isSelected() {\n        return this._uiManager.isSelected(this);\n    }\n    #selectOnPointerEvent(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n            this.parent.toggleSelected(this);\n        } else {\n            this.parent.setSelected(this);\n        }\n    }\n    #setUpDragSession(event) {\n        const { isSelected } = this;\n        this._uiManager.setUpDragSession();\n        const ac = new AbortController();\n        const signal = this._uiManager.combinedSignal(ac);\n        if (isSelected) {\n            this.div.classList.add(\"moving\");\n            this.#prevDragX = event.clientX;\n            this.#prevDragY = event.clientY;\n            const pointerMoveCallback = (e)=>{\n                const { clientX: x, clientY: y } = e;\n                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n                this.#prevDragX = x;\n                this.#prevDragY = y;\n                this._uiManager.dragSelectedEditors(tx, ty);\n            };\n            window.addEventListener(\"pointermove\", pointerMoveCallback, {\n                passive: true,\n                capture: true,\n                signal\n            });\n        }\n        const pointerUpCallback = ()=>{\n            ac.abort();\n            if (isSelected) {\n                this.div.classList.remove(\"moving\");\n            }\n            this.#hasBeenClicked = false;\n            if (!this._uiManager.endDragSession()) {\n                this.#selectOnPointerEvent(event);\n            }\n        };\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n    }\n    moveInDOM() {\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n        }\n        this.#moveInDOMTimeout = setTimeout(()=>{\n            this.#moveInDOMTimeout = null;\n            this.parent?.moveEditorInDOM(this);\n        }, 0);\n    }\n    _setParentAndPosition(parent, x, y) {\n        parent.changeParent(this);\n        this.x = x;\n        this.y = y;\n        this.fixAndSetPosition();\n    }\n    getRect(tx, ty, rotation = this.rotation) {\n        const scale = this.parentScale;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const shiftX = tx / scale;\n        const shiftY = ty / scale;\n        const x = this.x * pageWidth;\n        const y = this.y * pageHeight;\n        const width = this.width * pageWidth;\n        const height = this.height * pageHeight;\n        switch(rotation){\n            case 0:\n                return [\n                    x + shiftX + pageX,\n                    pageHeight - y - shiftY - height + pageY,\n                    x + shiftX + width + pageX,\n                    pageHeight - y - shiftY + pageY\n                ];\n            case 90:\n                return [\n                    x + shiftY + pageX,\n                    pageHeight - y + shiftX + pageY,\n                    x + shiftY + height + pageX,\n                    pageHeight - y + shiftX + width + pageY\n                ];\n            case 180:\n                return [\n                    x - shiftX - width + pageX,\n                    pageHeight - y + shiftY + pageY,\n                    x - shiftX + pageX,\n                    pageHeight - y + shiftY + height + pageY\n                ];\n            case 270:\n                return [\n                    x - shiftY - height + pageX,\n                    pageHeight - y - shiftX - width + pageY,\n                    x - shiftY + pageX,\n                    pageHeight - y - shiftX + pageY\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    getRectInCurrentCoords(rect, pageHeight) {\n        const [x1, y1, x2, y2] = rect;\n        const width = x2 - x1;\n        const height = y2 - y1;\n        switch(this.rotation){\n            case 0:\n                return [\n                    x1,\n                    pageHeight - y2,\n                    width,\n                    height\n                ];\n            case 90:\n                return [\n                    x1,\n                    pageHeight - y1,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    x2,\n                    pageHeight - y1,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    x2,\n                    pageHeight - y2,\n                    height,\n                    width\n                ];\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n    }\n    onceAdded() {}\n    isEmpty() {\n        return false;\n    }\n    enableEditMode() {\n        this.#isInEditMode = true;\n    }\n    disableEditMode() {\n        this.#isInEditMode = false;\n    }\n    isInEditMode() {\n        return this.#isInEditMode;\n    }\n    shouldGetKeyboardEvents() {\n        return this.#isResizerEnabledForKeyboard;\n    }\n    needsToBeRebuilt() {\n        return this.div && !this.isAttachedToDOM;\n    }\n    #addFocusListeners() {\n        if (this.#focusAC || !this.div) {\n            return;\n        }\n        this.#focusAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#focusAC);\n        this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n            signal\n        });\n    }\n    rebuild() {\n        this.#addFocusListeners();\n    }\n    rotate(_angle) {}\n    serializeDeleted() {\n        return {\n            id: this.annotationElementId,\n            deleted: true,\n            pageIndex: this.pageIndex,\n            popupRef: this._initialData?.popupRef || \"\"\n        };\n    }\n    serialize(isForCopying = false, context = null) {\n        unreachable(\"An editor must be serializable\");\n    }\n    static async deserialize(data, parent, uiManager) {\n        const editor = new this.prototype.constructor({\n            parent,\n            id: parent.getNextId(),\n            uiManager\n        });\n        editor.rotation = data.rotation;\n        editor.#accessibilityData = data.accessibilityData;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n        editor.x = x / pageWidth;\n        editor.y = y / pageHeight;\n        editor.width = width / pageWidth;\n        editor.height = height / pageHeight;\n        return editor;\n    }\n    get hasBeenModified() {\n        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n    }\n    remove() {\n        this.#focusAC?.abort();\n        this.#focusAC = null;\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        if (this.parent) {\n            this.parent.remove(this);\n        } else {\n            this._uiManager.removeEditor(this);\n        }\n        if (this.#moveInDOMTimeout) {\n            clearTimeout(this.#moveInDOMTimeout);\n            this.#moveInDOMTimeout = null;\n        }\n        this.#stopResizing();\n        this.removeEditToolbar();\n        if (this.#telemetryTimeouts) {\n            for (const timeout of this.#telemetryTimeouts.values()){\n                clearTimeout(timeout);\n            }\n            this.#telemetryTimeouts = null;\n        }\n        this.parent = null;\n    }\n    get isResizable() {\n        return false;\n    }\n    makeResizable() {\n        if (this.isResizable) {\n            this.#createResizers();\n            this.#resizersDiv.classList.remove(\"hidden\");\n            bindEvents(this, this.div, [\n                \"keydown\"\n            ]);\n        }\n    }\n    get toolbarPosition() {\n        return null;\n    }\n    keydown(event) {\n        if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n            return;\n        }\n        this._uiManager.setSelected(this);\n        this.#savedDimensions = {\n            savedX: this.x,\n            savedY: this.y,\n            savedWidth: this.width,\n            savedHeight: this.height\n        };\n        const children = this.#resizersDiv.children;\n        if (!this.#allResizerDivs) {\n            this.#allResizerDivs = Array.from(children);\n            const boundResizerKeydown = this.#resizerKeydown.bind(this);\n            const boundResizerBlur = this.#resizerBlur.bind(this);\n            const signal = this._uiManager._signal;\n            for (const div of this.#allResizerDivs){\n                const name = div.getAttribute(\"data-resizer-name\");\n                div.setAttribute(\"role\", \"spinbutton\");\n                div.addEventListener(\"keydown\", boundResizerKeydown, {\n                    signal\n                });\n                div.addEventListener(\"blur\", boundResizerBlur, {\n                    signal\n                });\n                div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n                    signal\n                });\n                div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        const first = this.#allResizerDivs[0];\n        let firstPosition = 0;\n        for (const div of children){\n            if (div === first) {\n                break;\n            }\n            firstPosition++;\n        }\n        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n        if (nextFirstPosition !== firstPosition) {\n            if (nextFirstPosition < firstPosition) {\n                for(let i = 0; i < firstPosition - nextFirstPosition; i++){\n                    this.#resizersDiv.append(this.#resizersDiv.firstChild);\n                }\n            } else if (nextFirstPosition > firstPosition) {\n                for(let i = 0; i < nextFirstPosition - firstPosition; i++){\n                    this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);\n                }\n            }\n            let i = 0;\n            for (const child of children){\n                const div = this.#allResizerDivs[i++];\n                const name = div.getAttribute(\"data-resizer-name\");\n                child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n            }\n        }\n        this.#setResizerTabIndex(0);\n        this.#isResizerEnabledForKeyboard = true;\n        this.#resizersDiv.firstChild.focus({\n            focusVisible: true\n        });\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    #resizerKeydown(event) {\n        AnnotationEditor._resizerKeyboardManager.exec(this, event);\n    }\n    #resizerBlur(event) {\n        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n            this.#stopResizing();\n        }\n    }\n    #resizerFocus(name) {\n        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n    }\n    #setResizerTabIndex(value) {\n        if (!this.#allResizerDivs) {\n            return;\n        }\n        for (const div of this.#allResizerDivs){\n            div.tabIndex = value;\n        }\n    }\n    _resizeWithKeyboard(x, y) {\n        if (!this.#isResizerEnabledForKeyboard) {\n            return;\n        }\n        this.#resizerPointermove(this.#focusedResizerName, {\n            movementX: x,\n            movementY: y\n        });\n    }\n    #stopResizing() {\n        this.#isResizerEnabledForKeyboard = false;\n        this.#setResizerTabIndex(-1);\n        if (this.#savedDimensions) {\n            const { savedX, savedY, savedWidth, savedHeight } = this.#savedDimensions;\n            this.#addResizeToUndoStack(savedX, savedY, savedWidth, savedHeight);\n            this.#savedDimensions = null;\n        }\n    }\n    _stopResizingWithKeyboard() {\n        this.#stopResizing();\n        this.div.focus();\n    }\n    select() {\n        this.makeResizable();\n        this.div?.classList.add(\"selectedEditor\");\n        if (!this._editToolbar) {\n            this.addEditToolbar().then(()=>{\n                if (this.div?.classList.contains(\"selectedEditor\")) {\n                    this._editToolbar?.show();\n                }\n            });\n            return;\n        }\n        this._editToolbar?.show();\n        this.#altText?.toggleAltTextBadge(false);\n    }\n    unselect() {\n        this.#resizersDiv?.classList.add(\"hidden\");\n        this.div?.classList.remove(\"selectedEditor\");\n        if (this.div?.contains(document.activeElement)) {\n            this._uiManager.currentLayer.div.focus({\n                preventScroll: true\n            });\n        }\n        this._editToolbar?.hide();\n        this.#altText?.toggleAltTextBadge(true);\n    }\n    updateParams(type, value) {}\n    disableEditing() {}\n    enableEditing() {}\n    enterInEditMode() {}\n    getImageForAltText() {\n        return null;\n    }\n    get contentDiv() {\n        return this.div;\n    }\n    get isEditing() {\n        return this.#isEditing;\n    }\n    set isEditing(value) {\n        this.#isEditing = value;\n        if (!this.parent) {\n            return;\n        }\n        if (value) {\n            this.parent.setSelected(this);\n            this.parent.setActiveEditor(this);\n        } else {\n            this.parent.setActiveEditor(null);\n        }\n    }\n    setAspectRatio(width, height) {\n        this.#keepAspectRatio = true;\n        const aspectRatio = width / height;\n        const { style } = this.div;\n        style.aspectRatio = aspectRatio;\n        style.height = \"auto\";\n    }\n    static get MIN_SIZE() {\n        return 16;\n    }\n    static canCreateNewEmptyEditor() {\n        return true;\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\"\n        };\n    }\n    get telemetryFinalData() {\n        return null;\n    }\n    _reportTelemetry(data, mustWait = false) {\n        if (mustWait) {\n            this.#telemetryTimeouts ||= new Map();\n            const { action } = data;\n            let timeout = this.#telemetryTimeouts.get(action);\n            if (timeout) {\n                clearTimeout(timeout);\n            }\n            timeout = setTimeout(()=>{\n                this._reportTelemetry(data);\n                this.#telemetryTimeouts.delete(action);\n                if (this.#telemetryTimeouts.size === 0) {\n                    this.#telemetryTimeouts = null;\n                }\n            }, AnnotationEditor._telemetryTimeout);\n            this.#telemetryTimeouts.set(action, timeout);\n            return;\n        }\n        data.type ||= this.editorType;\n        this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n                type: \"editing\",\n                data\n            }\n        });\n    }\n    show(visible = this._isVisible) {\n        this.div.classList.toggle(\"hidden\", !visible);\n        this._isVisible = visible;\n    }\n    enable() {\n        if (this.div) {\n            this.div.tabIndex = 0;\n        }\n        this.#disabled = false;\n    }\n    disable() {\n        if (this.div) {\n            this.div.tabIndex = -1;\n        }\n        this.#disabled = true;\n    }\n    renderAnnotationElement(annotation) {\n        let content = annotation.container.querySelector(\".annotationContent\");\n        if (!content) {\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            annotation.container.prepend(content);\n        } else if (content.nodeName === \"CANVAS\") {\n            const canvas = content;\n            content = document.createElement(\"div\");\n            content.classList.add(\"annotationContent\", this.editorType);\n            canvas.before(content);\n        }\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        const { firstChild } = annotation.container;\n        if (firstChild?.nodeName === \"DIV\" && firstChild.classList.contains(\"annotationContent\")) {\n            firstChild.remove();\n        }\n    }\n}\nclass FakeEditor extends AnnotationEditor {\n    constructor(params){\n        super(params);\n        this.annotationElementId = params.annotationElementId;\n        this.deleted = true;\n    }\n    serialize() {\n        return this.serializeDeleted();\n    }\n}\n; // ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n    constructor(seed){\n        this.h1 = seed ? seed & 0xffffffff : SEED;\n        this.h2 = seed ? seed & 0xffffffff : SEED;\n    }\n    update(input) {\n        let data, length;\n        if (typeof input === \"string\") {\n            data = new Uint8Array(input.length * 2);\n            length = 0;\n            for(let i = 0, ii = input.length; i < ii; i++){\n                const code = input.charCodeAt(i);\n                if (code <= 0xff) {\n                    data[length++] = code;\n                } else {\n                    data[length++] = code >>> 8;\n                    data[length++] = code & 0xff;\n                }\n            }\n        } else if (ArrayBuffer.isView(input)) {\n            data = input.slice();\n            length = data.byteLength;\n        } else {\n            throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n        }\n        const blockCounts = length >> 2;\n        const tailLength = length - blockCounts * 4;\n        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n        let k1 = 0, k2 = 0;\n        let h1 = this.h1, h2 = this.h2;\n        const C1 = 0xcc9e2d51, C2 = 0x1b873593;\n        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;\n        for(let i = 0; i < blockCounts; i++){\n            if (i & 1) {\n                k1 = dataUint32[i];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                h1 ^= k1;\n                h1 = h1 << 13 | h1 >>> 19;\n                h1 = h1 * 5 + 0xe6546b64;\n            } else {\n                k2 = dataUint32[i];\n                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n                k2 = k2 << 15 | k2 >>> 17;\n                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n                h2 ^= k2;\n                h2 = h2 << 13 | h2 >>> 19;\n                h2 = h2 * 5 + 0xe6546b64;\n            }\n        }\n        k1 = 0;\n        switch(tailLength){\n            case 3:\n                k1 ^= data[blockCounts * 4 + 2] << 16;\n            case 2:\n                k1 ^= data[blockCounts * 4 + 1] << 8;\n            case 1:\n                k1 ^= data[blockCounts * 4];\n                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n                k1 = k1 << 15 | k1 >>> 17;\n                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n                if (blockCounts & 1) {\n                    h1 ^= k1;\n                } else {\n                    h2 ^= k1;\n                }\n        }\n        this.h1 = h1;\n        this.h2 = h2;\n    }\n    hexdigest() {\n        let h1 = this.h1, h2 = this.h2;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n        h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n        h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n        h1 ^= h2 >>> 1;\n        return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n    }\n}\n; // ./src/display/annotation_storage.js\nconst SerializableEmpty = Object.freeze({\n    map: null,\n    hash: \"\",\n    transfer: undefined\n});\nclass AnnotationStorage {\n    #modified;\n    #modifiedIds;\n    #storage;\n    constructor(){\n        this.#modified = false;\n        this.#modifiedIds = null;\n        this.#storage = new Map();\n        this.onSetModified = null;\n        this.onResetModified = null;\n        this.onAnnotationEditor = null;\n    }\n    getValue(key, defaultValue) {\n        const value = this.#storage.get(key);\n        if (value === undefined) {\n            return defaultValue;\n        }\n        return Object.assign(defaultValue, value);\n    }\n    getRawValue(key) {\n        return this.#storage.get(key);\n    }\n    remove(key) {\n        this.#storage.delete(key);\n        if (this.#storage.size === 0) {\n            this.resetModified();\n        }\n        if (typeof this.onAnnotationEditor === \"function\") {\n            for (const value of this.#storage.values()){\n                if (value instanceof AnnotationEditor) {\n                    return;\n                }\n            }\n            this.onAnnotationEditor(null);\n        }\n    }\n    setValue(key, value) {\n        const obj = this.#storage.get(key);\n        let modified = false;\n        if (obj !== undefined) {\n            for (const [entry, val] of Object.entries(value)){\n                if (obj[entry] !== val) {\n                    modified = true;\n                    obj[entry] = val;\n                }\n            }\n        } else {\n            modified = true;\n            this.#storage.set(key, value);\n        }\n        if (modified) {\n            this.#setModified();\n        }\n        if (value instanceof AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n            this.onAnnotationEditor(value.constructor._type);\n        }\n    }\n    has(key) {\n        return this.#storage.has(key);\n    }\n    getAll() {\n        return this.#storage.size > 0 ? objectFromMap(this.#storage) : null;\n    }\n    setAll(obj) {\n        for (const [key, val] of Object.entries(obj)){\n            this.setValue(key, val);\n        }\n    }\n    get size() {\n        return this.#storage.size;\n    }\n    #setModified() {\n        if (!this.#modified) {\n            this.#modified = true;\n            if (typeof this.onSetModified === \"function\") {\n                this.onSetModified();\n            }\n        }\n    }\n    resetModified() {\n        if (this.#modified) {\n            this.#modified = false;\n            if (typeof this.onResetModified === \"function\") {\n                this.onResetModified();\n            }\n        }\n    }\n    get print() {\n        return new PrintAnnotationStorage(this);\n    }\n    get serializable() {\n        if (this.#storage.size === 0) {\n            return SerializableEmpty;\n        }\n        const map = new Map(), hash = new MurmurHash3_64(), transfer = [];\n        const context = Object.create(null);\n        let hasBitmap = false;\n        for (const [key, val] of this.#storage){\n            const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n            if (serialized) {\n                map.set(key, serialized);\n                hash.update(`${key}:${JSON.stringify(serialized)}`);\n                hasBitmap ||= !!serialized.bitmap;\n            }\n        }\n        if (hasBitmap) {\n            for (const value of map.values()){\n                if (value.bitmap) {\n                    transfer.push(value.bitmap);\n                }\n            }\n        }\n        return map.size > 0 ? {\n            map,\n            hash: hash.hexdigest(),\n            transfer\n        } : SerializableEmpty;\n    }\n    get editorStats() {\n        let stats = null;\n        const typeToEditor = new Map();\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor)) {\n                continue;\n            }\n            const editorStats = value.telemetryFinalData;\n            if (!editorStats) {\n                continue;\n            }\n            const { type } = editorStats;\n            if (!typeToEditor.has(type)) {\n                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n            }\n            stats ||= Object.create(null);\n            const map = stats[type] ||= new Map();\n            for (const [key, val] of Object.entries(editorStats)){\n                if (key === \"type\") {\n                    continue;\n                }\n                let counters = map.get(key);\n                if (!counters) {\n                    counters = new Map();\n                    map.set(key, counters);\n                }\n                const count = counters.get(val) ?? 0;\n                counters.set(val, count + 1);\n            }\n        }\n        for (const [type, editor] of typeToEditor){\n            stats[type] = editor.computeTelemetryFinalData(stats[type]);\n        }\n        return stats;\n    }\n    resetModifiedIds() {\n        this.#modifiedIds = null;\n    }\n    get modifiedIds() {\n        if (this.#modifiedIds) {\n            return this.#modifiedIds;\n        }\n        const ids = [];\n        for (const value of this.#storage.values()){\n            if (!(value instanceof AnnotationEditor) || !value.annotationElementId || !value.serialize()) {\n                continue;\n            }\n            ids.push(value.annotationElementId);\n        }\n        return this.#modifiedIds = {\n            ids: new Set(ids),\n            hash: ids.join(\",\")\n        };\n    }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n    #serializable;\n    constructor(parent){\n        super();\n        const { map, hash, transfer } = parent.serializable;\n        const clone = structuredClone(map, transfer ? {\n            transfer\n        } : null);\n        this.#serializable = {\n            map: clone,\n            hash,\n            transfer\n        };\n    }\n    get print() {\n        unreachable(\"Should not call PrintAnnotationStorage.print\");\n    }\n    get serializable() {\n        return this.#serializable;\n    }\n    get modifiedIds() {\n        return shadow(this, \"modifiedIds\", {\n            ids: new Set(),\n            hash: \"\"\n        });\n    }\n}\n; // ./src/display/font_loader.js\nclass FontLoader {\n    #systemFonts;\n    constructor({ ownerDocument = globalThis.document, styleElement = null }){\n        this.#systemFonts = new Set();\n        this._document = ownerDocument;\n        this.nativeFontFaces = new Set();\n        this.styleElement = null;\n        this.loadingRequests = [];\n        this.loadTestFontId = 0;\n    }\n    addNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.add(nativeFontFace);\n        this._document.fonts.add(nativeFontFace);\n    }\n    removeNativeFontFace(nativeFontFace) {\n        this.nativeFontFaces.delete(nativeFontFace);\n        this._document.fonts.delete(nativeFontFace);\n    }\n    insertRule(rule) {\n        if (!this.styleElement) {\n            this.styleElement = this._document.createElement(\"style\");\n            this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n        }\n        const styleSheet = this.styleElement.sheet;\n        styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n    clear() {\n        for (const nativeFontFace of this.nativeFontFaces){\n            this._document.fonts.delete(nativeFontFace);\n        }\n        this.nativeFontFaces.clear();\n        this.#systemFonts.clear();\n        if (this.styleElement) {\n            this.styleElement.remove();\n            this.styleElement = null;\n        }\n    }\n    async loadSystemFont({ systemFontInfo: info, _inspectFont }) {\n        if (!info || this.#systemFonts.has(info.loadedName)) {\n            return;\n        }\n        assert(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n        if (this.isFontLoadingAPISupported) {\n            const { loadedName, src, style } = info;\n            const fontFace = new FontFace(loadedName, src, style);\n            this.addNativeFontFace(fontFace);\n            try {\n                await fontFace.load();\n                this.#systemFonts.add(loadedName);\n                _inspectFont?.(info);\n            } catch  {\n                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n                this.removeNativeFontFace(fontFace);\n            }\n            return;\n        }\n        unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n    }\n    async bind(font) {\n        if (font.attached || font.missingFile && !font.systemFontInfo) {\n            return;\n        }\n        font.attached = true;\n        if (font.systemFontInfo) {\n            await this.loadSystemFont(font);\n            return;\n        }\n        if (this.isFontLoadingAPISupported) {\n            const nativeFontFace = font.createNativeFontFace();\n            if (nativeFontFace) {\n                this.addNativeFontFace(nativeFontFace);\n                try {\n                    await nativeFontFace.loaded;\n                } catch (ex) {\n                    warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n                    font.disableFontFace = true;\n                    throw ex;\n                }\n            }\n            return;\n        }\n        const rule = font.createFontFaceRule();\n        if (rule) {\n            this.insertRule(rule);\n            if (this.isSyncFontLoadingSupported) {\n                return;\n            }\n            await new Promise((resolve)=>{\n                const request = this._queueLoadingCallback(resolve);\n                this._prepareFontLoadEvent(font, request);\n            });\n        }\n    }\n    get isFontLoadingAPISupported() {\n        const hasFonts = !!this._document?.fonts;\n        return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n    }\n    get isSyncFontLoadingSupported() {\n        let supported = false;\n        if (isNodeJS) {\n            supported = true;\n        } else if (typeof navigator !== \"undefined\" && typeof navigator?.userAgent === \"string\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n            supported = true;\n        }\n        return shadow(this, \"isSyncFontLoadingSupported\", supported);\n    }\n    _queueLoadingCallback(callback) {\n        function completeRequest() {\n            assert(!request.done, \"completeRequest() cannot be called twice.\");\n            request.done = true;\n            while(loadingRequests.length > 0 && loadingRequests[0].done){\n                const otherRequest = loadingRequests.shift();\n                setTimeout(otherRequest.callback, 0);\n            }\n        }\n        const { loadingRequests } = this;\n        const request = {\n            done: false,\n            complete: completeRequest,\n            callback\n        };\n        loadingRequests.push(request);\n        return request;\n    }\n    get _loadTestFont() {\n        const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        return shadow(this, \"_loadTestFont\", testFont);\n    }\n    _prepareFontLoadEvent(font, request) {\n        function int32(data, offset) {\n            return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n        function spliceString(s, offset, remove, insert) {\n            const chunk1 = s.substring(0, offset);\n            const chunk2 = s.substring(offset + remove);\n            return chunk1 + insert + chunk2;\n        }\n        let i, ii;\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = 1;\n        canvas.height = 1;\n        const ctx = canvas.getContext(\"2d\");\n        let called = 0;\n        function isFontReady(name, callback) {\n            if (++called > 30) {\n                warn(\"Load test font never loaded.\");\n                callback();\n                return;\n            }\n            ctx.font = \"30px \" + name;\n            ctx.fillText(\".\", 0, 20);\n            const imageData = ctx.getImageData(0, 0, 1, 1);\n            if (imageData.data[3] > 0) {\n                callback();\n                return;\n            }\n            setTimeout(isFontReady.bind(null, name, callback));\n        }\n        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n        let data = this._loadTestFont;\n        const COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        const CFF_CHECKSUM_OFFSET = 16;\n        const XXXX_VALUE = 0x58585858;\n        let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n        for(i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4){\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n        if (i < loadTestFontId.length) {\n            checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n        const url = `url(data:font/opentype;base64,${btoa(data)});`;\n        const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n        this.insertRule(rule);\n        const div = this._document.createElement(\"div\");\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n        for (const name of [\n            font.loadedName,\n            loadTestFontId\n        ]){\n            const span = this._document.createElement(\"span\");\n            span.textContent = \"Hi\";\n            span.style.fontFamily = name;\n            div.append(span);\n        }\n        this._document.body.append(div);\n        isFontReady(loadTestFontId, ()=>{\n            div.remove();\n            request.complete();\n        });\n    }\n}\nclass FontFaceObject {\n    constructor(translatedData, { disableFontFace = false, inspectFont = null }){\n        this.compiledGlyphs = Object.create(null);\n        for(const i in translatedData){\n            this[i] = translatedData[i];\n        }\n        this.disableFontFace = disableFontFace === true;\n        this._inspectFont = inspectFont;\n    }\n    createNativeFontFace() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        let nativeFontFace;\n        if (!this.cssFontInfo) {\n            nativeFontFace = new FontFace(this.loadedName, this.data, {});\n        } else {\n            const css = {\n                weight: this.cssFontInfo.fontWeight\n            };\n            if (this.cssFontInfo.italicAngle) {\n                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n            }\n            nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n        }\n        this._inspectFont?.(this);\n        return nativeFontFace;\n    }\n    createFontFaceRule() {\n        if (!this.data || this.disableFontFace) {\n            return null;\n        }\n        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n        let rule;\n        if (!this.cssFontInfo) {\n            rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n        } else {\n            let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n            if (this.cssFontInfo.italicAngle) {\n                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n            }\n            rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n        }\n        this._inspectFont?.(this, url);\n        return rule;\n    }\n    getPathGenerator(objs, character) {\n        if (this.compiledGlyphs[character] !== undefined) {\n            return this.compiledGlyphs[character];\n        }\n        let cmds;\n        try {\n            cmds = objs.get(this.loadedName + \"_path_\" + character);\n        } catch (ex) {\n            warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n        }\n        if (!Array.isArray(cmds) || cmds.length === 0) {\n            return this.compiledGlyphs[character] = function(c, size) {};\n        }\n        const commands = [];\n        for(let i = 0, ii = cmds.length; i < ii;){\n            switch(cmds[i++]){\n                case FontRenderOps.BEZIER_CURVE_TO:\n                    {\n                        const [a, b, c, d, e, f] = cmds.slice(i, i + 6);\n                        commands.push((ctx)=>ctx.bezierCurveTo(a, b, c, d, e, f));\n                        i += 6;\n                    }\n                    break;\n                case FontRenderOps.MOVE_TO:\n                    {\n                        const [a, b] = cmds.slice(i, i + 2);\n                        commands.push((ctx)=>ctx.moveTo(a, b));\n                        i += 2;\n                    }\n                    break;\n                case FontRenderOps.LINE_TO:\n                    {\n                        const [a, b] = cmds.slice(i, i + 2);\n                        commands.push((ctx)=>ctx.lineTo(a, b));\n                        i += 2;\n                    }\n                    break;\n                case FontRenderOps.QUADRATIC_CURVE_TO:\n                    {\n                        const [a, b, c, d] = cmds.slice(i, i + 4);\n                        commands.push((ctx)=>ctx.quadraticCurveTo(a, b, c, d));\n                        i += 4;\n                    }\n                    break;\n                case FontRenderOps.RESTORE:\n                    commands.push((ctx)=>ctx.restore());\n                    break;\n                case FontRenderOps.SAVE:\n                    commands.push((ctx)=>ctx.save());\n                    break;\n                case FontRenderOps.SCALE:\n                    assert(commands.length === 2, \"Scale command is only valid at the third position.\");\n                    break;\n                case FontRenderOps.TRANSFORM:\n                    {\n                        const [a, b, c, d, e, f] = cmds.slice(i, i + 6);\n                        commands.push((ctx)=>ctx.transform(a, b, c, d, e, f));\n                        i += 6;\n                    }\n                    break;\n                case FontRenderOps.TRANSLATE:\n                    {\n                        const [a, b] = cmds.slice(i, i + 2);\n                        commands.push((ctx)=>ctx.translate(a, b));\n                        i += 2;\n                    }\n                    break;\n            }\n        }\n        return this.compiledGlyphs[character] = function glyphDrawer(ctx, size) {\n            commands[0](ctx);\n            commands[1](ctx);\n            ctx.scale(size, -size);\n            for(let i = 2, ii = commands.length; i < ii; i++){\n                commands[i](ctx);\n            }\n        };\n    }\n}\n; // ./src/display/canvas_factory.js\nclass BaseCanvasFactory {\n    #enableHWA;\n    constructor({ enableHWA = false }){\n        this.#enableHWA = false;\n        this.#enableHWA = enableHWA;\n    }\n    create(width, height) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        const canvas = this._createCanvas(width, height);\n        return {\n            canvas,\n            context: canvas.getContext(\"2d\", {\n                willReadFrequently: !this.#enableHWA\n            })\n        };\n    }\n    reset(canvasAndContext, width, height) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid canvas size\");\n        }\n        canvasAndContext.canvas.width = width;\n        canvasAndContext.canvas.height = height;\n    }\n    destroy(canvasAndContext) {\n        if (!canvasAndContext.canvas) {\n            throw new Error(\"Canvas is not specified\");\n        }\n        canvasAndContext.canvas.width = 0;\n        canvasAndContext.canvas.height = 0;\n        canvasAndContext.canvas = null;\n        canvasAndContext.context = null;\n    }\n    _createCanvas(width, height) {\n        unreachable(\"Abstract method `_createCanvas` called.\");\n    }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n    constructor({ ownerDocument = globalThis.document, enableHWA = false }){\n        super({\n            enableHWA\n        });\n        this._document = ownerDocument;\n    }\n    _createCanvas(width, height) {\n        const canvas = this._document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n}\n; // ./src/display/cmap_reader_factory.js\nclass BaseCMapReaderFactory {\n    constructor({ baseUrl = null, isCompressed = true }){\n        this.baseUrl = baseUrl;\n        this.isCompressed = isCompressed;\n    }\n    async fetch({ name }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n        }\n        if (!name) {\n            throw new Error(\"CMap name must be specified.\");\n        }\n        const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n        return this._fetch(url).then((cMapData)=>({\n                cMapData,\n                isCompressed: this.isCompressed\n            })).catch((reason)=>{\n            throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n    }\n}\n; // ./src/display/filter_factory.js\nclass BaseFilterFactory {\n    addFilter(maps) {\n        return \"none\";\n    }\n    addHCMFilter(fgColor, bgColor) {\n        return \"none\";\n    }\n    addAlphaFilter(map) {\n        return \"none\";\n    }\n    addLuminosityFilter(map) {\n        return \"none\";\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        return \"none\";\n    }\n    destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n    #baseUrl;\n    #_cache;\n    #_defs;\n    #docId;\n    #document;\n    #_hcmCache;\n    #id;\n    constructor({ docId, ownerDocument = globalThis.document }){\n        super();\n        this.#id = 0;\n        this.#docId = docId;\n        this.#document = ownerDocument;\n    }\n    get #cache() {\n        return this.#_cache ||= new Map();\n    }\n    get #hcmCache() {\n        return this.#_hcmCache ||= new Map();\n    }\n    get #defs() {\n        if (!this.#_defs) {\n            const div = this.#document.createElement(\"div\");\n            const { style } = div;\n            style.visibility = \"hidden\";\n            style.contain = \"strict\";\n            style.width = style.height = 0;\n            style.position = \"absolute\";\n            style.top = style.left = 0;\n            style.zIndex = -1;\n            const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n            svg.setAttribute(\"width\", 0);\n            svg.setAttribute(\"height\", 0);\n            this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n            div.append(svg);\n            svg.append(this.#_defs);\n            this.#document.body.append(div);\n        }\n        return this.#_defs;\n    }\n    #createTables(maps) {\n        if (maps.length === 1) {\n            const mapR = maps[0];\n            const buffer = new Array(256);\n            for(let i = 0; i < 256; i++){\n                buffer[i] = mapR[i] / 255;\n            }\n            const table = buffer.join(\",\");\n            return [\n                table,\n                table,\n                table\n            ];\n        }\n        const [mapR, mapG, mapB] = maps;\n        const bufferR = new Array(256);\n        const bufferG = new Array(256);\n        const bufferB = new Array(256);\n        for(let i = 0; i < 256; i++){\n            bufferR[i] = mapR[i] / 255;\n            bufferG[i] = mapG[i] / 255;\n            bufferB[i] = mapB[i] / 255;\n        }\n        return [\n            bufferR.join(\",\"),\n            bufferG.join(\",\"),\n            bufferB.join(\",\")\n        ];\n    }\n    #createUrl(id) {\n        if (this.#baseUrl === undefined) {\n            this.#baseUrl = \"\";\n            const url = this.#document.URL;\n            if (url !== this.#document.baseURI) {\n                if (isDataScheme(url)) {\n                    warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n                } else {\n                    this.#baseUrl = url.split(\"#\", 1)[0];\n                }\n            }\n        }\n        return `url(${this.#baseUrl}#${id})`;\n    }\n    addFilter(maps) {\n        if (!maps) {\n            return \"none\";\n        }\n        let value = this.#cache.get(maps);\n        if (value) {\n            return value;\n        }\n        const [tableR, tableG, tableB] = this.#createTables(maps);\n        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(maps, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(maps, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n        return url;\n    }\n    addHCMFilter(fgColor, bgColor) {\n        const key = `${fgColor}-${bgColor}`;\n        const filterName = \"base\";\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const fgRGB = this.#getRGB(fgColor);\n        fgColor = Util.makeHexColor(...fgRGB);\n        const bgRGB = this.#getRGB(bgColor);\n        bgColor = Util.makeHexColor(...bgRGB);\n        this.#defs.style.color = \"\";\n        if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n            return info.url;\n        }\n        const map = new Array(256);\n        for(let i = 0; i <= 255; i++){\n            const x = i / 255;\n            map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n        }\n        const table = map.join(\",\");\n        const id = `g_${this.#docId}_hcm_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addTransferMapConversion(table, table, table, filter);\n        this.#addGrayConversion(filter);\n        const getSteps = (c, n)=>{\n            const start = fgRGB[c] / 255;\n            const end = bgRGB[c] / 255;\n            const arr = new Array(n + 1);\n            for(let i = 0; i <= n; i++){\n                arr[i] = start + i / n * (end - start);\n            }\n            return arr.join(\",\");\n        };\n        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    addAlphaFilter(map) {\n        let value = this.#cache.get(map);\n        if (value) {\n            return value;\n        }\n        const [tableA] = this.#createTables([\n            map\n        ]);\n        const key = `alpha_${tableA}`;\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addTransferMapAlphaConversion(tableA, filter);\n        return url;\n    }\n    addLuminosityFilter(map) {\n        let value = this.#cache.get(map || \"luminosity\");\n        if (value) {\n            return value;\n        }\n        let tableA, key;\n        if (map) {\n            [tableA] = this.#createTables([\n                map\n            ]);\n            key = `luminosity_${tableA}`;\n        } else {\n            key = \"luminosity\";\n        }\n        value = this.#cache.get(key);\n        if (value) {\n            this.#cache.set(map, value);\n            return value;\n        }\n        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n        const url = this.#createUrl(id);\n        this.#cache.set(map, url);\n        this.#cache.set(key, url);\n        const filter = this.#createFilter(id);\n        this.#addLuminosityConversion(filter);\n        if (map) {\n            this.#addTransferMapAlphaConversion(tableA, filter);\n        }\n        return url;\n    }\n    addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n        let info = this.#hcmCache.get(filterName);\n        if (info?.key === key) {\n            return info.url;\n        }\n        if (info) {\n            info.filter?.remove();\n            info.key = key;\n            info.url = \"none\";\n            info.filter = null;\n        } else {\n            info = {\n                key,\n                url: \"none\",\n                filter: null\n            };\n            this.#hcmCache.set(filterName, info);\n        }\n        if (!fgColor || !bgColor) {\n            return info.url;\n        }\n        const [fgRGB, bgRGB] = [\n            fgColor,\n            bgColor\n        ].map(this.#getRGB.bind(this));\n        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n        let [newFgRGB, newBgRGB] = [\n            newFgColor,\n            newBgColor\n        ].map(this.#getRGB.bind(this));\n        if (bgGray < fgGray) {\n            [fgGray, bgGray, newFgRGB, newBgRGB] = [\n                bgGray,\n                fgGray,\n                newBgRGB,\n                newFgRGB\n            ];\n        }\n        this.#defs.style.color = \"\";\n        const getSteps = (fg, bg, n)=>{\n            const arr = new Array(256);\n            const step = (bgGray - fgGray) / n;\n            const newStart = fg / 255;\n            const newStep = (bg - fg) / (255 * n);\n            let prev = 0;\n            for(let i = 0; i <= n; i++){\n                const k = Math.round(fgGray + i * step);\n                const value = newStart + i * newStep;\n                for(let j = prev; j <= k; j++){\n                    arr[j] = value;\n                }\n                prev = k + 1;\n            }\n            for(let i = prev; i < 256; i++){\n                arr[i] = arr[prev - 1];\n            }\n            return arr.join(\",\");\n        };\n        const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n        const filter = info.filter = this.#createFilter(id);\n        this.#addGrayConversion(filter);\n        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n        info.url = this.#createUrl(id);\n        return info.url;\n    }\n    destroy(keepHCM = false) {\n        if (keepHCM && this.#hcmCache.size !== 0) {\n            return;\n        }\n        if (this.#_defs) {\n            this.#_defs.parentNode.parentNode.remove();\n            this.#_defs = null;\n        }\n        if (this.#_cache) {\n            this.#_cache.clear();\n            this.#_cache = null;\n        }\n        this.#id = 0;\n    }\n    #addLuminosityConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n        filter.append(feColorMatrix);\n    }\n    #addGrayConversion(filter) {\n        const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n        filter.append(feColorMatrix);\n    }\n    #createFilter(id) {\n        const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n        filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        filter.setAttribute(\"id\", id);\n        this.#defs.append(filter);\n        return filter;\n    }\n    #appendFeFunc(feComponentTransfer, func, table) {\n        const feFunc = this.#document.createElementNS(SVG_NS, func);\n        feFunc.setAttribute(\"type\", \"discrete\");\n        feFunc.setAttribute(\"tableValues\", table);\n        feComponentTransfer.append(feFunc);\n    }\n    #addTransferMapConversion(rTable, gTable, bTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n    }\n    #addTransferMapAlphaConversion(aTable, filter) {\n        const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n        filter.append(feComponentTransfer);\n        this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n    }\n    #getRGB(color) {\n        this.#defs.style.color = color;\n        return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n    }\n}\n; // ./src/display/standard_fontdata_factory.js\nclass BaseStandardFontDataFactory {\n    constructor({ baseUrl = null }){\n        this.baseUrl = baseUrl;\n    }\n    async fetch({ filename }) {\n        if (!this.baseUrl) {\n            throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n        }\n        if (!filename) {\n            throw new Error(\"Font filename must be specified.\");\n        }\n        const url = `${this.baseUrl}${filename}`;\n        return this._fetch(url).catch((reason)=>{\n            throw new Error(`Unable to load font data at: ${url}`);\n        });\n    }\n    async _fetch(url) {\n        unreachable(\"Abstract method `_fetch` called.\");\n    }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        const data = await fetchData(url, \"arraybuffer\");\n        return new Uint8Array(data);\n    }\n}\n; // ./src/display/node_utils.js\nif (isNodeJS) {\n    var packageCapability = Promise.withResolvers();\n    var packageMap = null;\n    const loadPackages = async ()=>{\n        const fs = await import(/*webpackIgnore: true*/ \"fs\"), http = await import(/*webpackIgnore: true*/ \"http\"), https = await import(/*webpackIgnore: true*/ \"https\"), url = await import(/*webpackIgnore: true*/ \"url\");\n        let canvas, path2d;\n        return new Map(Object.entries({\n            fs,\n            http,\n            https,\n            url,\n            canvas,\n            path2d\n        }));\n    };\n    loadPackages().then((map)=>{\n        packageMap = map;\n        packageCapability.resolve();\n    }, (reason)=>{\n        warn(`loadPackages: ${reason}`);\n        packageMap = new Map();\n        packageCapability.resolve();\n    });\n}\nclass NodePackages {\n    static get promise() {\n        return packageCapability.promise;\n    }\n    static get(name) {\n        return packageMap?.get(name);\n    }\n}\nasync function node_utils_fetchData(url) {\n    const fs = NodePackages.get(\"fs\");\n    const data = await fs.promises.readFile(url);\n    return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {\n}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n    _createCanvas(width, height) {\n        const canvas = NodePackages.get(\"canvas\");\n        return canvas.createCanvas(width, height);\n    }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n    async _fetch(url) {\n        return node_utils_fetchData(url);\n    }\n}\n; // ./src/display/pattern_helper.js\nconst PathType = {\n    FILL: \"Fill\",\n    STROKE: \"Stroke\",\n    SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n    if (!bbox) {\n        return;\n    }\n    const width = bbox[2] - bbox[0];\n    const height = bbox[3] - bbox[1];\n    const region = new Path2D();\n    region.rect(bbox[0], bbox[1], width, height);\n    ctx.clip(region);\n}\nclass BaseShadingPattern {\n    getPattern() {\n        unreachable(\"Abstract method `getPattern` called.\");\n    }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._type = IR[1];\n        this._bbox = IR[2];\n        this._colorStops = IR[3];\n        this._p0 = IR[4];\n        this._p1 = IR[5];\n        this._r0 = IR[6];\n        this._r1 = IR[7];\n        this.matrix = null;\n    }\n    _createGradient(ctx) {\n        let grad;\n        if (this._type === \"axial\") {\n            grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n        } else if (this._type === \"radial\") {\n            grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n        }\n        for (const colorStop of this._colorStops){\n            grad.addColorStop(colorStop[0], colorStop[1]);\n        }\n        return grad;\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let pattern;\n        if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n            const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [\n                0,\n                0,\n                0,\n                0\n            ];\n            const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n            const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n            const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.beginPath();\n            tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n            tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n            inverse = Util.transform(inverse, [\n                1,\n                0,\n                0,\n                1,\n                ownerBBox[0],\n                ownerBBox[1]\n            ]);\n            tmpCtx.transform(...owner.baseTransform);\n            if (this.matrix) {\n                tmpCtx.transform(...this.matrix);\n            }\n            applyBoundingBox(tmpCtx, this._bbox);\n            tmpCtx.fillStyle = this._createGradient(tmpCtx);\n            tmpCtx.fill();\n            pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n            const domMatrix = new DOMMatrix(inverse);\n            pattern.setTransform(domMatrix);\n        } else {\n            applyBoundingBox(ctx, this._bbox);\n            pattern = this._createGradient(ctx);\n        }\n        return pattern;\n    }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    const coords = context.coords, colors = context.colors;\n    const bytes = data.data, rowSize = data.width * 4;\n    let tmp;\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n        tmp = p2;\n        p2 = p3;\n        p3 = tmp;\n        tmp = c2;\n        c2 = c3;\n        c3 = tmp;\n    }\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n        tmp = p1;\n        p1 = p2;\n        p2 = tmp;\n        tmp = c1;\n        c1 = c2;\n        c2 = tmp;\n    }\n    const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n    if (y1 >= y3) {\n        return;\n    }\n    const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];\n    const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];\n    const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];\n    const minY = Math.round(y1), maxY = Math.round(y3);\n    let xa, car, cag, cab;\n    let xb, cbr, cbg, cbb;\n    for(let y = minY; y <= maxY; y++){\n        if (y < y2) {\n            const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n            xa = x1 - (x1 - x2) * k;\n            car = c1r - (c1r - c2r) * k;\n            cag = c1g - (c1g - c2g) * k;\n            cab = c1b - (c1b - c2b) * k;\n        } else {\n            let k;\n            if (y > y3) {\n                k = 1;\n            } else if (y2 === y3) {\n                k = 0;\n            } else {\n                k = (y2 - y) / (y2 - y3);\n            }\n            xa = x2 - (x2 - x3) * k;\n            car = c2r - (c2r - c3r) * k;\n            cag = c2g - (c2g - c3g) * k;\n            cab = c2b - (c2b - c3b) * k;\n        }\n        let k;\n        if (y < y1) {\n            k = 0;\n        } else if (y > y3) {\n            k = 1;\n        } else {\n            k = (y1 - y) / (y1 - y3);\n        }\n        xb = x1 - (x1 - x3) * k;\n        cbr = c1r - (c1r - c3r) * k;\n        cbg = c1g - (c1g - c3g) * k;\n        cbb = c1b - (c1b - c3b) * k;\n        const x1_ = Math.round(Math.min(xa, xb));\n        const x2_ = Math.round(Math.max(xa, xb));\n        let j = rowSize * y + x1_ * 4;\n        for(let x = x1_; x <= x2_; x++){\n            k = (xa - x) / (xa - xb);\n            if (k < 0) {\n                k = 0;\n            } else if (k > 1) {\n                k = 1;\n            }\n            bytes[j++] = car - (car - cbr) * k | 0;\n            bytes[j++] = cag - (cag - cbg) * k | 0;\n            bytes[j++] = cab - (cab - cbb) * k | 0;\n            bytes[j++] = 255;\n        }\n    }\n}\nfunction drawFigure(data, figure, context) {\n    const ps = figure.coords;\n    const cs = figure.colors;\n    let i, ii;\n    switch(figure.type){\n        case \"lattice\":\n            const verticesPerRow = figure.verticesPerRow;\n            const rows = Math.floor(ps.length / verticesPerRow) - 1;\n            const cols = verticesPerRow - 1;\n            for(i = 0; i < rows; i++){\n                let q = i * verticesPerRow;\n                for(let j = 0; j < cols; j++, q++){\n                    drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n                    drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n                }\n            }\n            break;\n        case \"triangles\":\n            for(i = 0, ii = ps.length; i < ii; i += 3){\n                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n            }\n            break;\n        default:\n            throw new Error(\"illegal figure\");\n    }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n    constructor(IR){\n        super();\n        this._coords = IR[2];\n        this._colors = IR[3];\n        this._figures = IR[4];\n        this._bounds = IR[5];\n        this._bbox = IR[7];\n        this._background = IR[8];\n        this.matrix = null;\n    }\n    _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n        const EXPECTED_SCALE = 1.1;\n        const MAX_PATTERN_SIZE = 3000;\n        const BORDER_SIZE = 2;\n        const offsetX = Math.floor(this._bounds[0]);\n        const offsetY = Math.floor(this._bounds[1]);\n        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n        const scaleX = boundsWidth / width;\n        const scaleY = boundsHeight / height;\n        const context = {\n            coords: this._coords,\n            colors: this._colors,\n            offsetX: -offsetX,\n            offsetY: -offsetY,\n            scaleX: 1 / scaleX,\n            scaleY: 1 / scaleY\n        };\n        const paddedWidth = width + BORDER_SIZE * 2;\n        const paddedHeight = height + BORDER_SIZE * 2;\n        const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n        const tmpCtx = tmpCanvas.context;\n        const data = tmpCtx.createImageData(width, height);\n        if (backgroundColor) {\n            const bytes = data.data;\n            for(let i = 0, ii = bytes.length; i < ii; i += 4){\n                bytes[i] = backgroundColor[0];\n                bytes[i + 1] = backgroundColor[1];\n                bytes[i + 2] = backgroundColor[2];\n                bytes[i + 3] = 255;\n            }\n        }\n        for (const figure of this._figures){\n            drawFigure(data, figure, context);\n        }\n        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n        const canvas = tmpCanvas.canvas;\n        return {\n            canvas,\n            offsetX: offsetX - BORDER_SIZE * scaleX,\n            offsetY: offsetY - BORDER_SIZE * scaleY,\n            scaleX,\n            scaleY\n        };\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        applyBoundingBox(ctx, this._bbox);\n        let scale;\n        if (pathType === PathType.SHADING) {\n            scale = Util.singularValueDecompose2dScale(getCurrentTransform(ctx));\n        } else {\n            scale = Util.singularValueDecompose2dScale(owner.baseTransform);\n            if (this.matrix) {\n                const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n                scale = [\n                    scale[0] * matrixScale[0],\n                    scale[1] * matrixScale[1]\n                ];\n            }\n        }\n        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n        if (pathType !== PathType.SHADING) {\n            ctx.setTransform(...owner.baseTransform);\n            if (this.matrix) {\n                ctx.transform(...this.matrix);\n            }\n        }\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n    }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n    getPattern() {\n        return \"hotpink\";\n    }\n}\nfunction getShadingPattern(IR) {\n    switch(IR[0]){\n        case \"RadialAxial\":\n            return new RadialAxialShadingPattern(IR);\n        case \"Mesh\":\n            return new MeshShadingPattern(IR);\n        case \"Dummy\":\n            return new DummyShadingPattern();\n    }\n    throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n};\nclass TilingPattern {\n    static{\n        this.MAX_PATTERN_SIZE = 3000;\n    }\n    constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform){\n        this.operatorList = IR[2];\n        this.matrix = IR[3];\n        this.bbox = IR[4];\n        this.xstep = IR[5];\n        this.ystep = IR[6];\n        this.paintType = IR[7];\n        this.tilingType = IR[8];\n        this.color = color;\n        this.ctx = ctx;\n        this.canvasGraphicsFactory = canvasGraphicsFactory;\n        this.baseTransform = baseTransform;\n    }\n    createPatternCanvas(owner) {\n        const { bbox, operatorList, paintType, tilingType, color, canvasGraphicsFactory } = this;\n        let { xstep, ystep } = this;\n        xstep = Math.abs(xstep);\n        ystep = Math.abs(ystep);\n        info(\"TilingType: \" + tilingType);\n        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];\n        const width = x1 - x0;\n        const height = y1 - y0;\n        const matrixScale = Util.singularValueDecompose2dScale(this.matrix);\n        const curMatrixScale = Util.singularValueDecompose2dScale(this.baseTransform);\n        const combinedScaleX = matrixScale[0] * curMatrixScale[0];\n        const combinedScaleY = matrixScale[1] * curMatrixScale[1];\n        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;\n        const xScaledStep = Math.ceil(xstep * combinedScaleX);\n        const yScaledStep = Math.ceil(ystep * combinedScaleY);\n        const xScaledWidth = Math.ceil(width * combinedScaleX);\n        const yScaledHeight = Math.ceil(height * combinedScaleY);\n        if (xScaledStep >= xScaledWidth) {\n            canvasWidth = xstep;\n        } else {\n            redrawHorizontally = true;\n        }\n        if (yScaledStep >= yScaledHeight) {\n            canvasHeight = ystep;\n        } else {\n            redrawVertically = true;\n        }\n        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n        const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n        const tmpCtx = tmpCanvas.context;\n        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n        graphics.groupLevel = owner.groupLevel;\n        this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n        graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n        tmpCtx.save();\n        this.clipBbox(graphics, x0, y0, x1, y1);\n        graphics.baseTransform = getCurrentTransform(graphics.ctx);\n        graphics.executeOperatorList(operatorList);\n        graphics.endDrawing();\n        tmpCtx.restore();\n        if (redrawHorizontally || redrawVertically) {\n            const image = tmpCanvas.canvas;\n            if (redrawHorizontally) {\n                canvasWidth = xstep;\n            }\n            if (redrawVertically) {\n                canvasHeight = ystep;\n            }\n            const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n            const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n            const xSize = dimx2.size;\n            const ySize = dimy2.size;\n            const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n            const tmpCtx2 = tmpCanvas2.context;\n            const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n            const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n            for(let i = 0; i <= ii; i++){\n                for(let j = 0; j <= jj; j++){\n                    tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n                }\n            }\n            return {\n                canvas: tmpCanvas2.canvas,\n                scaleX: dimx2.scale,\n                scaleY: dimy2.scale,\n                offsetX: x0,\n                offsetY: y0\n            };\n        }\n        return {\n            canvas: tmpCanvas.canvas,\n            scaleX: dimx.scale,\n            scaleY: dimy.scale,\n            offsetX: x0,\n            offsetY: y0\n        };\n    }\n    getSizeAndScale(step, realOutputSize, scale) {\n        const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n        let size = Math.ceil(step * scale);\n        if (size >= maxSize) {\n            size = maxSize;\n        } else {\n            scale = size / step;\n        }\n        return {\n            scale,\n            size\n        };\n    }\n    clipBbox(graphics, x0, y0, x1, y1) {\n        const bboxWidth = x1 - x0;\n        const bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        graphics.current.updateRectMinMax(getCurrentTransform(graphics.ctx), [\n            x0,\n            y0,\n            x1,\n            y1\n        ]);\n        graphics.clip();\n        graphics.endPath();\n    }\n    setFillAndStrokeStyleToContext(graphics, paintType, color) {\n        const context = graphics.ctx, current = graphics.current;\n        switch(paintType){\n            case PaintType.COLORED:\n                const ctx = this.ctx;\n                context.fillStyle = ctx.fillStyle;\n                context.strokeStyle = ctx.strokeStyle;\n                current.fillColor = ctx.fillStyle;\n                current.strokeColor = ctx.strokeStyle;\n                break;\n            case PaintType.UNCOLORED:\n                const cssColor = Util.makeHexColor(color[0], color[1], color[2]);\n                context.fillStyle = cssColor;\n                context.strokeStyle = cssColor;\n                current.fillColor = cssColor;\n                current.strokeColor = cssColor;\n                break;\n            default:\n                throw new FormatError(`Unsupported paint type: ${paintType}`);\n        }\n    }\n    getPattern(ctx, owner, inverse, pathType) {\n        let matrix = inverse;\n        if (pathType !== PathType.SHADING) {\n            matrix = Util.transform(matrix, owner.baseTransform);\n            if (this.matrix) {\n                matrix = Util.transform(matrix, this.matrix);\n            }\n        }\n        const temporaryPatternCanvas = this.createPatternCanvas(owner);\n        let domMatrix = new DOMMatrix(matrix);\n        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n        pattern.setTransform(domMatrix);\n        return pattern;\n    }\n}\n; // ./src/shared/image_utils.js\nfunction convertToRGBA(params) {\n    switch(params.kind){\n        case ImageKind.GRAYSCALE_1BPP:\n            return convertBlackAndWhiteToRGBA(params);\n        case ImageKind.RGB_24BPP:\n            return convertRGBToRGBA(params);\n    }\n    return null;\n}\nfunction convertBlackAndWhiteToRGBA({ src, srcPos = 0, dest, width, height, nonBlackColor = 0xffffffff, inverseDecode = false }) {\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    const [zeroMapping, oneMapping] = inverseDecode ? [\n        nonBlackColor,\n        black\n    ] : [\n        black,\n        nonBlackColor\n    ];\n    const widthInSource = width >> 3;\n    const widthRemainder = width & 7;\n    const srcLength = src.length;\n    dest = new Uint32Array(dest.buffer);\n    let destPos = 0;\n    for(let i = 0; i < height; i++){\n        for(const max = srcPos + widthInSource; srcPos < max; srcPos++){\n            const elem = srcPos < srcLength ? src[srcPos] : 255;\n            dest[destPos++] = elem & 128 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 64 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 32 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 16 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 8 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 4 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 2 ? oneMapping : zeroMapping;\n            dest[destPos++] = elem & 1 ? oneMapping : zeroMapping;\n        }\n        if (widthRemainder === 0) {\n            continue;\n        }\n        const elem = srcPos < srcLength ? src[srcPos++] : 255;\n        for(let j = 0; j < widthRemainder; j++){\n            dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction convertRGBToRGBA({ src, srcPos = 0, dest, destPos = 0, width, height }) {\n    let i = 0;\n    const len32 = src.length >> 2;\n    const src32 = new Uint32Array(src.buffer, srcPos, len32);\n    if (FeatureTest.isLittleEndian) {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff000000;\n            dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n            dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n            dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n        }\n        for(let j = i * 4, jj = src.length; j < jj; j += 3){\n            dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n        }\n    } else {\n        for(; i < len32 - 2; i += 3, destPos += 4){\n            const s1 = src32[i];\n            const s2 = src32[i + 1];\n            const s3 = src32[i + 2];\n            dest[destPos] = s1 | 0xff;\n            dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n            dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n            dest[destPos + 3] = s3 << 8 | 0xff;\n        }\n        for(let j = i * 4, jj = src.length; j < jj; j += 3){\n            dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n        }\n    }\n    return {\n        srcPos,\n        destPos\n    };\n}\nfunction grayToRGBA(src, dest) {\n    if (FeatureTest.isLittleEndian) {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x10101 | 0xff000000;\n        }\n    } else {\n        for(let i = 0, ii = src.length; i < ii; i++){\n            dest[i] = src[i] * 0x1010100 | 0x000000ff;\n        }\n    }\n}\n; // ./src/display/canvas.js\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nfunction mirrorContextOperations(ctx, destCtx) {\n    if (ctx._removeMirroring) {\n        throw new Error(\"Context is already forwarding operations.\");\n    }\n    ctx.__originalSave = ctx.save;\n    ctx.__originalRestore = ctx.restore;\n    ctx.__originalRotate = ctx.rotate;\n    ctx.__originalScale = ctx.scale;\n    ctx.__originalTranslate = ctx.translate;\n    ctx.__originalTransform = ctx.transform;\n    ctx.__originalSetTransform = ctx.setTransform;\n    ctx.__originalResetTransform = ctx.resetTransform;\n    ctx.__originalClip = ctx.clip;\n    ctx.__originalMoveTo = ctx.moveTo;\n    ctx.__originalLineTo = ctx.lineTo;\n    ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n    ctx.__originalRect = ctx.rect;\n    ctx.__originalClosePath = ctx.closePath;\n    ctx.__originalBeginPath = ctx.beginPath;\n    ctx._removeMirroring = ()=>{\n        ctx.save = ctx.__originalSave;\n        ctx.restore = ctx.__originalRestore;\n        ctx.rotate = ctx.__originalRotate;\n        ctx.scale = ctx.__originalScale;\n        ctx.translate = ctx.__originalTranslate;\n        ctx.transform = ctx.__originalTransform;\n        ctx.setTransform = ctx.__originalSetTransform;\n        ctx.resetTransform = ctx.__originalResetTransform;\n        ctx.clip = ctx.__originalClip;\n        ctx.moveTo = ctx.__originalMoveTo;\n        ctx.lineTo = ctx.__originalLineTo;\n        ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n        ctx.rect = ctx.__originalRect;\n        ctx.closePath = ctx.__originalClosePath;\n        ctx.beginPath = ctx.__originalBeginPath;\n        delete ctx._removeMirroring;\n    };\n    ctx.save = function ctxSave() {\n        destCtx.save();\n        this.__originalSave();\n    };\n    ctx.restore = function ctxRestore() {\n        destCtx.restore();\n        this.__originalRestore();\n    };\n    ctx.translate = function ctxTranslate(x, y) {\n        destCtx.translate(x, y);\n        this.__originalTranslate(x, y);\n    };\n    ctx.scale = function ctxScale(x, y) {\n        destCtx.scale(x, y);\n        this.__originalScale(x, y);\n    };\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n        destCtx.transform(a, b, c, d, e, f);\n        this.__originalTransform(a, b, c, d, e, f);\n    };\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n        destCtx.setTransform(a, b, c, d, e, f);\n        this.__originalSetTransform(a, b, c, d, e, f);\n    };\n    ctx.resetTransform = function ctxResetTransform() {\n        destCtx.resetTransform();\n        this.__originalResetTransform();\n    };\n    ctx.rotate = function ctxRotate(angle) {\n        destCtx.rotate(angle);\n        this.__originalRotate(angle);\n    };\n    ctx.clip = function ctxRotate(rule) {\n        destCtx.clip(rule);\n        this.__originalClip(rule);\n    };\n    ctx.moveTo = function(x, y) {\n        destCtx.moveTo(x, y);\n        this.__originalMoveTo(x, y);\n    };\n    ctx.lineTo = function(x, y) {\n        destCtx.lineTo(x, y);\n        this.__originalLineTo(x, y);\n    };\n    ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {\n        destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n        this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    };\n    ctx.rect = function(x, y, width, height) {\n        destCtx.rect(x, y, width, height);\n        this.__originalRect(x, y, width, height);\n    };\n    ctx.closePath = function() {\n        destCtx.closePath();\n        this.__originalClosePath();\n    };\n    ctx.beginPath = function() {\n        destCtx.beginPath();\n        this.__originalBeginPath();\n    };\n}\nclass CachedCanvases {\n    constructor(canvasFactory){\n        this.canvasFactory = canvasFactory;\n        this.cache = Object.create(null);\n    }\n    getCanvas(id, width, height) {\n        let canvasEntry;\n        if (this.cache[id] !== undefined) {\n            canvasEntry = this.cache[id];\n            this.canvasFactory.reset(canvasEntry, width, height);\n        } else {\n            canvasEntry = this.canvasFactory.create(width, height);\n            this.cache[id] = canvasEntry;\n        }\n        return canvasEntry;\n    }\n    delete(id) {\n        delete this.cache[id];\n    }\n    clear() {\n        for(const id in this.cache){\n            const canvasEntry = this.cache[id];\n            this.canvasFactory.destroy(canvasEntry);\n            delete this.cache[id];\n        }\n    }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n    const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n    if (b === 0 && c === 0) {\n        const tlX = destX * a + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destY * d + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destX + destW) * a + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destY + destH) * d + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rWidth,\n            rHeight\n        ];\n    }\n    if (a === 0 && d === 0) {\n        const tlX = destY * c + tx;\n        const rTlX = Math.round(tlX);\n        const tlY = destX * b + ty;\n        const rTlY = Math.round(tlY);\n        const brX = (destY + destH) * c + tx;\n        const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n        const brY = (destX + destW) * b + ty;\n        const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n        ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n        ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n        ctx.setTransform(a, b, c, d, tx, ty);\n        return [\n            rHeight,\n            rWidth\n        ];\n    }\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n    const scaleX = Math.hypot(a, b);\n    const scaleY = Math.hypot(c, d);\n    return [\n        scaleX * destW,\n        scaleY * destH\n    ];\n}\nfunction compileType3Glyph(imgData) {\n    const { width, height } = imgData;\n    if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n        return null;\n    }\n    const POINT_TO_PROCESS_LIMIT = 1000;\n    const POINT_TYPES = new Uint8Array([\n        0,\n        2,\n        4,\n        0,\n        1,\n        0,\n        5,\n        4,\n        8,\n        10,\n        0,\n        8,\n        0,\n        2,\n        1,\n        0\n    ]);\n    const width1 = width + 1;\n    let points = new Uint8Array(width1 * (height + 1));\n    let i, j, j0;\n    const lineSize = width + 7 & ~7;\n    let data = new Uint8Array(lineSize * height), pos = 0;\n    for (const elem of imgData.data){\n        let mask = 128;\n        while(mask > 0){\n            data[pos++] = elem & mask ? 0 : 255;\n            mask >>= 1;\n        }\n    }\n    let count = 0;\n    pos = 0;\n    if (data[pos] !== 0) {\n        points[0] = 1;\n        ++count;\n    }\n    for(j = 1; j < width; j++){\n        if (data[pos] !== data[pos + 1]) {\n            points[j] = data[pos] ? 2 : 1;\n            ++count;\n        }\n        pos++;\n    }\n    if (data[pos] !== 0) {\n        points[j] = 2;\n        ++count;\n    }\n    for(i = 1; i < height; i++){\n        pos = i * lineSize;\n        j0 = i * width1;\n        if (data[pos - lineSize] !== data[pos]) {\n            points[j0] = data[pos] ? 1 : 8;\n            ++count;\n        }\n        let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n        for(j = 1; j < width; j++){\n            sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n            if (POINT_TYPES[sum]) {\n                points[j0 + j] = POINT_TYPES[sum];\n                ++count;\n            }\n            pos++;\n        }\n        if (data[pos - lineSize] !== data[pos]) {\n            points[j0 + j] = data[pos] ? 2 : 4;\n            ++count;\n        }\n        if (count > POINT_TO_PROCESS_LIMIT) {\n            return null;\n        }\n    }\n    pos = lineSize * (height - 1);\n    j0 = i * width1;\n    if (data[pos] !== 0) {\n        points[j0] = 8;\n        ++count;\n    }\n    for(j = 1; j < width; j++){\n        if (data[pos] !== data[pos + 1]) {\n            points[j0 + j] = data[pos] ? 4 : 8;\n            ++count;\n        }\n        pos++;\n    }\n    if (data[pos] !== 0) {\n        points[j0 + j] = 4;\n        ++count;\n    }\n    if (count > POINT_TO_PROCESS_LIMIT) {\n        return null;\n    }\n    const steps = new Int32Array([\n        0,\n        width1,\n        -1,\n        0,\n        -width1,\n        0,\n        0,\n        0,\n        1\n    ]);\n    const path = new Path2D();\n    for(i = 0; count && i <= height; i++){\n        let p = i * width1;\n        const end = p + width;\n        while(p < end && !points[p]){\n            p++;\n        }\n        if (p === end) {\n            continue;\n        }\n        path.moveTo(p % width1, i);\n        const p0 = p;\n        let type = points[p];\n        do {\n            const step = steps[type];\n            do {\n                p += step;\n            }while (!points[p]);\n            const pp = points[p];\n            if (pp !== 5 && pp !== 10) {\n                type = pp;\n                points[p] = 0;\n            } else {\n                type = pp & 0x33 * type >> 4;\n                points[p] &= type >> 2 | type << 2;\n            }\n            path.lineTo(p % width1, p / width1 | 0);\n            if (!points[p]) {\n                --count;\n            }\n        }while (p0 !== p);\n        --i;\n    }\n    data = null;\n    points = null;\n    const drawOutline = function(c) {\n        c.save();\n        c.scale(1 / width, -1 / height);\n        c.translate(0, -height);\n        c.fill(path);\n        c.beginPath();\n        c.restore();\n    };\n    return drawOutline;\n}\nclass CanvasExtraState {\n    constructor(width, height){\n        this.alphaIsShape = false;\n        this.fontSize = 0;\n        this.fontSizeScale = 1;\n        this.textMatrix = IDENTITY_MATRIX;\n        this.textMatrixScale = 1;\n        this.fontMatrix = FONT_IDENTITY_MATRIX;\n        this.leading = 0;\n        this.x = 0;\n        this.y = 0;\n        this.lineX = 0;\n        this.lineY = 0;\n        this.charSpacing = 0;\n        this.wordSpacing = 0;\n        this.textHScale = 1;\n        this.textRenderingMode = TextRenderingMode.FILL;\n        this.textRise = 0;\n        this.fillColor = \"#000000\";\n        this.strokeColor = \"#000000\";\n        this.patternFill = false;\n        this.fillAlpha = 1;\n        this.strokeAlpha = 1;\n        this.lineWidth = 1;\n        this.activeSMask = null;\n        this.transferMaps = \"none\";\n        this.startNewPathAndClipBox([\n            0,\n            0,\n            width,\n            height\n        ]);\n    }\n    clone() {\n        const clone = Object.create(this);\n        clone.clipBox = this.clipBox.slice();\n        return clone;\n    }\n    setCurrentPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    updatePathMinMax(transform, x, y) {\n        [x, y] = Util.applyTransform([\n            x,\n            y\n        ], transform);\n        this.minX = Math.min(this.minX, x);\n        this.minY = Math.min(this.minY, y);\n        this.maxX = Math.max(this.maxX, x);\n        this.maxY = Math.max(this.maxY, y);\n    }\n    updateRectMinMax(transform, rect) {\n        const p1 = Util.applyTransform(rect, transform);\n        const p2 = Util.applyTransform(rect.slice(2), transform);\n        const p3 = Util.applyTransform([\n            rect[0],\n            rect[3]\n        ], transform);\n        const p4 = Util.applyTransform([\n            rect[2],\n            rect[1]\n        ], transform);\n        this.minX = Math.min(this.minX, p1[0], p2[0], p3[0], p4[0]);\n        this.minY = Math.min(this.minY, p1[1], p2[1], p3[1], p4[1]);\n        this.maxX = Math.max(this.maxX, p1[0], p2[0], p3[0], p4[0]);\n        this.maxY = Math.max(this.maxY, p1[1], p2[1], p3[1], p4[1]);\n    }\n    updateScalingPathMinMax(transform, minMax) {\n        Util.scaleMinMax(transform, minMax);\n        this.minX = Math.min(this.minX, minMax[0]);\n        this.minY = Math.min(this.minY, minMax[1]);\n        this.maxX = Math.max(this.maxX, minMax[2]);\n        this.maxY = Math.max(this.maxY, minMax[3]);\n    }\n    updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n        const box = Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax);\n        if (minMax) {\n            return;\n        }\n        this.updateRectMinMax(transform, box);\n    }\n    getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        const box = [\n            this.minX,\n            this.minY,\n            this.maxX,\n            this.maxY\n        ];\n        if (pathType === PathType.STROKE) {\n            if (!transform) {\n                unreachable(\"Stroke bounding box must include transform.\");\n            }\n            const scale = Util.singularValueDecompose2dScale(transform);\n            const xStrokePad = scale[0] * this.lineWidth / 2;\n            const yStrokePad = scale[1] * this.lineWidth / 2;\n            box[0] -= xStrokePad;\n            box[1] -= yStrokePad;\n            box[2] += xStrokePad;\n            box[3] += yStrokePad;\n        }\n        return box;\n    }\n    updateClipFromPath() {\n        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n        this.startNewPathAndClipBox(intersect || [\n            0,\n            0,\n            0,\n            0\n        ]);\n    }\n    isEmptyClip() {\n        return this.minX === Infinity;\n    }\n    startNewPathAndClipBox(box) {\n        this.clipBox = box;\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = 0;\n        this.maxY = 0;\n    }\n    getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n    }\n}\nfunction putBinaryImageData(ctx, imgData) {\n    if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n        ctx.putImageData(imgData, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0, destPos;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    let i, j, thisChunkHeight, elemsInThisChunk;\n    if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n        const srcLength = src.byteLength;\n        const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n        const dest32DataLength = dest32.length;\n        const fullSrcDiff = width + 7 >> 3;\n        const white = 0xffffffff;\n        const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n        for(i = 0; i < totalChunks; i++){\n            thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n            destPos = 0;\n            for(j = 0; j < thisChunkHeight; j++){\n                const srcDiff = srcLength - srcPos;\n                let k = 0;\n                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n                const kEndUnrolled = kEnd & ~7;\n                let mask = 0;\n                let srcByte = 0;\n                for(; k < kEndUnrolled; k += 8){\n                    srcByte = src[srcPos++];\n                    dest32[destPos++] = srcByte & 128 ? white : black;\n                    dest32[destPos++] = srcByte & 64 ? white : black;\n                    dest32[destPos++] = srcByte & 32 ? white : black;\n                    dest32[destPos++] = srcByte & 16 ? white : black;\n                    dest32[destPos++] = srcByte & 8 ? white : black;\n                    dest32[destPos++] = srcByte & 4 ? white : black;\n                    dest32[destPos++] = srcByte & 2 ? white : black;\n                    dest32[destPos++] = srcByte & 1 ? white : black;\n                }\n                for(; k < kEnd; k++){\n                    if (mask === 0) {\n                        srcByte = src[srcPos++];\n                        mask = 128;\n                    }\n                    dest32[destPos++] = srcByte & mask ? white : black;\n                    mask >>= 1;\n                }\n            }\n            while(destPos < dest32DataLength){\n                dest32[destPos++] = 0;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n        j = 0;\n        elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n        for(i = 0; i < fullChunks; i++){\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            srcPos += elemsInThisChunk;\n            ctx.putImageData(chunkImgData, 0, j);\n            j += FULL_CHUNK_HEIGHT;\n        }\n        if (i < totalChunks) {\n            elemsInThisChunk = width * partialChunkHeight * 4;\n            dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n            ctx.putImageData(chunkImgData, 0, j);\n        }\n    } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n        thisChunkHeight = FULL_CHUNK_HEIGHT;\n        elemsInThisChunk = width * thisChunkHeight;\n        for(i = 0; i < totalChunks; i++){\n            if (i >= fullChunks) {\n                thisChunkHeight = partialChunkHeight;\n                elemsInThisChunk = width * thisChunkHeight;\n            }\n            destPos = 0;\n            for(j = elemsInThisChunk; j--;){\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = src[srcPos++];\n                dest[destPos++] = 255;\n            }\n            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n        }\n    } else {\n        throw new Error(`bad image kind: ${imgData.kind}`);\n    }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n    if (imgData.bitmap) {\n        ctx.drawImage(imgData.bitmap, 0, 0);\n        return;\n    }\n    const height = imgData.height, width = imgData.width;\n    const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    let srcPos = 0;\n    const src = imgData.data;\n    const dest = chunkImgData.data;\n    for(let i = 0; i < totalChunks; i++){\n        const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        ({ srcPos } = convertBlackAndWhiteToRGBA({\n            src,\n            srcPos,\n            dest,\n            width,\n            height: thisChunkHeight,\n            nonBlackColor: 0\n        }));\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n    const properties = [\n        \"strokeStyle\",\n        \"fillStyle\",\n        \"fillRule\",\n        \"globalAlpha\",\n        \"lineWidth\",\n        \"lineCap\",\n        \"lineJoin\",\n        \"miterLimit\",\n        \"globalCompositeOperation\",\n        \"font\",\n        \"filter\"\n    ];\n    for (const property of properties){\n        if (sourceCtx[property] !== undefined) {\n            destCtx[property] = sourceCtx[property];\n        }\n    }\n    if (sourceCtx.setLineDash !== undefined) {\n        destCtx.setLineDash(sourceCtx.getLineDash());\n        destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n}\nfunction resetCtxToDefault(ctx) {\n    ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n    if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash([]);\n        ctx.lineDashOffset = 0;\n    }\n    if (!isNodeJS) {\n        const { filter } = ctx;\n        if (filter !== \"none\" && filter !== \"\") {\n            ctx.filter = \"none\";\n        }\n    }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n    if (interpolate) {\n        return true;\n    }\n    const scale = Util.singularValueDecompose2dScale(transform);\n    scale[0] = Math.fround(scale[0]);\n    scale[1] = Math.fround(scale[1]);\n    const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * PixelsPerInch.PDF_TO_CSS_UNITS);\n    return scale[0] <= actualScale && scale[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\n    \"butt\",\n    \"round\",\n    \"square\"\n];\nconst LINE_JOIN_STYLES = [\n    \"miter\",\n    \"round\",\n    \"bevel\"\n];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n    constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, { optionalContentConfig, markedContentStack = null }, annotationCanvasMap, pageColors){\n        this.ctx = canvasCtx;\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.stateStack = [];\n        this.pendingClip = null;\n        this.pendingEOFill = false;\n        this.res = null;\n        this.xobjs = null;\n        this.commonObjs = commonObjs;\n        this.objs = objs;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this.groupStack = [];\n        this.processingType3 = null;\n        this.baseTransform = null;\n        this.baseTransformStack = [];\n        this.groupLevel = 0;\n        this.smaskStack = [];\n        this.smaskCounter = 0;\n        this.tempSMask = null;\n        this.suspendedCtx = null;\n        this.contentVisible = true;\n        this.markedContentStack = markedContentStack || [];\n        this.optionalContentConfig = optionalContentConfig;\n        this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n        this.cachedPatterns = new Map();\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.viewportScale = 1;\n        this.outputScaleX = 1;\n        this.outputScaleY = 1;\n        this.pageColors = pageColors;\n        this._cachedScaleForStroking = [\n            -1,\n            0\n        ];\n        this._cachedGetSinglePixelWidth = null;\n        this._cachedBitmapsMap = new Map();\n    }\n    getObject(data, fallback = null) {\n        if (typeof data === \"string\") {\n            return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n        }\n        return fallback;\n    }\n    beginDrawing({ transform, viewport, transparency = false, background = null }) {\n        const width = this.ctx.canvas.width;\n        const height = this.ctx.canvas.height;\n        const savedFillStyle = this.ctx.fillStyle;\n        this.ctx.fillStyle = background || \"#ffffff\";\n        this.ctx.fillRect(0, 0, width, height);\n        this.ctx.fillStyle = savedFillStyle;\n        if (transparency) {\n            const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n            this.compositeCtx = this.ctx;\n            this.transparentCanvas = transparentCanvas.canvas;\n            this.ctx = transparentCanvas.context;\n            this.ctx.save();\n            this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n        }\n        this.ctx.save();\n        resetCtxToDefault(this.ctx);\n        if (transform) {\n            this.ctx.transform(...transform);\n            this.outputScaleX = transform[0];\n            this.outputScaleY = transform[0];\n        }\n        this.ctx.transform(...viewport.transform);\n        this.viewportScale = viewport.scale;\n        this.baseTransform = getCurrentTransform(this.ctx);\n    }\n    executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n        const argsArray = operatorList.argsArray;\n        const fnArray = operatorList.fnArray;\n        let i = executionStartIdx || 0;\n        const argsArrayLen = argsArray.length;\n        if (argsArrayLen === i) {\n            return i;\n        }\n        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n        let steps = 0;\n        const commonObjs = this.commonObjs;\n        const objs = this.objs;\n        let fnId;\n        while(true){\n            if (stepper !== undefined && i === stepper.nextBreakPoint) {\n                stepper.breakIt(i, continueCallback);\n                return i;\n            }\n            fnId = fnArray[i];\n            if (fnId !== OPS.dependency) {\n                this[fnId].apply(this, argsArray[i]);\n            } else {\n                for (const depObjId of argsArray[i]){\n                    const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n                    if (!objsPool.has(depObjId)) {\n                        objsPool.get(depObjId, continueCallback);\n                        return i;\n                    }\n                }\n            }\n            i++;\n            if (i === argsArrayLen) {\n                return i;\n            }\n            if (chunkOperations && ++steps > EXECUTION_STEPS) {\n                if (Date.now() > endTime) {\n                    continueCallback();\n                    return i;\n                }\n                steps = 0;\n            }\n        }\n    }\n    #restoreInitialState() {\n        while(this.stateStack.length || this.inSMaskMode){\n            this.restore();\n        }\n        this.current.activeSMask = null;\n        this.ctx.restore();\n        if (this.transparentCanvas) {\n            this.ctx = this.compositeCtx;\n            this.ctx.save();\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.drawImage(this.transparentCanvas, 0, 0);\n            this.ctx.restore();\n            this.transparentCanvas = null;\n        }\n    }\n    endDrawing() {\n        this.#restoreInitialState();\n        this.cachedCanvases.clear();\n        this.cachedPatterns.clear();\n        for (const cache of this._cachedBitmapsMap.values()){\n            for (const canvas of cache.values()){\n                if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n                    canvas.width = canvas.height = 0;\n                }\n            }\n            cache.clear();\n        }\n        this._cachedBitmapsMap.clear();\n        this.#drawFilter();\n    }\n    #drawFilter() {\n        if (this.pageColors) {\n            const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n            if (hcmFilterId !== \"none\") {\n                const savedFilter = this.ctx.filter;\n                this.ctx.filter = hcmFilterId;\n                this.ctx.drawImage(this.ctx.canvas, 0, 0);\n                this.ctx.filter = savedFilter;\n            }\n        }\n    }\n    _scaleImage(img, inverseTransform) {\n        const width = img.width ?? img.displayWidth;\n        const height = img.height ?? img.displayHeight;\n        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n        let paintWidth = width, paintHeight = height;\n        let tmpCanvasId = \"prescale1\";\n        let tmpCanvas, tmpCtx;\n        while(widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1){\n            let newWidth = paintWidth, newHeight = paintHeight;\n            if (widthScale > 2 && paintWidth > 1) {\n                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n                widthScale /= paintWidth / newWidth;\n            }\n            if (heightScale > 2 && paintHeight > 1) {\n                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n                heightScale /= paintHeight / newHeight;\n            }\n            tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n            tmpCtx = tmpCanvas.context;\n            tmpCtx.clearRect(0, 0, newWidth, newHeight);\n            tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n            img = tmpCanvas.canvas;\n            paintWidth = newWidth;\n            paintHeight = newHeight;\n            tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n        }\n        return {\n            img,\n            paintWidth,\n            paintHeight\n        };\n    }\n    _createMaskCanvas(img) {\n        const ctx = this.ctx;\n        const { width, height } = img;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        const currentTransform = getCurrentTransform(ctx);\n        let cache, cacheKey, scaled, maskCanvas;\n        if ((img.bitmap || img.data) && img.count > 1) {\n            const mainKey = img.bitmap || img.data.buffer;\n            cacheKey = JSON.stringify(isPatternFill ? currentTransform : [\n                currentTransform.slice(0, 4),\n                fillColor\n            ]);\n            cache = this._cachedBitmapsMap.get(mainKey);\n            if (!cache) {\n                cache = new Map();\n                this._cachedBitmapsMap.set(mainKey, cache);\n            }\n            const cachedImage = cache.get(cacheKey);\n            if (cachedImage && !isPatternFill) {\n                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n                return {\n                    canvas: cachedImage,\n                    offsetX,\n                    offsetY\n                };\n            }\n            scaled = cachedImage;\n        }\n        if (!scaled) {\n            maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            putBinaryImageMask(maskCanvas.context, img);\n        }\n        let maskToCanvas = Util.transform(currentTransform, [\n            1 / width,\n            0,\n            0,\n            -1 / height,\n            0,\n            0\n        ]);\n        maskToCanvas = Util.transform(maskToCanvas, [\n            1,\n            0,\n            0,\n            1,\n            0,\n            -height\n        ]);\n        const [minX, minY, maxX, maxY] = Util.getAxialAlignedBoundingBox([\n            0,\n            0,\n            width,\n            height\n        ], maskToCanvas);\n        const drawnWidth = Math.round(maxX - minX) || 1;\n        const drawnHeight = Math.round(maxY - minY) || 1;\n        const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n        const fillCtx = fillCanvas.context;\n        const offsetX = minX;\n        const offsetY = minY;\n        fillCtx.translate(-offsetX, -offsetY);\n        fillCtx.transform(...maskToCanvas);\n        if (!scaled) {\n            scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n            scaled = scaled.img;\n            if (cache && isPatternFill) {\n                cache.set(cacheKey, scaled);\n            }\n        }\n        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n        fillCtx.globalCompositeOperation = \"source-in\";\n        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [\n            1,\n            0,\n            0,\n            1,\n            -offsetX,\n            -offsetY\n        ]);\n        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL) : fillColor;\n        fillCtx.fillRect(0, 0, width, height);\n        if (cache && !isPatternFill) {\n            this.cachedCanvases.delete(\"fillCanvas\");\n            cache.set(cacheKey, fillCanvas.canvas);\n        }\n        return {\n            canvas: fillCanvas.canvas,\n            offsetX: Math.round(offsetX),\n            offsetY: Math.round(offsetY)\n        };\n    }\n    setLineWidth(width) {\n        if (width !== this.current.lineWidth) {\n            this._cachedScaleForStroking[0] = -1;\n        }\n        this.current.lineWidth = width;\n        this.ctx.lineWidth = width;\n    }\n    setLineCap(style) {\n        this.ctx.lineCap = LINE_CAP_STYLES[style];\n    }\n    setLineJoin(style) {\n        this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    }\n    setMiterLimit(limit) {\n        this.ctx.miterLimit = limit;\n    }\n    setDash(dashArray, dashPhase) {\n        const ctx = this.ctx;\n        if (ctx.setLineDash !== undefined) {\n            ctx.setLineDash(dashArray);\n            ctx.lineDashOffset = dashPhase;\n        }\n    }\n    setRenderingIntent(intent) {}\n    setFlatness(flatness) {}\n    setGState(states) {\n        for (const [key, value] of states){\n            switch(key){\n                case \"LW\":\n                    this.setLineWidth(value);\n                    break;\n                case \"LC\":\n                    this.setLineCap(value);\n                    break;\n                case \"LJ\":\n                    this.setLineJoin(value);\n                    break;\n                case \"ML\":\n                    this.setMiterLimit(value);\n                    break;\n                case \"D\":\n                    this.setDash(value[0], value[1]);\n                    break;\n                case \"RI\":\n                    this.setRenderingIntent(value);\n                    break;\n                case \"FL\":\n                    this.setFlatness(value);\n                    break;\n                case \"Font\":\n                    this.setFont(value[0], value[1]);\n                    break;\n                case \"CA\":\n                    this.current.strokeAlpha = value;\n                    break;\n                case \"ca\":\n                    this.current.fillAlpha = value;\n                    this.ctx.globalAlpha = value;\n                    break;\n                case \"BM\":\n                    this.ctx.globalCompositeOperation = value;\n                    break;\n                case \"SMask\":\n                    this.current.activeSMask = value ? this.tempSMask : null;\n                    this.tempSMask = null;\n                    this.checkSMaskState();\n                    break;\n                case \"TR\":\n                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n                    break;\n            }\n        }\n    }\n    get inSMaskMode() {\n        return !!this.suspendedCtx;\n    }\n    checkSMaskState() {\n        const inSMaskMode = this.inSMaskMode;\n        if (this.current.activeSMask && !inSMaskMode) {\n            this.beginSMaskMode();\n        } else if (!this.current.activeSMask && inSMaskMode) {\n            this.endSMaskMode();\n        }\n    }\n    beginSMaskMode() {\n        if (this.inSMaskMode) {\n            throw new Error(\"beginSMaskMode called while already in smask mode\");\n        }\n        const drawnWidth = this.ctx.canvas.width;\n        const drawnHeight = this.ctx.canvas.height;\n        const cacheId = \"smaskGroupAt\" + this.groupLevel;\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        this.suspendedCtx = this.ctx;\n        this.ctx = scratchCanvas.context;\n        const ctx = this.ctx;\n        ctx.setTransform(...getCurrentTransform(this.suspendedCtx));\n        copyCtxState(this.suspendedCtx, ctx);\n        mirrorContextOperations(ctx, this.suspendedCtx);\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n    }\n    endSMaskMode() {\n        if (!this.inSMaskMode) {\n            throw new Error(\"endSMaskMode called while not in smask mode\");\n        }\n        this.ctx._removeMirroring();\n        copyCtxState(this.ctx, this.suspendedCtx);\n        this.ctx = this.suspendedCtx;\n        this.suspendedCtx = null;\n    }\n    compose(dirtyBox) {\n        if (!this.current.activeSMask) {\n            return;\n        }\n        if (!dirtyBox) {\n            dirtyBox = [\n                0,\n                0,\n                this.ctx.canvas.width,\n                this.ctx.canvas.height\n            ];\n        } else {\n            dirtyBox[0] = Math.floor(dirtyBox[0]);\n            dirtyBox[1] = Math.floor(dirtyBox[1]);\n            dirtyBox[2] = Math.ceil(dirtyBox[2]);\n            dirtyBox[3] = Math.ceil(dirtyBox[3]);\n        }\n        const smask = this.current.activeSMask;\n        const suspendedCtx = this.suspendedCtx;\n        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n        this.ctx.restore();\n    }\n    composeSMask(ctx, smask, layerCtx, layerBox) {\n        const layerOffsetX = layerBox[0];\n        const layerOffsetY = layerBox[1];\n        const layerWidth = layerBox[2] - layerOffsetX;\n        const layerHeight = layerBox[3] - layerOffsetY;\n        if (layerWidth === 0 || layerHeight === 0) {\n            return;\n        }\n        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n        ctx.save();\n        ctx.globalAlpha = 1;\n        ctx.globalCompositeOperation = \"source-over\";\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(layerCtx.canvas, 0, 0);\n        ctx.restore();\n    }\n    genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n        let maskCanvas = maskCtx.canvas;\n        let maskX = layerOffsetX - maskOffsetX;\n        let maskY = layerOffsetY - maskOffsetY;\n        if (backdrop) {\n            const backdropRGB = Util.makeHexColor(...backdrop);\n            if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n                const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n                const ctx = canvas.context;\n                ctx.drawImage(maskCanvas, -maskX, -maskY);\n                ctx.globalCompositeOperation = \"destination-atop\";\n                ctx.fillStyle = backdropRGB;\n                ctx.fillRect(0, 0, width, height);\n                ctx.globalCompositeOperation = \"source-over\";\n                maskCanvas = canvas.canvas;\n                maskX = maskY = 0;\n            } else {\n                maskCtx.save();\n                maskCtx.globalAlpha = 1;\n                maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n                const clip = new Path2D();\n                clip.rect(maskX, maskY, width, height);\n                maskCtx.clip(clip);\n                maskCtx.globalCompositeOperation = \"destination-atop\";\n                maskCtx.fillStyle = backdropRGB;\n                maskCtx.fillRect(maskX, maskY, width, height);\n                maskCtx.restore();\n            }\n        }\n        layerCtx.save();\n        layerCtx.globalAlpha = 1;\n        layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n        if (subtype === \"Alpha\" && transferMap) {\n            layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n        } else if (subtype === \"Luminosity\") {\n            layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n        }\n        const clip = new Path2D();\n        clip.rect(layerOffsetX, layerOffsetY, width, height);\n        layerCtx.clip(clip);\n        layerCtx.globalCompositeOperation = \"destination-in\";\n        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n        layerCtx.restore();\n    }\n    save() {\n        if (this.inSMaskMode) {\n            copyCtxState(this.ctx, this.suspendedCtx);\n            this.suspendedCtx.save();\n        } else {\n            this.ctx.save();\n        }\n        const old = this.current;\n        this.stateStack.push(old);\n        this.current = old.clone();\n    }\n    restore() {\n        if (this.stateStack.length === 0 && this.inSMaskMode) {\n            this.endSMaskMode();\n        }\n        if (this.stateStack.length !== 0) {\n            this.current = this.stateStack.pop();\n            if (this.inSMaskMode) {\n                this.suspendedCtx.restore();\n                copyCtxState(this.suspendedCtx, this.ctx);\n            } else {\n                this.ctx.restore();\n            }\n            this.checkSMaskState();\n            this.pendingClip = null;\n            this._cachedScaleForStroking[0] = -1;\n            this._cachedGetSinglePixelWidth = null;\n        }\n    }\n    transform(a, b, c, d, e, f) {\n        this.ctx.transform(a, b, c, d, e, f);\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n    }\n    constructPath(ops, args, minMax) {\n        const ctx = this.ctx;\n        const current = this.current;\n        let x = current.x, y = current.y;\n        let startX, startY;\n        const currentTransform = getCurrentTransform(ctx);\n        const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n        const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n        for(let i = 0, j = 0, ii = ops.length; i < ii; i++){\n            switch(ops[i] | 0){\n                case OPS.rectangle:\n                    x = args[j++];\n                    y = args[j++];\n                    const width = args[j++];\n                    const height = args[j++];\n                    const xw = x + width;\n                    const yh = y + height;\n                    ctx.moveTo(x, y);\n                    if (width === 0 || height === 0) {\n                        ctx.lineTo(xw, yh);\n                    } else {\n                        ctx.lineTo(xw, y);\n                        ctx.lineTo(xw, yh);\n                        ctx.lineTo(x, yh);\n                    }\n                    if (!isScalingMatrix) {\n                        current.updateRectMinMax(currentTransform, [\n                            x,\n                            y,\n                            xw,\n                            yh\n                        ]);\n                    }\n                    ctx.closePath();\n                    break;\n                case OPS.moveTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.moveTo(x, y);\n                    if (!isScalingMatrix) {\n                        current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                case OPS.lineTo:\n                    x = args[j++];\n                    y = args[j++];\n                    ctx.lineTo(x, y);\n                    if (!isScalingMatrix) {\n                        current.updatePathMinMax(currentTransform, x, y);\n                    }\n                    break;\n                case OPS.curveTo:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 4];\n                    y = args[j + 5];\n                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n                    j += 6;\n                    break;\n                case OPS.curveTo2:\n                    startX = x;\n                    startY = y;\n                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    j += 4;\n                    break;\n                case OPS.curveTo3:\n                    startX = x;\n                    startY = y;\n                    x = args[j + 2];\n                    y = args[j + 3];\n                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n                    current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n                    j += 4;\n                    break;\n                case OPS.closePath:\n                    ctx.closePath();\n                    break;\n            }\n        }\n        if (isScalingMatrix) {\n            current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n        }\n        current.setCurrentPoint(x, y);\n    }\n    closePath() {\n        this.ctx.closePath();\n    }\n    stroke(consumePath = true) {\n        const ctx = this.ctx;\n        const strokeColor = this.current.strokeColor;\n        ctx.globalAlpha = this.current.strokeAlpha;\n        if (this.contentVisible) {\n            if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n                ctx.save();\n                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE);\n                this.rescaleAndStroke(false);\n                ctx.restore();\n            } else {\n                this.rescaleAndStroke(true);\n            }\n        }\n        if (consumePath) {\n            this.consumePath(this.current.getClippedPathBoundingBox());\n        }\n        ctx.globalAlpha = this.current.fillAlpha;\n    }\n    closeStroke() {\n        this.closePath();\n        this.stroke();\n    }\n    fill(consumePath = true) {\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        let needRestore = false;\n        if (isPatternFill) {\n            ctx.save();\n            ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            needRestore = true;\n        }\n        const intersect = this.current.getClippedPathBoundingBox();\n        if (this.contentVisible && intersect !== null) {\n            if (this.pendingEOFill) {\n                ctx.fill(\"evenodd\");\n                this.pendingEOFill = false;\n            } else {\n                ctx.fill();\n            }\n        }\n        if (needRestore) {\n            ctx.restore();\n        }\n        if (consumePath) {\n            this.consumePath(intersect);\n        }\n    }\n    eoFill() {\n        this.pendingEOFill = true;\n        this.fill();\n    }\n    fillStroke() {\n        this.fill(false);\n        this.stroke(false);\n        this.consumePath();\n    }\n    eoFillStroke() {\n        this.pendingEOFill = true;\n        this.fillStroke();\n    }\n    closeFillStroke() {\n        this.closePath();\n        this.fillStroke();\n    }\n    closeEOFillStroke() {\n        this.pendingEOFill = true;\n        this.closePath();\n        this.fillStroke();\n    }\n    endPath() {\n        this.consumePath();\n    }\n    clip() {\n        this.pendingClip = NORMAL_CLIP;\n    }\n    eoClip() {\n        this.pendingClip = EO_CLIP;\n    }\n    beginText() {\n        this.current.textMatrix = IDENTITY_MATRIX;\n        this.current.textMatrixScale = 1;\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n    }\n    endText() {\n        const paths = this.pendingTextPaths;\n        const ctx = this.ctx;\n        if (paths === undefined) {\n            ctx.beginPath();\n            return;\n        }\n        ctx.save();\n        ctx.beginPath();\n        for (const path of paths){\n            ctx.setTransform(...path.transform);\n            ctx.translate(path.x, path.y);\n            path.addToPath(ctx, path.fontSize);\n        }\n        ctx.restore();\n        ctx.clip();\n        ctx.beginPath();\n        delete this.pendingTextPaths;\n    }\n    setCharSpacing(spacing) {\n        this.current.charSpacing = spacing;\n    }\n    setWordSpacing(spacing) {\n        this.current.wordSpacing = spacing;\n    }\n    setHScale(scale) {\n        this.current.textHScale = scale / 100;\n    }\n    setLeading(leading) {\n        this.current.leading = -leading;\n    }\n    setFont(fontRefName, size) {\n        const fontObj = this.commonObjs.get(fontRefName);\n        const current = this.current;\n        if (!fontObj) {\n            throw new Error(`Can't find font for ${fontRefName}`);\n        }\n        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n            warn(\"Invalid font matrix for font \" + fontRefName);\n        }\n        if (size < 0) {\n            size = -size;\n            current.fontDirection = -1;\n        } else {\n            current.fontDirection = 1;\n        }\n        this.current.font = fontObj;\n        this.current.fontSize = size;\n        if (fontObj.isType3Font) {\n            return;\n        }\n        const name = fontObj.loadedName || \"sans-serif\";\n        const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n        let bold = \"normal\";\n        if (fontObj.black) {\n            bold = \"900\";\n        } else if (fontObj.bold) {\n            bold = \"bold\";\n        }\n        const italic = fontObj.italic ? \"italic\" : \"normal\";\n        let browserFontSize = size;\n        if (size < MIN_FONT_SIZE) {\n            browserFontSize = MIN_FONT_SIZE;\n        } else if (size > MAX_FONT_SIZE) {\n            browserFontSize = MAX_FONT_SIZE;\n        }\n        this.current.fontSizeScale = size / browserFontSize;\n        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n    }\n    setTextRenderingMode(mode) {\n        this.current.textRenderingMode = mode;\n    }\n    setTextRise(rise) {\n        this.current.textRise = rise;\n    }\n    moveText(x, y) {\n        this.current.x = this.current.lineX += x;\n        this.current.y = this.current.lineY += y;\n    }\n    setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n    }\n    setTextMatrix(a, b, c, d, e, f) {\n        this.current.textMatrix = [\n            a,\n            b,\n            c,\n            d,\n            e,\n            f\n        ];\n        this.current.textMatrixScale = Math.hypot(a, b);\n        this.current.x = this.current.lineX = 0;\n        this.current.y = this.current.lineY = 0;\n    }\n    nextLine() {\n        this.moveText(0, this.current.leading);\n    }\n    paintChar(character, x, y, patternTransform) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const textRenderingMode = current.textRenderingMode;\n        const fontSize = current.fontSize / current.fontSizeScale;\n        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n        const patternFill = current.patternFill && !font.missingFile;\n        let addToPath;\n        if (font.disableFontFace || isAddToPathSet || patternFill) {\n            addToPath = font.getPathGenerator(this.commonObjs, character);\n        }\n        if (font.disableFontFace || patternFill) {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.beginPath();\n            addToPath(ctx, fontSize);\n            if (patternTransform) {\n                ctx.setTransform(...patternTransform);\n            }\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fill();\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.stroke();\n            }\n            ctx.restore();\n        } else {\n            if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.fillText(character, x, y);\n            }\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                ctx.strokeText(character, x, y);\n            }\n        }\n        if (isAddToPathSet) {\n            const paths = this.pendingTextPaths ||= [];\n            paths.push({\n                transform: getCurrentTransform(ctx),\n                x,\n                y,\n                fontSize,\n                addToPath\n            });\n        }\n    }\n    get isFontSubpixelAAEnabled() {\n        const { context: ctx } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n        ctx.scale(1.5, 1);\n        ctx.fillText(\"I\", 0, 10);\n        const data = ctx.getImageData(0, 0, 10, 10).data;\n        let enabled = false;\n        for(let i = 3; i < data.length; i += 4){\n            if (data[i] > 0 && data[i] < 255) {\n                enabled = true;\n                break;\n            }\n        }\n        return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n    }\n    showText(glyphs) {\n        const current = this.current;\n        const font = current.font;\n        if (font.isType3Font) {\n            return this.showType3Text(glyphs);\n        }\n        const fontSize = current.fontSize;\n        if (fontSize === 0) {\n            return undefined;\n        }\n        const ctx = this.ctx;\n        const fontSizeScale = current.fontSizeScale;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const fontDirection = current.fontDirection;\n        const textHScale = current.textHScale * fontDirection;\n        const glyphsLength = glyphs.length;\n        const vertical = font.vertical;\n        const spacingDir = vertical ? 1 : -1;\n        const defaultVMetrics = font.defaultVMetrics;\n        const widthAdvanceScale = fontSize * current.fontMatrix[0];\n        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n        ctx.save();\n        ctx.transform(...current.textMatrix);\n        ctx.translate(current.x, current.y + current.textRise);\n        if (fontDirection > 0) {\n            ctx.scale(textHScale, -1);\n        } else {\n            ctx.scale(textHScale, 1);\n        }\n        let patternTransform;\n        if (current.patternFill) {\n            ctx.save();\n            const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL);\n            patternTransform = getCurrentTransform(ctx);\n            ctx.restore();\n            ctx.fillStyle = pattern;\n        }\n        let lineWidth = current.lineWidth;\n        const scale = current.textMatrixScale;\n        if (scale === 0 || lineWidth === 0) {\n            const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n            if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n                lineWidth = this.getSinglePixelWidth();\n            }\n        } else {\n            lineWidth /= scale;\n        }\n        if (fontSizeScale !== 1.0) {\n            ctx.scale(fontSizeScale, fontSizeScale);\n            lineWidth /= fontSizeScale;\n        }\n        ctx.lineWidth = lineWidth;\n        if (font.isInvalidPDFjsFont) {\n            const chars = [];\n            let width = 0;\n            for (const glyph of glyphs){\n                chars.push(glyph.unicode);\n                width += glyph.width;\n            }\n            ctx.fillText(chars.join(\"\"), 0, 0);\n            current.x += width * widthAdvanceScale * textHScale;\n            ctx.restore();\n            this.compose();\n            return undefined;\n        }\n        let x = 0, i;\n        for(i = 0; i < glyphsLength; ++i){\n            const glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                x += spacingDir * glyph * fontSize / 1000;\n                continue;\n            }\n            let restoreNeeded = false;\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const character = glyph.fontChar;\n            const accent = glyph.accent;\n            let scaledX, scaledY;\n            let width = glyph.width;\n            if (vertical) {\n                const vmetric = glyph.vmetric || defaultVMetrics;\n                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n                const vy = vmetric[2] * widthAdvanceScale;\n                width = vmetric ? -vmetric[0] : width;\n                scaledX = vx / fontSizeScale;\n                scaledY = (x + vy) / fontSizeScale;\n            } else {\n                scaledX = x / fontSizeScale;\n                scaledY = 0;\n            }\n            if (font.remeasure && width > 0) {\n                const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n                    const characterScaleX = width / measuredWidth;\n                    restoreNeeded = true;\n                    ctx.save();\n                    ctx.scale(characterScaleX, 1);\n                    scaledX /= characterScaleX;\n                } else if (width !== measuredWidth) {\n                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n                }\n            }\n            if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n                if (simpleFillText && !accent) {\n                    ctx.fillText(character, scaledX, scaledY);\n                } else {\n                    this.paintChar(character, scaledX, scaledY, patternTransform);\n                    if (accent) {\n                        const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n                        const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n                        this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n                    }\n                }\n            }\n            const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n            x += charWidth;\n            if (restoreNeeded) {\n                ctx.restore();\n            }\n        }\n        if (vertical) {\n            current.y -= x;\n        } else {\n            current.x += x * textHScale;\n        }\n        ctx.restore();\n        this.compose();\n        return undefined;\n    }\n    showType3Text(glyphs) {\n        const ctx = this.ctx;\n        const current = this.current;\n        const font = current.font;\n        const fontSize = current.fontSize;\n        const fontDirection = current.fontDirection;\n        const spacingDir = font.vertical ? 1 : -1;\n        const charSpacing = current.charSpacing;\n        const wordSpacing = current.wordSpacing;\n        const textHScale = current.textHScale * fontDirection;\n        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n        const glyphsLength = glyphs.length;\n        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n        let i, glyph, width, spacingLength;\n        if (isTextInvisible || fontSize === 0) {\n            return;\n        }\n        this._cachedScaleForStroking[0] = -1;\n        this._cachedGetSinglePixelWidth = null;\n        ctx.save();\n        ctx.transform(...current.textMatrix);\n        ctx.translate(current.x, current.y);\n        ctx.scale(textHScale, fontDirection);\n        for(i = 0; i < glyphsLength; ++i){\n            glyph = glyphs[i];\n            if (typeof glyph === \"number\") {\n                spacingLength = spacingDir * glyph * fontSize / 1000;\n                this.ctx.translate(spacingLength, 0);\n                current.x += spacingLength * textHScale;\n                continue;\n            }\n            const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            const operatorList = font.charProcOperatorList[glyph.operatorListId];\n            if (!operatorList) {\n                warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n                continue;\n            }\n            if (this.contentVisible) {\n                this.processingType3 = glyph;\n                this.save();\n                ctx.scale(fontSize, fontSize);\n                ctx.transform(...fontMatrix);\n                this.executeOperatorList(operatorList);\n                this.restore();\n            }\n            const transformed = Util.applyTransform([\n                glyph.width,\n                0\n            ], fontMatrix);\n            width = transformed[0] * fontSize + spacing;\n            ctx.translate(width, 0);\n            current.x += width * textHScale;\n        }\n        ctx.restore();\n        this.processingType3 = null;\n    }\n    setCharWidth(xWidth, yWidth) {}\n    setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n        this.ctx.rect(llx, lly, urx - llx, ury - lly);\n        this.ctx.clip();\n        this.endPath();\n    }\n    getColorN_Pattern(IR) {\n        let pattern;\n        if (IR[0] === \"TilingPattern\") {\n            const color = IR[1];\n            const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n            const canvasGraphicsFactory = {\n                createCanvasGraphics: (ctx)=>new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n                        optionalContentConfig: this.optionalContentConfig,\n                        markedContentStack: this.markedContentStack\n                    })\n            };\n            pattern = new TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n        } else {\n            pattern = this._getPattern(IR[1], IR[2]);\n        }\n        return pattern;\n    }\n    setStrokeColorN() {\n        this.current.strokeColor = this.getColorN_Pattern(arguments);\n    }\n    setFillColorN() {\n        this.current.fillColor = this.getColorN_Pattern(arguments);\n        this.current.patternFill = true;\n    }\n    setStrokeRGBColor(r, g, b) {\n        this.ctx.strokeStyle = this.current.strokeColor = Util.makeHexColor(r, g, b);\n    }\n    setStrokeTransparent() {\n        this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n    }\n    setFillRGBColor(r, g, b) {\n        this.ctx.fillStyle = this.current.fillColor = Util.makeHexColor(r, g, b);\n        this.current.patternFill = false;\n    }\n    setFillTransparent() {\n        this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n        this.current.patternFill = false;\n    }\n    _getPattern(objId, matrix = null) {\n        let pattern;\n        if (this.cachedPatterns.has(objId)) {\n            pattern = this.cachedPatterns.get(objId);\n        } else {\n            pattern = getShadingPattern(this.getObject(objId));\n            this.cachedPatterns.set(objId, pattern);\n        }\n        if (matrix) {\n            pattern.matrix = matrix;\n        }\n        return pattern;\n    }\n    shadingFill(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        this.save();\n        const pattern = this._getPattern(objId);\n        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING);\n        const inv = getCurrentTransformInverse(ctx);\n        if (inv) {\n            const { width, height } = ctx.canvas;\n            const [x0, y0, x1, y1] = Util.getAxialAlignedBoundingBox([\n                0,\n                0,\n                width,\n                height\n            ], inv);\n            this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n        } else {\n            this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n        }\n        this.compose(this.current.getClippedPathBoundingBox());\n        this.restore();\n    }\n    beginInlineImage() {\n        unreachable(\"Should not call beginInlineImage\");\n    }\n    beginImageData() {\n        unreachable(\"Should not call beginImageData\");\n    }\n    paintFormXObjectBegin(matrix, bbox) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        this.baseTransformStack.push(this.baseTransform);\n        if (matrix) {\n            this.transform(...matrix);\n        }\n        this.baseTransform = getCurrentTransform(this.ctx);\n        if (bbox) {\n            const width = bbox[2] - bbox[0];\n            const height = bbox[3] - bbox[1];\n            this.ctx.rect(bbox[0], bbox[1], width, height);\n            this.current.updateRectMinMax(getCurrentTransform(this.ctx), bbox);\n            this.clip();\n            this.endPath();\n        }\n    }\n    paintFormXObjectEnd() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.restore();\n        this.baseTransform = this.baseTransformStack.pop();\n    }\n    beginGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.save();\n        if (this.inSMaskMode) {\n            this.endSMaskMode();\n            this.current.activeSMask = null;\n        }\n        const currentCtx = this.ctx;\n        if (!group.isolated) {\n            info(\"TODO: Support non-isolated groups.\");\n        }\n        if (group.knockout) {\n            warn(\"Knockout groups not supported.\");\n        }\n        const currentTransform = getCurrentTransform(currentCtx);\n        if (group.matrix) {\n            currentCtx.transform(...group.matrix);\n        }\n        if (!group.bbox) {\n            throw new Error(\"Bounding box is required.\");\n        }\n        let bounds = Util.getAxialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx));\n        const canvasBounds = [\n            0,\n            0,\n            currentCtx.canvas.width,\n            currentCtx.canvas.height\n        ];\n        bounds = Util.intersect(bounds, canvasBounds) || [\n            0,\n            0,\n            0,\n            0\n        ];\n        const offsetX = Math.floor(bounds[0]);\n        const offsetY = Math.floor(bounds[1]);\n        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n        this.current.startNewPathAndClipBox([\n            0,\n            0,\n            drawnWidth,\n            drawnHeight\n        ]);\n        let cacheId = \"groupAt\" + this.groupLevel;\n        if (group.smask) {\n            cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n        }\n        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n        const groupCtx = scratchCanvas.context;\n        groupCtx.translate(-offsetX, -offsetY);\n        groupCtx.transform(...currentTransform);\n        if (group.smask) {\n            this.smaskStack.push({\n                canvas: scratchCanvas.canvas,\n                context: groupCtx,\n                offsetX,\n                offsetY,\n                subtype: group.smask.subtype,\n                backdrop: group.smask.backdrop,\n                transferMap: group.smask.transferMap || null,\n                startTransformInverse: null\n            });\n        } else {\n            currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n            currentCtx.translate(offsetX, offsetY);\n            currentCtx.save();\n        }\n        copyCtxState(currentCtx, groupCtx);\n        this.ctx = groupCtx;\n        this.setGState([\n            [\n                \"BM\",\n                \"source-over\"\n            ],\n            [\n                \"ca\",\n                1\n            ],\n            [\n                \"CA\",\n                1\n            ]\n        ]);\n        this.groupStack.push(currentCtx);\n        this.groupLevel++;\n    }\n    endGroup(group) {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.groupLevel--;\n        const groupCtx = this.ctx;\n        const ctx = this.groupStack.pop();\n        this.ctx = ctx;\n        this.ctx.imageSmoothingEnabled = false;\n        if (group.smask) {\n            this.tempSMask = this.smaskStack.pop();\n            this.restore();\n        } else {\n            this.ctx.restore();\n            const currentMtx = getCurrentTransform(this.ctx);\n            this.restore();\n            this.ctx.save();\n            this.ctx.setTransform(...currentMtx);\n            const dirtyBox = Util.getAxialAlignedBoundingBox([\n                0,\n                0,\n                groupCtx.canvas.width,\n                groupCtx.canvas.height\n            ], currentMtx);\n            this.ctx.drawImage(groupCtx.canvas, 0, 0);\n            this.ctx.restore();\n            this.compose(dirtyBox);\n        }\n    }\n    beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n        this.#restoreInitialState();\n        resetCtxToDefault(this.ctx);\n        this.ctx.save();\n        this.save();\n        if (this.baseTransform) {\n            this.ctx.setTransform(...this.baseTransform);\n        }\n        if (rect) {\n            const width = rect[2] - rect[0];\n            const height = rect[3] - rect[1];\n            if (hasOwnCanvas && this.annotationCanvasMap) {\n                transform = transform.slice();\n                transform[4] -= rect[0];\n                transform[5] -= rect[1];\n                rect = rect.slice();\n                rect[0] = rect[1] = 0;\n                rect[2] = width;\n                rect[3] = height;\n                const [scaleX, scaleY] = Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx));\n                const { viewportScale } = this;\n                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n                const { canvas, context } = this.annotationCanvas;\n                this.annotationCanvasMap.set(id, canvas);\n                this.annotationCanvas.savedCtx = this.ctx;\n                this.ctx = context;\n                this.ctx.save();\n                this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n                resetCtxToDefault(this.ctx);\n            } else {\n                resetCtxToDefault(this.ctx);\n                this.endPath();\n                this.ctx.rect(rect[0], rect[1], width, height);\n                this.ctx.clip();\n                this.ctx.beginPath();\n            }\n        }\n        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n        this.transform(...transform);\n        this.transform(...matrix);\n    }\n    endAnnotation() {\n        if (this.annotationCanvas) {\n            this.ctx.restore();\n            this.#drawFilter();\n            this.ctx = this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas.savedCtx;\n            delete this.annotationCanvas;\n        }\n    }\n    paintImageMaskXObject(img) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const count = img.count;\n        img = this.getObject(img.data, img);\n        img.count = count;\n        const ctx = this.ctx;\n        const glyph = this.processingType3;\n        if (glyph) {\n            if (glyph.compiled === undefined) {\n                glyph.compiled = compileType3Glyph(img);\n            }\n            if (glyph.compiled) {\n                glyph.compiled(ctx);\n                return;\n            }\n        }\n        const mask = this._createMaskCanvas(img);\n        const maskCanvas = mask.canvas;\n        ctx.save();\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        img = this.getObject(img.data, img);\n        const ctx = this.ctx;\n        ctx.save();\n        const currentTransform = getCurrentTransform(ctx);\n        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n        const mask = this._createMaskCanvas(img);\n        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            const trans = Util.transform(currentTransform, [\n                scaleX,\n                skewX,\n                skewY,\n                scaleY,\n                positions[i],\n                positions[i + 1]\n            ]);\n            const [x, y] = Util.applyTransform([\n                0,\n                0\n            ], trans);\n            ctx.drawImage(mask.canvas, x, y);\n        }\n        ctx.restore();\n        this.compose();\n    }\n    paintImageMaskXObjectGroup(images) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        const fillColor = this.current.fillColor;\n        const isPatternFill = this.current.patternFill;\n        for (const image of images){\n            const { data, width, height, transform } = image;\n            const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n            const maskCtx = maskCanvas.context;\n            maskCtx.save();\n            const img = this.getObject(data, image);\n            putBinaryImageMask(maskCtx, img);\n            maskCtx.globalCompositeOperation = \"source-in\";\n            maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL) : fillColor;\n            maskCtx.fillRect(0, 0, width, height);\n            maskCtx.restore();\n            ctx.save();\n            ctx.transform(...transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintImageXObject(objId) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        this.paintInlineImageXObject(imgData);\n    }\n    paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const imgData = this.getObject(objId);\n        if (!imgData) {\n            warn(\"Dependent image isn't ready yet\");\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const map = [];\n        for(let i = 0, ii = positions.length; i < ii; i += 2){\n            map.push({\n                transform: [\n                    scaleX,\n                    0,\n                    0,\n                    scaleY,\n                    positions[i],\n                    positions[i + 1]\n                ],\n                x: 0,\n                y: 0,\n                w: width,\n                h: height\n            });\n        }\n        this.paintInlineImageXObjectGroup(imgData, map);\n    }\n    applyTransferMapsToCanvas(ctx) {\n        if (this.current.transferMaps !== \"none\") {\n            ctx.filter = this.current.transferMaps;\n            ctx.drawImage(ctx.canvas, 0, 0);\n            ctx.filter = \"none\";\n        }\n        return ctx.canvas;\n    }\n    applyTransferMapsToBitmap(imgData) {\n        if (this.current.transferMaps === \"none\") {\n            return imgData.bitmap;\n        }\n        const { bitmap, width, height } = imgData;\n        const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        const tmpCtx = tmpCanvas.context;\n        tmpCtx.filter = this.current.transferMaps;\n        tmpCtx.drawImage(bitmap, 0, 0);\n        tmpCtx.filter = \"none\";\n        return tmpCanvas.canvas;\n    }\n    paintInlineImageXObject(imgData) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const width = imgData.width;\n        const height = imgData.height;\n        const ctx = this.ctx;\n        this.save();\n        if (!isNodeJS) {\n            const { filter } = ctx;\n            if (filter !== \"none\" && filter !== \"\") {\n                ctx.filter = \"none\";\n            }\n        }\n        ctx.scale(1 / width, -1 / height);\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = this.applyTransferMapsToBitmap(imgData);\n        } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n            imgToPaint = imgData;\n        } else {\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n        this.compose();\n        this.restore();\n    }\n    paintInlineImageXObjectGroup(imgData, map) {\n        if (!this.contentVisible) {\n            return;\n        }\n        const ctx = this.ctx;\n        let imgToPaint;\n        if (imgData.bitmap) {\n            imgToPaint = imgData.bitmap;\n        } else {\n            const w = imgData.width;\n            const h = imgData.height;\n            const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n            const tmpCtx = tmpCanvas.context;\n            putBinaryImageData(tmpCtx, imgData);\n            imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n        }\n        for (const entry of map){\n            ctx.save();\n            ctx.transform(...entry.transform);\n            ctx.scale(1, -1);\n            drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n            ctx.restore();\n        }\n        this.compose();\n    }\n    paintSolidColorImageMask() {\n        if (!this.contentVisible) {\n            return;\n        }\n        this.ctx.fillRect(0, 0, 1, 1);\n        this.compose();\n    }\n    markPoint(tag) {}\n    markPointProps(tag, properties) {}\n    beginMarkedContent(tag) {\n        this.markedContentStack.push({\n            visible: true\n        });\n    }\n    beginMarkedContentProps(tag, properties) {\n        if (tag === \"OC\") {\n            this.markedContentStack.push({\n                visible: this.optionalContentConfig.isVisible(properties)\n            });\n        } else {\n            this.markedContentStack.push({\n                visible: true\n            });\n        }\n        this.contentVisible = this.isContentVisible();\n    }\n    endMarkedContent() {\n        this.markedContentStack.pop();\n        this.contentVisible = this.isContentVisible();\n    }\n    beginCompat() {}\n    endCompat() {}\n    consumePath(clipBox) {\n        const isEmpty = this.current.isEmptyClip();\n        if (this.pendingClip) {\n            this.current.updateClipFromPath();\n        }\n        if (!this.pendingClip) {\n            this.compose(clipBox);\n        }\n        const ctx = this.ctx;\n        if (this.pendingClip) {\n            if (!isEmpty) {\n                if (this.pendingClip === EO_CLIP) {\n                    ctx.clip(\"evenodd\");\n                } else {\n                    ctx.clip();\n                }\n            }\n            this.pendingClip = null;\n        }\n        this.current.startNewPathAndClipBox(this.current.clipBox);\n        ctx.beginPath();\n    }\n    getSinglePixelWidth() {\n        if (!this._cachedGetSinglePixelWidth) {\n            const m = getCurrentTransform(this.ctx);\n            if (m[1] === 0 && m[2] === 0) {\n                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n            } else {\n                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n                const normX = Math.hypot(m[0], m[2]);\n                const normY = Math.hypot(m[1], m[3]);\n                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n            }\n        }\n        return this._cachedGetSinglePixelWidth;\n    }\n    getScaleForStroking() {\n        if (this._cachedScaleForStroking[0] === -1) {\n            const { lineWidth } = this.current;\n            const { a, b, c, d } = this.ctx.getTransform();\n            let scaleX, scaleY;\n            if (b === 0 && c === 0) {\n                const normX = Math.abs(a);\n                const normY = Math.abs(d);\n                if (normX === normY) {\n                    if (lineWidth === 0) {\n                        scaleX = scaleY = 1 / normX;\n                    } else {\n                        const scaledLineWidth = normX * lineWidth;\n                        scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n                    }\n                } else if (lineWidth === 0) {\n                    scaleX = 1 / normX;\n                    scaleY = 1 / normY;\n                } else {\n                    const scaledXLineWidth = normX * lineWidth;\n                    const scaledYLineWidth = normY * lineWidth;\n                    scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n                    scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n                }\n            } else {\n                const absDet = Math.abs(a * d - b * c);\n                const normX = Math.hypot(a, b);\n                const normY = Math.hypot(c, d);\n                if (lineWidth === 0) {\n                    scaleX = normY / absDet;\n                    scaleY = normX / absDet;\n                } else {\n                    const baseArea = lineWidth * absDet;\n                    scaleX = normY > baseArea ? normY / baseArea : 1;\n                    scaleY = normX > baseArea ? normX / baseArea : 1;\n                }\n            }\n            this._cachedScaleForStroking[0] = scaleX;\n            this._cachedScaleForStroking[1] = scaleY;\n        }\n        return this._cachedScaleForStroking;\n    }\n    rescaleAndStroke(saveRestore) {\n        const { ctx } = this;\n        const { lineWidth } = this.current;\n        const [scaleX, scaleY] = this.getScaleForStroking();\n        ctx.lineWidth = lineWidth || 1;\n        if (scaleX === 1 && scaleY === 1) {\n            ctx.stroke();\n            return;\n        }\n        const dashes = ctx.getLineDash();\n        if (saveRestore) {\n            ctx.save();\n        }\n        ctx.scale(scaleX, scaleY);\n        if (dashes.length > 0) {\n            const scale = Math.max(scaleX, scaleY);\n            ctx.setLineDash(dashes.map((x)=>x / scale));\n            ctx.lineDashOffset /= scale;\n        }\n        ctx.stroke();\n        if (saveRestore) {\n            ctx.restore();\n        }\n    }\n    isContentVisible() {\n        for(let i = this.markedContentStack.length - 1; i >= 0; i--){\n            if (!this.markedContentStack[i].visible) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nfor(const op in OPS){\n    if (CanvasGraphics.prototype[op] !== undefined) {\n        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n    }\n}\n; // ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n    static #port = null;\n    static #src = \"\";\n    static get workerPort() {\n        return this.#port;\n    }\n    static set workerPort(val) {\n        if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n            throw new Error(\"Invalid `workerPort` type.\");\n        }\n        this.#port = val;\n    }\n    static get workerSrc() {\n        return this.#src;\n    }\n    static set workerSrc(val) {\n        if (typeof val !== \"string\") {\n            throw new Error(\"Invalid `workerSrc` type.\");\n        }\n        this.#src = val;\n    }\n}\n; // ./src/shared/message_handler.js\nconst CallbackKind = {\n    UNKNOWN: 0,\n    DATA: 1,\n    ERROR: 2\n};\nconst StreamKind = {\n    UNKNOWN: 0,\n    CANCEL: 1,\n    CANCEL_COMPLETE: 2,\n    CLOSE: 3,\n    ENQUEUE: 4,\n    ERROR: 5,\n    PULL: 6,\n    PULL_COMPLETE: 7,\n    START_COMPLETE: 8\n};\nfunction wrapReason(reason) {\n    if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n        unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n    }\n    switch(reason.name){\n        case \"AbortException\":\n            return new AbortException(reason.message);\n        case \"MissingPDFException\":\n            return new MissingPDFException(reason.message);\n        case \"PasswordException\":\n            return new PasswordException(reason.message, reason.code);\n        case \"UnexpectedResponseException\":\n            return new UnexpectedResponseException(reason.message, reason.status);\n        case \"UnknownErrorException\":\n            return new UnknownErrorException(reason.message, reason.details);\n        default:\n            return new UnknownErrorException(reason.message, reason.toString());\n    }\n}\nclass MessageHandler {\n    #messageAC;\n    constructor(sourceName, targetName, comObj){\n        this.#messageAC = new AbortController();\n        this.sourceName = sourceName;\n        this.targetName = targetName;\n        this.comObj = comObj;\n        this.callbackId = 1;\n        this.streamId = 1;\n        this.streamSinks = Object.create(null);\n        this.streamControllers = Object.create(null);\n        this.callbackCapabilities = Object.create(null);\n        this.actionHandler = Object.create(null);\n        comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n            signal: this.#messageAC.signal\n        });\n    }\n    #onMessage({ data }) {\n        if (data.targetName !== this.sourceName) {\n            return;\n        }\n        if (data.stream) {\n            this.#processStreamMessage(data);\n            return;\n        }\n        if (data.callback) {\n            const callbackId = data.callbackId;\n            const capability = this.callbackCapabilities[callbackId];\n            if (!capability) {\n                throw new Error(`Cannot resolve callback ${callbackId}`);\n            }\n            delete this.callbackCapabilities[callbackId];\n            if (data.callback === CallbackKind.DATA) {\n                capability.resolve(data.data);\n            } else if (data.callback === CallbackKind.ERROR) {\n                capability.reject(wrapReason(data.reason));\n            } else {\n                throw new Error(\"Unexpected callback case\");\n            }\n            return;\n        }\n        const action = this.actionHandler[data.action];\n        if (!action) {\n            throw new Error(`Unknown action from worker: ${data.action}`);\n        }\n        if (data.callbackId) {\n            const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n            new Promise(function(resolve) {\n                resolve(action(data.data));\n            }).then(function(result) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.DATA,\n                    callbackId: data.callbackId,\n                    data: result\n                });\n            }, function(reason) {\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    callback: CallbackKind.ERROR,\n                    callbackId: data.callbackId,\n                    reason: wrapReason(reason)\n                });\n            });\n            return;\n        }\n        if (data.streamId) {\n            this.#createStreamSink(data);\n            return;\n        }\n        action(data.data);\n    }\n    on(actionName, handler) {\n        const ah = this.actionHandler;\n        if (ah[actionName]) {\n            throw new Error(`There is already an actionName called \"${actionName}\"`);\n        }\n        ah[actionName] = handler;\n    }\n    send(actionName, data, transfers) {\n        this.comObj.postMessage({\n            sourceName: this.sourceName,\n            targetName: this.targetName,\n            action: actionName,\n            data\n        }, transfers);\n    }\n    sendWithPromise(actionName, data, transfers) {\n        const callbackId = this.callbackId++;\n        const capability = Promise.withResolvers();\n        this.callbackCapabilities[callbackId] = capability;\n        try {\n            this.comObj.postMessage({\n                sourceName: this.sourceName,\n                targetName: this.targetName,\n                action: actionName,\n                callbackId,\n                data\n            }, transfers);\n        } catch (ex) {\n            capability.reject(ex);\n        }\n        return capability.promise;\n    }\n    sendWithStream(actionName, data, queueingStrategy, transfers) {\n        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;\n        return new ReadableStream({\n            start: (controller)=>{\n                const startCapability = Promise.withResolvers();\n                this.streamControllers[streamId] = {\n                    controller,\n                    startCall: startCapability,\n                    pullCall: null,\n                    cancelCall: null,\n                    isClosed: false\n                };\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    action: actionName,\n                    streamId,\n                    data,\n                    desiredSize: controller.desiredSize\n                }, transfers);\n                return startCapability.promise;\n            },\n            pull: (controller)=>{\n                const pullCapability = Promise.withResolvers();\n                this.streamControllers[streamId].pullCall = pullCapability;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.PULL,\n                    streamId,\n                    desiredSize: controller.desiredSize\n                });\n                return pullCapability.promise;\n            },\n            cancel: (reason)=>{\n                assert(reason instanceof Error, \"cancel must have a valid reason\");\n                const cancelCapability = Promise.withResolvers();\n                this.streamControllers[streamId].cancelCall = cancelCapability;\n                this.streamControllers[streamId].isClosed = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CANCEL,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n                return cancelCapability.promise;\n            }\n        }, queueingStrategy);\n    }\n    #createStreamSink(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const self = this, action = this.actionHandler[data.action];\n        const streamSink = {\n            enqueue (chunk, size = 1, transfers) {\n                if (this.isCancelled) {\n                    return;\n                }\n                const lastDesiredSize = this.desiredSize;\n                this.desiredSize -= size;\n                if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n                    this.sinkCapability = Promise.withResolvers();\n                    this.ready = this.sinkCapability.promise;\n                }\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ENQUEUE,\n                    streamId,\n                    chunk\n                }, transfers);\n            },\n            close () {\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.CLOSE,\n                    streamId\n                });\n                delete self.streamSinks[streamId];\n            },\n            error (reason) {\n                assert(reason instanceof Error, \"error must have a valid reason\");\n                if (this.isCancelled) {\n                    return;\n                }\n                this.isCancelled = true;\n                comObj.postMessage({\n                    sourceName,\n                    targetName,\n                    stream: StreamKind.ERROR,\n                    streamId,\n                    reason: wrapReason(reason)\n                });\n            },\n            sinkCapability: Promise.withResolvers(),\n            onPull: null,\n            onCancel: null,\n            isCancelled: false,\n            desiredSize: data.desiredSize,\n            ready: null\n        };\n        streamSink.sinkCapability.resolve();\n        streamSink.ready = streamSink.sinkCapability.promise;\n        this.streamSinks[streamId] = streamSink;\n        new Promise(function(resolve) {\n            resolve(action(data.data, streamSink));\n        }).then(function() {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                success: true\n            });\n        }, function(reason) {\n            comObj.postMessage({\n                sourceName,\n                targetName,\n                stream: StreamKind.START_COMPLETE,\n                streamId,\n                reason: wrapReason(reason)\n            });\n        });\n    }\n    #processStreamMessage(data) {\n        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;\n        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];\n        switch(data.stream){\n            case StreamKind.START_COMPLETE:\n                if (data.success) {\n                    streamController.startCall.resolve();\n                } else {\n                    streamController.startCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL_COMPLETE:\n                if (data.success) {\n                    streamController.pullCall.resolve();\n                } else {\n                    streamController.pullCall.reject(wrapReason(data.reason));\n                }\n                break;\n            case StreamKind.PULL:\n                if (!streamSink) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                    break;\n                }\n                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n                    streamSink.sinkCapability.resolve();\n                }\n                streamSink.desiredSize = data.desiredSize;\n                new Promise(function(resolve) {\n                    resolve(streamSink.onPull?.());\n                }).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.PULL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                break;\n            case StreamKind.ENQUEUE:\n                assert(streamController, \"enqueue should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.controller.enqueue(data.chunk);\n                break;\n            case StreamKind.CLOSE:\n                assert(streamController, \"close should have stream controller\");\n                if (streamController.isClosed) {\n                    break;\n                }\n                streamController.isClosed = true;\n                streamController.controller.close();\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.ERROR:\n                assert(streamController, \"error should have stream controller\");\n                streamController.controller.error(wrapReason(data.reason));\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL_COMPLETE:\n                if (data.success) {\n                    streamController.cancelCall.resolve();\n                } else {\n                    streamController.cancelCall.reject(wrapReason(data.reason));\n                }\n                this.#deleteStreamController(streamController, streamId);\n                break;\n            case StreamKind.CANCEL:\n                if (!streamSink) {\n                    break;\n                }\n                new Promise(function(resolve) {\n                    resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n                }).then(function() {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        success: true\n                    });\n                }, function(reason) {\n                    comObj.postMessage({\n                        sourceName,\n                        targetName,\n                        stream: StreamKind.CANCEL_COMPLETE,\n                        streamId,\n                        reason: wrapReason(reason)\n                    });\n                });\n                streamSink.sinkCapability.reject(wrapReason(data.reason));\n                streamSink.isCancelled = true;\n                delete this.streamSinks[streamId];\n                break;\n            default:\n                throw new Error(\"Unexpected stream case\");\n        }\n    }\n    async #deleteStreamController(streamController, streamId) {\n        await Promise.allSettled([\n            streamController.startCall?.promise,\n            streamController.pullCall?.promise,\n            streamController.cancelCall?.promise\n        ]);\n        delete this.streamControllers[streamId];\n    }\n    destroy() {\n        this.#messageAC?.abort();\n        this.#messageAC = null;\n    }\n}\n; // ./src/display/metadata.js\nclass Metadata {\n    #metadataMap;\n    #data;\n    constructor({ parsedData, rawData }){\n        this.#metadataMap = parsedData;\n        this.#data = rawData;\n    }\n    getRaw() {\n        return this.#data;\n    }\n    get(name) {\n        return this.#metadataMap.get(name) ?? null;\n    }\n    getAll() {\n        return objectFromMap(this.#metadataMap);\n    }\n    has(name) {\n        return this.#metadataMap.has(name);\n    }\n}\n; // ./src/display/optional_content_config.js\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n    #isDisplay;\n    #isPrint;\n    #userSet;\n    #visible;\n    constructor(renderingIntent, { name, intent, usage, rbGroups }){\n        this.#isDisplay = false;\n        this.#isPrint = false;\n        this.#userSet = false;\n        this.#visible = true;\n        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        this.name = name;\n        this.intent = intent;\n        this.usage = usage;\n        this.rbGroups = rbGroups;\n    }\n    get visible() {\n        if (this.#userSet) {\n            return this.#visible;\n        }\n        if (!this.#visible) {\n            return false;\n        }\n        const { print, view } = this.usage;\n        if (this.#isDisplay) {\n            return view?.viewState !== \"OFF\";\n        } else if (this.#isPrint) {\n            return print?.printState !== \"OFF\";\n        }\n        return true;\n    }\n    _setVisible(internal, visible, userSet = false) {\n        if (internal !== INTERNAL) {\n            unreachable(\"Internal method `_setVisible` called.\");\n        }\n        this.#userSet = userSet;\n        this.#visible = visible;\n    }\n}\nclass OptionalContentConfig {\n    #cachedGetHash;\n    #groups;\n    #initialHash;\n    #order;\n    constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY){\n        this.#cachedGetHash = null;\n        this.#groups = new Map();\n        this.#initialHash = null;\n        this.#order = null;\n        this.renderingIntent = renderingIntent;\n        this.name = null;\n        this.creator = null;\n        if (data === null) {\n            return;\n        }\n        this.name = data.name;\n        this.creator = data.creator;\n        this.#order = data.order;\n        for (const group of data.groups){\n            this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n        }\n        if (data.baseState === \"OFF\") {\n            for (const group of this.#groups.values()){\n                group._setVisible(INTERNAL, false);\n            }\n        }\n        for (const on of data.on){\n            this.#groups.get(on)._setVisible(INTERNAL, true);\n        }\n        for (const off of data.off){\n            this.#groups.get(off)._setVisible(INTERNAL, false);\n        }\n        this.#initialHash = this.getHash();\n    }\n    #evaluateVisibilityExpression(array) {\n        const length = array.length;\n        if (length < 2) {\n            return true;\n        }\n        const operator = array[0];\n        for(let i = 1; i < length; i++){\n            const element = array[i];\n            let state;\n            if (Array.isArray(element)) {\n                state = this.#evaluateVisibilityExpression(element);\n            } else if (this.#groups.has(element)) {\n                state = this.#groups.get(element).visible;\n            } else {\n                warn(`Optional content group not found: ${element}`);\n                return true;\n            }\n            switch(operator){\n                case \"And\":\n                    if (!state) {\n                        return false;\n                    }\n                    break;\n                case \"Or\":\n                    if (state) {\n                        return true;\n                    }\n                    break;\n                case \"Not\":\n                    return !state;\n                default:\n                    return true;\n            }\n        }\n        return operator === \"And\";\n    }\n    isVisible(group) {\n        if (this.#groups.size === 0) {\n            return true;\n        }\n        if (!group) {\n            info(\"Optional content group not defined.\");\n            return true;\n        }\n        if (group.type === \"OCG\") {\n            if (!this.#groups.has(group.id)) {\n                warn(`Optional content group not found: ${group.id}`);\n                return true;\n            }\n            return this.#groups.get(group.id).visible;\n        } else if (group.type === \"OCMD\") {\n            if (group.expression) {\n                return this.#evaluateVisibilityExpression(group.expression);\n            }\n            if (!group.policy || group.policy === \"AnyOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOn\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            } else if (group.policy === \"AnyOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (!this.#groups.get(id).visible) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (group.policy === \"AllOff\") {\n                for (const id of group.ids){\n                    if (!this.#groups.has(id)) {\n                        warn(`Optional content group not found: ${id}`);\n                        return true;\n                    }\n                    if (this.#groups.get(id).visible) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            warn(`Unknown optional content policy ${group.policy}.`);\n            return true;\n        }\n        warn(`Unknown group type ${group.type}.`);\n        return true;\n    }\n    setVisibility(id, visible = true, preserveRB = true) {\n        const group = this.#groups.get(id);\n        if (!group) {\n            warn(`Optional content group not found: ${id}`);\n            return;\n        }\n        if (preserveRB && visible && group.rbGroups.length) {\n            for (const rbGroup of group.rbGroups){\n                for (const otherId of rbGroup){\n                    if (otherId !== id) {\n                        this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n                    }\n                }\n            }\n        }\n        group._setVisible(INTERNAL, !!visible, true);\n        this.#cachedGetHash = null;\n    }\n    setOCGState({ state, preserveRB }) {\n        let operator;\n        for (const elem of state){\n            switch(elem){\n                case \"ON\":\n                case \"OFF\":\n                case \"Toggle\":\n                    operator = elem;\n                    continue;\n            }\n            const group = this.#groups.get(elem);\n            if (!group) {\n                continue;\n            }\n            switch(operator){\n                case \"ON\":\n                    this.setVisibility(elem, true, preserveRB);\n                    break;\n                case \"OFF\":\n                    this.setVisibility(elem, false, preserveRB);\n                    break;\n                case \"Toggle\":\n                    this.setVisibility(elem, !group.visible, preserveRB);\n                    break;\n            }\n        }\n        this.#cachedGetHash = null;\n    }\n    get hasInitialVisibility() {\n        return this.#initialHash === null || this.getHash() === this.#initialHash;\n    }\n    getOrder() {\n        if (!this.#groups.size) {\n            return null;\n        }\n        if (this.#order) {\n            return this.#order.slice();\n        }\n        return [\n            ...this.#groups.keys()\n        ];\n    }\n    getGroups() {\n        return this.#groups.size > 0 ? objectFromMap(this.#groups) : null;\n    }\n    getGroup(id) {\n        return this.#groups.get(id) || null;\n    }\n    getHash() {\n        if (this.#cachedGetHash !== null) {\n            return this.#cachedGetHash;\n        }\n        const hash = new MurmurHash3_64();\n        for (const [id, group] of this.#groups){\n            hash.update(`${id}:${group.visible}`);\n        }\n        return this.#cachedGetHash = hash.hexdigest();\n    }\n}\n; // ./src/display/transport_stream.js\nclass PDFDataTransportStream {\n    constructor(pdfDataRangeTransport, { disableRange = false, disableStream = false }){\n        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n        const { length, initialData, progressiveDone, contentDispositionFilename } = pdfDataRangeTransport;\n        this._queuedChunks = [];\n        this._progressiveDone = progressiveDone;\n        this._contentDispositionFilename = contentDispositionFilename;\n        if (initialData?.length > 0) {\n            const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n            this._queuedChunks.push(buffer);\n        }\n        this._pdfDataRangeTransport = pdfDataRangeTransport;\n        this._isStreamingSupported = !disableStream;\n        this._isRangeSupported = !disableRange;\n        this._contentLength = length;\n        this._fullRequestReader = null;\n        this._rangeReaders = [];\n        pdfDataRangeTransport.addRangeListener((begin, chunk)=>{\n            this._onReceiveData({\n                begin,\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressListener((loaded, total)=>{\n            this._onProgress({\n                loaded,\n                total\n            });\n        });\n        pdfDataRangeTransport.addProgressiveReadListener((chunk)=>{\n            this._onReceiveData({\n                chunk\n            });\n        });\n        pdfDataRangeTransport.addProgressiveDoneListener(()=>{\n            this._onProgressiveDone();\n        });\n        pdfDataRangeTransport.transportReady();\n    }\n    _onReceiveData({ begin, chunk }) {\n        const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n        if (begin === undefined) {\n            if (this._fullRequestReader) {\n                this._fullRequestReader._enqueue(buffer);\n            } else {\n                this._queuedChunks.push(buffer);\n            }\n        } else {\n            const found = this._rangeReaders.some(function(rangeReader) {\n                if (rangeReader._begin !== begin) {\n                    return false;\n                }\n                rangeReader._enqueue(buffer);\n                return true;\n            });\n            assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n        }\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    _onProgress(evt) {\n        if (evt.total === undefined) {\n            this._rangeReaders[0]?.onProgress?.({\n                loaded: evt.loaded\n            });\n        } else {\n            this._fullRequestReader?.onProgress?.({\n                loaded: evt.loaded,\n                total: evt.total\n            });\n        }\n    }\n    _onProgressiveDone() {\n        this._fullRequestReader?.progressiveDone();\n        this._progressiveDone = true;\n    }\n    _removeRangeReader(reader) {\n        const i = this._rangeReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n        const queuedChunks = this._queuedChunks;\n        this._queuedChunks = null;\n        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n        this._pdfDataRangeTransport.requestDataRange(begin, end);\n        this._rangeReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeReaders.slice(0)){\n            reader.cancel(reason);\n        }\n        this._pdfDataRangeTransport.abort();\n    }\n}\nclass PDFDataTransportStreamReader {\n    constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null){\n        this._stream = stream;\n        this._done = progressiveDone || false;\n        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n        this._queuedChunks = queuedChunks || [];\n        this._loaded = 0;\n        for (const chunk of this._queuedChunks){\n            this._loaded += chunk.byteLength;\n        }\n        this._requests = [];\n        this._headersReady = Promise.resolve();\n        stream._fullRequestReader = this;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunks.push(chunk);\n        }\n        this._loaded += chunk.byteLength;\n    }\n    get headersReady() {\n        return this._headersReady;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._stream._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._stream._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._stream._contentLength;\n    }\n    async read() {\n        if (this._queuedChunks.length > 0) {\n            const chunk = this._queuedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    progressiveDone() {\n        if (this._done) {\n            return;\n        }\n        this._done = true;\n    }\n}\nclass PDFDataTransportStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._begin = begin;\n        this._end = end;\n        this._queuedChunk = null;\n        this._requests = [];\n        this._done = false;\n        this.onProgress = null;\n    }\n    _enqueue(chunk) {\n        if (this._done) {\n            return;\n        }\n        if (this._requests.length === 0) {\n            this._queuedChunk = chunk;\n        } else {\n            const requestsCapability = this._requests.shift();\n            requestsCapability.resolve({\n                value: chunk,\n                done: false\n            });\n            for (const requestCapability of this._requests){\n                requestCapability.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            this._requests.length = 0;\n        }\n        this._done = true;\n        this._stream._removeRangeReader(this);\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._queuedChunk) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._stream._removeRangeReader(this);\n    }\n}\n; // ./src/display/content_disposition.js\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n    let needsEncodingFixup = true;\n    let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = unescape(filename);\n        filename = rfc5987decode(filename);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    tmp = rfc2231getparam(contentDisposition);\n    if (tmp) {\n        const filename = rfc2047decode(tmp);\n        return fixupEncoding(filename);\n    }\n    tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n    if (tmp) {\n        tmp = tmp[1];\n        let filename = rfc2616unquote(tmp);\n        filename = rfc2047decode(filename);\n        return fixupEncoding(filename);\n    }\n    function toParamRegExp(attributePattern, flags) {\n        return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n    }\n    function textdecode(encoding, value) {\n        if (encoding) {\n            if (!/^[\\x00-\\xFF]+$/.test(value)) {\n                return value;\n            }\n            try {\n                const decoder = new TextDecoder(encoding, {\n                    fatal: true\n                });\n                const buffer = stringToBytes(value);\n                value = decoder.decode(buffer);\n                needsEncodingFixup = false;\n            } catch  {}\n        }\n        return value;\n    }\n    function fixupEncoding(value) {\n        if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n            value = textdecode(\"utf-8\", value);\n            if (needsEncodingFixup) {\n                value = textdecode(\"iso-8859-1\", value);\n            }\n        }\n        return value;\n    }\n    function rfc2231getparam(contentDispositionStr) {\n        const matches = [];\n        let match;\n        const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n        while((match = iter.exec(contentDispositionStr)) !== null){\n            let [, n, quot, part] = match;\n            n = parseInt(n, 10);\n            if (n in matches) {\n                if (n === 0) {\n                    break;\n                }\n                continue;\n            }\n            matches[n] = [\n                quot,\n                part\n            ];\n        }\n        const parts = [];\n        for(let n = 0; n < matches.length; ++n){\n            if (!(n in matches)) {\n                break;\n            }\n            let [quot, part] = matches[n];\n            part = rfc2616unquote(part);\n            if (quot) {\n                part = unescape(part);\n                if (n === 0) {\n                    part = rfc5987decode(part);\n                }\n            }\n            parts.push(part);\n        }\n        return parts.join(\"\");\n    }\n    function rfc2616unquote(value) {\n        if (value.startsWith('\"')) {\n            const parts = value.slice(1).split('\\\\\"');\n            for(let i = 0; i < parts.length; ++i){\n                const quotindex = parts[i].indexOf('\"');\n                if (quotindex !== -1) {\n                    parts[i] = parts[i].slice(0, quotindex);\n                    parts.length = i + 1;\n                }\n                parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n            }\n            value = parts.join('\"');\n        }\n        return value;\n    }\n    function rfc5987decode(extvalue) {\n        const encodingend = extvalue.indexOf(\"'\");\n        if (encodingend === -1) {\n            return extvalue;\n        }\n        const encoding = extvalue.slice(0, encodingend);\n        const langvalue = extvalue.slice(encodingend + 1);\n        const value = langvalue.replace(/^[^']*'/, \"\");\n        return textdecode(encoding, value);\n    }\n    function rfc2047decode(value) {\n        if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n            return value;\n        }\n        return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function(matches, charset, encoding, text) {\n            if (encoding === \"q\" || encoding === \"Q\") {\n                text = text.replaceAll(\"_\", \" \");\n                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {\n                    return String.fromCharCode(parseInt(hex, 16));\n                });\n                return textdecode(charset, text);\n            }\n            try {\n                text = atob(text);\n            } catch  {}\n            return textdecode(charset, text);\n        });\n    }\n    return \"\";\n}\n; // ./src/display/network_utils.js\nfunction createHeaders(isHttp, httpHeaders) {\n    const headers = new Headers();\n    if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n        return headers;\n    }\n    for(const key in httpHeaders){\n        const val = httpHeaders[key];\n        if (val !== undefined) {\n            headers.append(key, val);\n        }\n    }\n    return headers;\n}\nfunction validateRangeRequestCapabilities({ responseHeaders, isHttp, rangeChunkSize, disableRange }) {\n    const returnValues = {\n        allowRangeRequests: false,\n        suggestedLength: undefined\n    };\n    const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n    if (!Number.isInteger(length)) {\n        return returnValues;\n    }\n    returnValues.suggestedLength = length;\n    if (length <= 2 * rangeChunkSize) {\n        return returnValues;\n    }\n    if (disableRange || !isHttp) {\n        return returnValues;\n    }\n    if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n        return returnValues;\n    }\n    const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n    if (contentEncoding !== \"identity\") {\n        return returnValues;\n    }\n    returnValues.allowRangeRequests = true;\n    return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n    const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n    if (contentDisposition) {\n        let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n        if (filename.includes(\"%\")) {\n            try {\n                filename = decodeURIComponent(filename);\n            } catch  {}\n        }\n        if (isPdfFile(filename)) {\n            return filename;\n        }\n    }\n    return null;\n}\nfunction createResponseStatusError(status, url) {\n    if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n        return new MissingPDFException('Missing PDF \"' + url + '\".');\n    }\n    return new UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\nfunction validateResponseStatus(status) {\n    return status === 200 || status === 206;\n}\n; // ./src/display/fetch_stream.js\nfunction createFetchOptions(headers, withCredentials, abortController) {\n    return {\n        method: \"GET\",\n        headers,\n        signal: abortController.signal,\n        mode: \"cors\",\n        credentials: withCredentials ? \"include\" : \"same-origin\",\n        redirect: \"follow\"\n    };\n}\nfunction getArrayBuffer(val) {\n    if (val instanceof Uint8Array) {\n        return val.buffer;\n    }\n    if (val instanceof ArrayBuffer) {\n        return val;\n    }\n    warn(`getArrayBuffer - unexpected data format: ${val}`);\n    return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n    constructor(source){\n        this.source = source;\n        this.isHttp = /^https?:/i.test(source.url);\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFFetchStreamReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const reader = new PDFFetchStreamRangeReader(this, begin, end);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFFetchStreamReader {\n    constructor(stream){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        this._filename = null;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._contentLength = source.length;\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._abortController = new AbortController();\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        const headers = new Headers(stream.headers);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseStatusError(response.status, url);\n            }\n            this._reader = response.body.getReader();\n            this._headersCapability.resolve();\n            const responseHeaders = response.headers;\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n            if (!this._isStreamingSupported && this._isRangeSupported) {\n                this.cancel(new AbortException(\"Streaming is disabled.\"));\n            }\n        }).catch(this._headersCapability.reject);\n        this.onProgress = null;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._headersCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\nclass PDFFetchStreamRangeReader {\n    constructor(stream, begin, end){\n        this._stream = stream;\n        this._reader = null;\n        this._loaded = 0;\n        const source = stream.source;\n        this._withCredentials = source.withCredentials || false;\n        this._readCapability = Promise.withResolvers();\n        this._isStreamingSupported = !source.disableStream;\n        this._abortController = new AbortController();\n        const headers = new Headers(stream.headers);\n        headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n        const url = source.url;\n        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response)=>{\n            if (!validateResponseStatus(response.status)) {\n                throw createResponseStatusError(response.status, url);\n            }\n            this._readCapability.resolve();\n            this._reader = response.body.getReader();\n        }).catch(this._readCapability.reject);\n        this.onProgress = null;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        const { value, done } = await this._reader.read();\n        if (done) {\n            return {\n                value,\n                done\n            };\n        }\n        this._loaded += value.byteLength;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        return {\n            value: getArrayBuffer(value),\n            done: false\n        };\n    }\n    cancel(reason) {\n        this._reader?.cancel(reason);\n        this._abortController.abort();\n    }\n}\n; // ./src/display/network.js\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n    const data = xhr.response;\n    if (typeof data !== \"string\") {\n        return data;\n    }\n    return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n    constructor({ url, httpHeaders, withCredentials }){\n        this.url = url;\n        this.isHttp = /^https?:/i.test(url);\n        this.headers = createHeaders(this.isHttp, httpHeaders);\n        this.withCredentials = withCredentials || false;\n        this.currXhrId = 0;\n        this.pendingRequests = Object.create(null);\n    }\n    requestRange(begin, end, listeners) {\n        const args = {\n            begin,\n            end\n        };\n        for(const prop in listeners){\n            args[prop] = listeners[prop];\n        }\n        return this.request(args);\n    }\n    requestFull(listeners) {\n        return this.request(listeners);\n    }\n    request(args) {\n        const xhr = new XMLHttpRequest();\n        const xhrId = this.currXhrId++;\n        const pendingRequest = this.pendingRequests[xhrId] = {\n            xhr\n        };\n        xhr.open(\"GET\", this.url);\n        xhr.withCredentials = this.withCredentials;\n        for (const [key, val] of this.headers){\n            xhr.setRequestHeader(key, val);\n        }\n        if (this.isHttp && \"begin\" in args && \"end\" in args) {\n            xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n            pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n        } else {\n            pendingRequest.expectedStatus = OK_RESPONSE;\n        }\n        xhr.responseType = \"arraybuffer\";\n        if (args.onError) {\n            xhr.onerror = function(evt) {\n                args.onError(xhr.status);\n            };\n        }\n        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n        xhr.onprogress = this.onProgress.bind(this, xhrId);\n        pendingRequest.onHeadersReceived = args.onHeadersReceived;\n        pendingRequest.onDone = args.onDone;\n        pendingRequest.onError = args.onError;\n        pendingRequest.onProgress = args.onProgress;\n        xhr.send(null);\n        return xhrId;\n    }\n    onProgress(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        pendingRequest.onProgress?.(evt);\n    }\n    onStateChange(xhrId, evt) {\n        const pendingRequest = this.pendingRequests[xhrId];\n        if (!pendingRequest) {\n            return;\n        }\n        const xhr = pendingRequest.xhr;\n        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n            pendingRequest.onHeadersReceived();\n            delete pendingRequest.onHeadersReceived;\n        }\n        if (xhr.readyState !== 4) {\n            return;\n        }\n        if (!(xhrId in this.pendingRequests)) {\n            return;\n        }\n        delete this.pendingRequests[xhrId];\n        if (xhr.status === 0 && this.isHttp) {\n            pendingRequest.onError?.(xhr.status);\n            return;\n        }\n        const xhrStatus = xhr.status || OK_RESPONSE;\n        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n            pendingRequest.onError?.(xhr.status);\n            return;\n        }\n        const chunk = network_getArrayBuffer(xhr);\n        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n            const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n            const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n            pendingRequest.onDone({\n                begin: parseInt(matches[1], 10),\n                chunk\n            });\n        } else if (chunk) {\n            pendingRequest.onDone({\n                begin: 0,\n                chunk\n            });\n        } else {\n            pendingRequest.onError?.(xhr.status);\n        }\n    }\n    getRequestXhr(xhrId) {\n        return this.pendingRequests[xhrId].xhr;\n    }\n    isPendingRequest(xhrId) {\n        return xhrId in this.pendingRequests;\n    }\n    abortRequest(xhrId) {\n        const xhr = this.pendingRequests[xhrId].xhr;\n        delete this.pendingRequests[xhrId];\n        xhr.abort();\n    }\n}\nclass PDFNetworkStream {\n    constructor(source){\n        this._source = source;\n        this._manager = new NetworkManager(source);\n        this._rangeChunkSize = source.rangeChunkSize;\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    _onRangeRequestReaderClosed(reader) {\n        const i = this._rangeRequestReaders.indexOf(reader);\n        if (i >= 0) {\n            this._rangeRequestReaders.splice(i, 1);\n        }\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n        return this._fullRequestReader;\n    }\n    getRangeReader(begin, end) {\n        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n        this._rangeRequestReaders.push(reader);\n        return reader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass PDFNetworkStreamFullRequestReader {\n    constructor(manager, source){\n        this._manager = manager;\n        const args = {\n            onHeadersReceived: this._onHeadersReceived.bind(this),\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        };\n        this._url = source.url;\n        this._fullRequestId = manager.requestFull(args);\n        this._headersCapability = Promise.withResolvers();\n        this._disableRange = source.disableRange || false;\n        this._contentLength = source.length;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = false;\n        this._isRangeSupported = false;\n        this._cachedChunks = [];\n        this._requests = [];\n        this._done = false;\n        this._storedError = undefined;\n        this._filename = null;\n        this.onProgress = null;\n    }\n    _onHeadersReceived() {\n        const fullRequestXhrId = this._fullRequestId;\n        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n        const responseHeaders = new Headers(fullRequestXhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/).map((x)=>{\n            const [key, ...val] = x.split(\": \");\n            return [\n                key,\n                val.join(\": \")\n            ];\n        }));\n        const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n            responseHeaders,\n            isHttp: this._manager.isHttp,\n            rangeChunkSize: this._rangeChunkSize,\n            disableRange: this._disableRange\n        });\n        if (allowRangeRequests) {\n            this._isRangeSupported = true;\n        }\n        this._contentLength = suggestedLength || this._contentLength;\n        this._filename = extractFilenameFromHeader(responseHeaders);\n        if (this._isRangeSupported) {\n            this._manager.abortRequest(fullRequestXhrId);\n        }\n        this._headersCapability.resolve();\n    }\n    _onDone(data) {\n        if (data) {\n            if (this._requests.length > 0) {\n                const requestCapability = this._requests.shift();\n                requestCapability.resolve({\n                    value: data.chunk,\n                    done: false\n                });\n            } else {\n                this._cachedChunks.push(data.chunk);\n            }\n        }\n        this._done = true;\n        if (this._cachedChunks.length > 0) {\n            return;\n        }\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n    }\n    _onError(status) {\n        this._storedError = createResponseStatusError(status, this._url);\n        this._headersCapability.reject(this._storedError);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._cachedChunks.length = 0;\n    }\n    _onProgress(evt) {\n        this.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.lengthComputable ? evt.total : this._contentLength\n        });\n    }\n    get filename() {\n        return this._filename;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._cachedChunks.length > 0) {\n            const chunk = this._cachedChunks.shift();\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        this._headersCapability.reject(reason);\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._fullRequestId)) {\n            this._manager.abortRequest(this._fullRequestId);\n        }\n        this._fullRequestReader = null;\n    }\n}\nclass PDFNetworkStreamRangeRequestReader {\n    constructor(manager, begin, end){\n        this._manager = manager;\n        const args = {\n            onDone: this._onDone.bind(this),\n            onError: this._onError.bind(this),\n            onProgress: this._onProgress.bind(this)\n        };\n        this._url = manager.url;\n        this._requestId = manager.requestRange(begin, end, args);\n        this._requests = [];\n        this._queuedChunk = null;\n        this._done = false;\n        this._storedError = undefined;\n        this.onProgress = null;\n        this.onClosed = null;\n    }\n    _close() {\n        this.onClosed?.(this);\n    }\n    _onDone(data) {\n        const chunk = data.chunk;\n        if (this._requests.length > 0) {\n            const requestCapability = this._requests.shift();\n            requestCapability.resolve({\n                value: chunk,\n                done: false\n            });\n        } else {\n            this._queuedChunk = chunk;\n        }\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        this._close();\n    }\n    _onError(status) {\n        this._storedError = createResponseStatusError(status, this._url);\n        for (const requestCapability of this._requests){\n            requestCapability.reject(this._storedError);\n        }\n        this._requests.length = 0;\n        this._queuedChunk = null;\n    }\n    _onProgress(evt) {\n        if (!this.isStreamingSupported) {\n            this.onProgress?.({\n                loaded: evt.loaded\n            });\n        }\n    }\n    get isStreamingSupported() {\n        return false;\n    }\n    async read() {\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        if (this._queuedChunk !== null) {\n            const chunk = this._queuedChunk;\n            this._queuedChunk = null;\n            return {\n                value: chunk,\n                done: false\n            };\n        }\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        const requestCapability = Promise.withResolvers();\n        this._requests.push(requestCapability);\n        return requestCapability.promise;\n    }\n    cancel(reason) {\n        this._done = true;\n        for (const requestCapability of this._requests){\n            requestCapability.resolve({\n                value: undefined,\n                done: true\n            });\n        }\n        this._requests.length = 0;\n        if (this._manager.isPendingRequest(this._requestId)) {\n            this._manager.abortRequest(this._requestId);\n        }\n        this._close();\n    }\n}\n; // ./src/display/node_stream.js\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n    if (urlRegex.test(sourceUrl)) {\n        return new URL(sourceUrl);\n    }\n    const url = NodePackages.get(\"url\");\n    return new URL(url.pathToFileURL(sourceUrl));\n}\nfunction createRequest(url, headers, callback) {\n    if (url.protocol === \"http:\") {\n        const http = NodePackages.get(\"http\");\n        return http.request(url, {\n            headers\n        }, callback);\n    }\n    const https = NodePackages.get(\"https\");\n    return https.request(url, {\n        headers\n    }, callback);\n}\nclass PDFNodeStream {\n    constructor(source){\n        this.source = source;\n        this.url = parseUrlOrPath(source.url);\n        this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n        this.isFsUrl = this.url.protocol === \"file:\";\n        this.headers = createHeaders(this.isHttp, source.httpHeaders);\n        this._fullRequestReader = null;\n        this._rangeRequestReaders = [];\n    }\n    get _progressiveDataLength() {\n        return this._fullRequestReader?._loaded ?? 0;\n    }\n    getFullReader() {\n        assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n        this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n        return this._fullRequestReader;\n    }\n    getRangeReader(start, end) {\n        if (end <= this._progressiveDataLength) {\n            return null;\n        }\n        const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n        this._rangeRequestReaders.push(rangeReader);\n        return rangeReader;\n    }\n    cancelAllRequests(reason) {\n        this._fullRequestReader?.cancel(reason);\n        for (const reader of this._rangeRequestReaders.slice(0)){\n            reader.cancel(reason);\n        }\n    }\n}\nclass BaseFullReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        const source = stream.source;\n        this._contentLength = source.length;\n        this._loaded = 0;\n        this._filename = null;\n        this._disableRange = source.disableRange || false;\n        this._rangeChunkSize = source.rangeChunkSize;\n        if (!this._rangeChunkSize && !this._disableRange) {\n            this._disableRange = true;\n        }\n        this._isStreamingSupported = !source.disableStream;\n        this._isRangeSupported = !source.disableRange;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        this._headersCapability = Promise.withResolvers();\n    }\n    get headersReady() {\n        return this._headersCapability.promise;\n    }\n    get filename() {\n        return this._filename;\n    }\n    get contentLength() {\n        return this._contentLength;\n    }\n    get isRangeSupported() {\n        return this._isRangeSupported;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded,\n            total: this._contentLength\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (!this._isStreamingSupported && this._isRangeSupported) {\n            this._error(new AbortException(\"streaming is disabled\"));\n        }\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass BaseRangeReader {\n    constructor(stream){\n        this._url = stream.url;\n        this._done = false;\n        this._storedError = null;\n        this.onProgress = null;\n        this._loaded = 0;\n        this._readableStream = null;\n        this._readCapability = Promise.withResolvers();\n        const source = stream.source;\n        this._isStreamingSupported = !source.disableStream;\n    }\n    get isStreamingSupported() {\n        return this._isStreamingSupported;\n    }\n    async read() {\n        await this._readCapability.promise;\n        if (this._done) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        if (this._storedError) {\n            throw this._storedError;\n        }\n        const chunk = this._readableStream.read();\n        if (chunk === null) {\n            this._readCapability = Promise.withResolvers();\n            return this.read();\n        }\n        this._loaded += chunk.length;\n        this.onProgress?.({\n            loaded: this._loaded\n        });\n        const buffer = new Uint8Array(chunk).buffer;\n        return {\n            value: buffer,\n            done: false\n        };\n    }\n    cancel(reason) {\n        if (!this._readableStream) {\n            this._error(reason);\n            return;\n        }\n        this._readableStream.destroy(reason);\n    }\n    _error(reason) {\n        this._storedError = reason;\n        this._readCapability.resolve();\n    }\n    _setReadableStream(readableStream) {\n        this._readableStream = readableStream;\n        readableStream.on(\"readable\", ()=>{\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"end\", ()=>{\n            readableStream.destroy();\n            this._done = true;\n            this._readCapability.resolve();\n        });\n        readableStream.on(\"error\", (reason)=>{\n            this._error(reason);\n        });\n        if (this._storedError) {\n            this._readableStream.destroy(this._storedError);\n        }\n    }\n}\nclass PDFNodeStreamFullReader extends BaseFullReader {\n    constructor(stream){\n        super(stream);\n        const headers = Object.fromEntries(stream.headers);\n        const handleResponse = (response)=>{\n            if (response.statusCode === 404) {\n                const error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n                this._storedError = error;\n                this._headersCapability.reject(error);\n                return;\n            }\n            this._headersCapability.resolve();\n            this._setReadableStream(response);\n            const responseHeaders = new Headers(this._readableStream.headers);\n            const { allowRangeRequests, suggestedLength } = validateRangeRequestCapabilities({\n                responseHeaders,\n                isHttp: stream.isHttp,\n                rangeChunkSize: this._rangeChunkSize,\n                disableRange: this._disableRange\n            });\n            this._isRangeSupported = allowRangeRequests;\n            this._contentLength = suggestedLength || this._contentLength;\n            this._filename = extractFilenameFromHeader(responseHeaders);\n        };\n        this._request = createRequest(this._url, headers, handleResponse);\n        this._request.on(\"error\", (reason)=>{\n            this._storedError = reason;\n            this._headersCapability.reject(reason);\n        });\n        this._request.end();\n    }\n}\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n    constructor(stream, start, end){\n        super(stream);\n        const headers = Object.fromEntries(stream.headers);\n        headers.Range = `bytes=${start}-${end - 1}`;\n        const handleResponse = (response)=>{\n            if (response.statusCode === 404) {\n                const error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n                this._storedError = error;\n                return;\n            }\n            this._setReadableStream(response);\n        };\n        this._request = createRequest(this._url, headers, handleResponse);\n        this._request.on(\"error\", (reason)=>{\n            this._storedError = reason;\n        });\n        this._request.end();\n    }\n}\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n    constructor(stream){\n        super(stream);\n        const fs = NodePackages.get(\"fs\");\n        fs.promises.lstat(this._url).then((stat)=>{\n            this._contentLength = stat.size;\n            this._setReadableStream(fs.createReadStream(this._url));\n            this._headersCapability.resolve();\n        }, (error)=>{\n            if (error.code === \"ENOENT\") {\n                error = new MissingPDFException(`Missing PDF \"${this._url}\".`);\n            }\n            this._storedError = error;\n            this._headersCapability.reject(error);\n        });\n    }\n}\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n    constructor(stream, start, end){\n        super(stream);\n        const fs = NodePackages.get(\"fs\");\n        this._setReadableStream(fs.createReadStream(this._url, {\n            start,\n            end: end - 1\n        }));\n    }\n}\n; // ./src/display/text_layer.js\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nclass TextLayer {\n    #capability;\n    #container;\n    #disableProcessItems;\n    #fontInspectorEnabled;\n    #lang;\n    #layoutTextParams;\n    #pageHeight;\n    #pageWidth;\n    #reader;\n    #rootContainer;\n    #rotation;\n    #scale;\n    #styleCache;\n    #textContentItemsStr;\n    #textContentSource;\n    #textDivs;\n    #textDivProperties;\n    #transform;\n    static #ascentCache = new Map();\n    static #canvasContexts = new Map();\n    static #canvasCtxFonts = new WeakMap();\n    static #minFontSize = null;\n    static #pendingTextLayers = new Set();\n    constructor({ textContentSource, container, viewport }){\n        this.#capability = Promise.withResolvers();\n        this.#container = null;\n        this.#disableProcessItems = false;\n        this.#fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n        this.#lang = null;\n        this.#layoutTextParams = null;\n        this.#pageHeight = 0;\n        this.#pageWidth = 0;\n        this.#reader = null;\n        this.#rootContainer = null;\n        this.#rotation = 0;\n        this.#scale = 0;\n        this.#styleCache = Object.create(null);\n        this.#textContentItemsStr = [];\n        this.#textContentSource = null;\n        this.#textDivs = [];\n        this.#textDivProperties = new WeakMap();\n        this.#transform = null;\n        if (textContentSource instanceof ReadableStream) {\n            this.#textContentSource = textContentSource;\n        } else if (typeof textContentSource === \"object\") {\n            this.#textContentSource = new ReadableStream({\n                start (controller) {\n                    controller.enqueue(textContentSource);\n                    controller.close();\n                }\n            });\n        } else {\n            throw new Error('No \"textContentSource\" parameter specified.');\n        }\n        this.#container = this.#rootContainer = container;\n        this.#scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n        this.#rotation = viewport.rotation;\n        this.#layoutTextParams = {\n            div: null,\n            properties: null,\n            ctx: null\n        };\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        this.#transform = [\n            1,\n            0,\n            0,\n            -1,\n            -pageX,\n            pageY + pageHeight\n        ];\n        this.#pageWidth = pageWidth;\n        this.#pageHeight = pageHeight;\n        TextLayer.#ensureMinFontSizeComputed();\n        setLayerDimensions(container, viewport);\n        this.#capability.promise.finally(()=>{\n            TextLayer.#pendingTextLayers.delete(this);\n            this.#layoutTextParams = null;\n            this.#styleCache = null;\n        }).catch(()=>{});\n    }\n    static get fontFamilyMap() {\n        const { isWindows, isFirefox } = util_FeatureTest.platform;\n        return shadow(this, \"fontFamilyMap\", new Map([\n            [\n                \"sans-serif\",\n                `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`\n            ],\n            [\n                \"monospace\",\n                `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`\n            ]\n        ]));\n    }\n    render() {\n        const pump = ()=>{\n            this.#reader.read().then(({ value, done })=>{\n                if (done) {\n                    this.#capability.resolve();\n                    return;\n                }\n                this.#lang ??= value.lang;\n                Object.assign(this.#styleCache, value.styles);\n                this.#processItems(value.items);\n                pump();\n            }, this.#capability.reject);\n        };\n        this.#reader = this.#textContentSource.getReader();\n        TextLayer.#pendingTextLayers.add(this);\n        pump();\n        return this.#capability.promise;\n    }\n    update({ viewport, onBefore = null }) {\n        const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n        const rotation = viewport.rotation;\n        if (rotation !== this.#rotation) {\n            onBefore?.();\n            this.#rotation = rotation;\n            setLayerDimensions(this.#rootContainer, {\n                rotation\n            });\n        }\n        if (scale !== this.#scale) {\n            onBefore?.();\n            this.#scale = scale;\n            const params = {\n                div: null,\n                properties: null,\n                ctx: TextLayer.#getCtx(this.#lang)\n            };\n            for (const div of this.#textDivs){\n                params.properties = this.#textDivProperties.get(div);\n                params.div = div;\n                this.#layout(params);\n            }\n        }\n    }\n    cancel() {\n        const abortEx = new AbortException(\"TextLayer task cancelled.\");\n        this.#reader?.cancel(abortEx).catch(()=>{});\n        this.#reader = null;\n        this.#capability.reject(abortEx);\n    }\n    get textDivs() {\n        return this.#textDivs;\n    }\n    get textContentItemsStr() {\n        return this.#textContentItemsStr;\n    }\n    #processItems(items) {\n        if (this.#disableProcessItems) {\n            return;\n        }\n        this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;\n        for (const item of items){\n            if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n                warn(\"Ignoring additional textDivs for performance reasons.\");\n                this.#disableProcessItems = true;\n                return;\n            }\n            if (item.str === undefined) {\n                if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n                    const parent = this.#container;\n                    this.#container = document.createElement(\"span\");\n                    this.#container.classList.add(\"markedContent\");\n                    if (item.id !== null) {\n                        this.#container.setAttribute(\"id\", `${item.id}`);\n                    }\n                    parent.append(this.#container);\n                } else if (item.type === \"endMarkedContent\") {\n                    this.#container = this.#container.parentNode;\n                }\n                continue;\n            }\n            textContentItemsStr.push(item.str);\n            this.#appendText(item);\n        }\n    }\n    #appendText(geom) {\n        const textDiv = document.createElement(\"span\");\n        const textDivProperties = {\n            angle: 0,\n            canvasWidth: 0,\n            hasText: geom.str !== \"\",\n            hasEOL: geom.hasEOL,\n            fontSize: 0\n        };\n        this.#textDivs.push(textDiv);\n        const tx = Util.transform(this.#transform, geom.transform);\n        let angle = Math.atan2(tx[1], tx[0]);\n        const style = this.#styleCache[geom.fontName];\n        if (style.vertical) {\n            angle += Math.PI / 2;\n        }\n        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n        fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n        const fontHeight = Math.hypot(tx[2], tx[3]);\n        const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, this.#lang);\n        let left, top;\n        if (angle === 0) {\n            left = tx[4];\n            top = tx[5] - fontAscent;\n        } else {\n            left = tx[4] + fontAscent * Math.sin(angle);\n            top = tx[5] - fontAscent * Math.cos(angle);\n        }\n        const scaleFactorStr = \"calc(var(--scale-factor)*\";\n        const divStyle = textDiv.style;\n        if (this.#container === this.#rootContainer) {\n            divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n            divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n        } else {\n            divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n            divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n        }\n        divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n        divStyle.fontFamily = fontFamily;\n        textDivProperties.fontSize = fontHeight;\n        textDiv.setAttribute(\"role\", \"presentation\");\n        textDiv.textContent = geom.str;\n        textDiv.dir = geom.dir;\n        if (this.#fontInspectorEnabled) {\n            textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n        }\n        if (angle !== 0) {\n            textDivProperties.angle = angle * (180 / Math.PI);\n        }\n        let shouldScaleText = false;\n        if (geom.str.length > 1) {\n            shouldScaleText = true;\n        } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n            const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);\n            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n                shouldScaleText = true;\n            }\n        }\n        if (shouldScaleText) {\n            textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n        }\n        this.#textDivProperties.set(textDiv, textDivProperties);\n        this.#layoutTextParams.div = textDiv;\n        this.#layoutTextParams.properties = textDivProperties;\n        this.#layout(this.#layoutTextParams);\n        if (textDivProperties.hasText) {\n            this.#container.append(textDiv);\n        }\n        if (textDivProperties.hasEOL) {\n            const br = document.createElement(\"br\");\n            br.setAttribute(\"role\", \"presentation\");\n            this.#container.append(br);\n        }\n    }\n    #layout(params) {\n        const { div, properties, ctx } = params;\n        const { style } = div;\n        let transform = \"\";\n        if (TextLayer.#minFontSize > 1) {\n            transform = `scale(${1 / TextLayer.#minFontSize})`;\n        }\n        if (properties.canvasWidth !== 0 && properties.hasText) {\n            const { fontFamily } = style;\n            const { canvasWidth, fontSize } = properties;\n            TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n            const { width } = ctx.measureText(div.textContent);\n            if (width > 0) {\n                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n            }\n        }\n        if (properties.angle !== 0) {\n            transform = `rotate(${properties.angle}deg) ${transform}`;\n        }\n        if (transform.length > 0) {\n            style.transform = transform;\n        }\n    }\n    static cleanup() {\n        if (this.#pendingTextLayers.size > 0) {\n            return;\n        }\n        this.#ascentCache.clear();\n        for (const { canvas } of this.#canvasContexts.values()){\n            canvas.remove();\n        }\n        this.#canvasContexts.clear();\n    }\n    static #getCtx(lang = null) {\n        let ctx = this.#canvasContexts.get(lang ||= \"\");\n        if (!ctx) {\n            const canvas = document.createElement(\"canvas\");\n            canvas.className = \"hiddenCanvasElement\";\n            canvas.lang = lang;\n            document.body.append(canvas);\n            ctx = canvas.getContext(\"2d\", {\n                alpha: false,\n                willReadFrequently: true\n            });\n            this.#canvasContexts.set(lang, ctx);\n            this.#canvasCtxFonts.set(ctx, {\n                size: 0,\n                family: \"\"\n            });\n        }\n        return ctx;\n    }\n    static #ensureCtxFont(ctx, size, family) {\n        const cached = this.#canvasCtxFonts.get(ctx);\n        if (size === cached.size && family === cached.family) {\n            return;\n        }\n        ctx.font = `${size}px ${family}`;\n        cached.size = size;\n        cached.family = family;\n    }\n    static #ensureMinFontSizeComputed() {\n        if (this.#minFontSize !== null) {\n            return;\n        }\n        const div = document.createElement(\"div\");\n        div.style.opacity = 0;\n        div.style.lineHeight = 1;\n        div.style.fontSize = \"1px\";\n        div.style.position = \"absolute\";\n        div.textContent = \"X\";\n        document.body.append(div);\n        this.#minFontSize = div.getBoundingClientRect().height;\n        div.remove();\n    }\n    static #getAscent(fontFamily, lang) {\n        const cachedAscent = this.#ascentCache.get(fontFamily);\n        if (cachedAscent) {\n            return cachedAscent;\n        }\n        const ctx = this.#getCtx(lang);\n        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n        const metrics = ctx.measureText(\"\");\n        let ascent = metrics.fontBoundingBoxAscent;\n        let descent = Math.abs(metrics.fontBoundingBoxDescent);\n        if (ascent) {\n            const ratio = ascent / (ascent + descent);\n            this.#ascentCache.set(fontFamily, ratio);\n            ctx.canvas.width = ctx.canvas.height = 0;\n            return ratio;\n        }\n        ctx.strokeStyle = \"red\";\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"g\", 0, 0);\n        let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        descent = 0;\n        for(let i = pixels.length - 1 - 3; i >= 0; i -= 4){\n            if (pixels[i] > 0) {\n                descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n                break;\n            }\n        }\n        ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n        ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n        pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n        ascent = 0;\n        for(let i = 0, ii = pixels.length; i < ii; i += 4){\n            if (pixels[i] > 0) {\n                ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n                break;\n            }\n        }\n        ctx.canvas.width = ctx.canvas.height = 0;\n        const ratio = ascent ? ascent / (ascent + descent) : DEFAULT_FONT_ASCENT;\n        this.#ascentCache.set(fontFamily, ratio);\n        return ratio;\n    }\n}\n; // ./src/display/xfa_text.js\nclass XfaText {\n    static textContent(xfa) {\n        const items = [];\n        const output = {\n            items,\n            styles: Object.create(null)\n        };\n        function walk(node) {\n            if (!node) {\n                return;\n            }\n            let str = null;\n            const name = node.name;\n            if (name === \"#text\") {\n                str = node.value;\n            } else if (!XfaText.shouldBuildText(name)) {\n                return;\n            } else if (node?.attributes?.textContent) {\n                str = node.attributes.textContent;\n            } else if (node.value) {\n                str = node.value;\n            }\n            if (str !== null) {\n                items.push({\n                    str\n                });\n            }\n            if (!node.children) {\n                return;\n            }\n            for (const child of node.children){\n                walk(child);\n            }\n        }\n        walk(xfa);\n        return output;\n    }\n    static shouldBuildText(name) {\n        return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n    }\n}\n; // ./src/display/api.js\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DELAYED_CLEANUP_TIMEOUT = 5000;\nconst DefaultCanvasFactory = isNodeJS ? NodeCanvasFactory : DOMCanvasFactory;\nconst DefaultCMapReaderFactory = isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory;\nconst DefaultFilterFactory = isNodeJS ? NodeFilterFactory : DOMFilterFactory;\nconst DefaultStandardFontDataFactory = isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory;\nfunction getDocument(src = {}) {\n    if (typeof src === \"string\" || src instanceof URL) {\n        src = {\n            url: src\n        };\n    } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n        src = {\n            data: src\n        };\n    }\n    const task = new PDFDocumentLoadingTask();\n    const { docId } = task;\n    const url = src.url ? getUrlProp(src.url) : null;\n    const data = src.data ? getDataProp(src.data) : null;\n    const httpHeaders = src.httpHeaders || null;\n    const withCredentials = src.withCredentials === true;\n    const password = src.password ?? null;\n    const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n    const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n    let worker = src.worker instanceof PDFWorker ? src.worker : null;\n    const verbosity = src.verbosity;\n    const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n    const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n    const cMapPacked = src.cMapPacked !== false;\n    const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n    const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n    const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n    const ignoreErrors = src.stopAtErrors !== true;\n    const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n    const isEvalSupported = src.isEvalSupported !== false;\n    const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n    const isChrome = typeof src.isChrome === \"boolean\" ? src.isChrome : !util_FeatureTest.platform.isFirefox && \"undefined\" !== \"undefined\" && 0;\n    const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n    const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n    const fontExtraProperties = src.fontExtraProperties === true;\n    const enableXfa = src.enableXfa === true;\n    const ownerDocument = src.ownerDocument || globalThis.document;\n    const disableRange = src.disableRange === true;\n    const disableStream = src.disableStream === true;\n    const disableAutoFetch = src.disableAutoFetch === true;\n    const pdfBug = src.pdfBug === true;\n    const CanvasFactory = src.CanvasFactory || DefaultCanvasFactory;\n    const FilterFactory = src.FilterFactory || DefaultFilterFactory;\n    const enableHWA = src.enableHWA === true;\n    const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n    const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n    const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI);\n    if (src.canvasFactory) {\n        deprecated(\"`canvasFactory`-instance option, please use `CanvasFactory` instead.\");\n    }\n    if (src.filterFactory) {\n        deprecated(\"`filterFactory`-instance option, please use `FilterFactory` instead.\");\n    }\n    const styleElement = null;\n    setVerbosityLevel(verbosity);\n    const transportFactory = {\n        canvasFactory: new CanvasFactory({\n            ownerDocument,\n            enableHWA\n        }),\n        filterFactory: new FilterFactory({\n            docId,\n            ownerDocument\n        }),\n        cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n            baseUrl: cMapUrl,\n            isCompressed: cMapPacked\n        }),\n        standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n            baseUrl: standardFontDataUrl\n        })\n    };\n    if (!worker) {\n        const workerParams = {\n            verbosity,\n            port: GlobalWorkerOptions.workerPort\n        };\n        worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n        task._worker = worker;\n    }\n    const docParams = {\n        docId,\n        apiVersion: \"4.8.69\",\n        data,\n        password,\n        disableAutoFetch,\n        rangeChunkSize,\n        length,\n        docBaseUrl,\n        enableXfa,\n        evaluatorOptions: {\n            maxImageSize,\n            disableFontFace,\n            ignoreErrors,\n            isEvalSupported,\n            isOffscreenCanvasSupported,\n            isChrome,\n            canvasMaxAreaInBytes,\n            fontExtraProperties,\n            useSystemFonts,\n            cMapUrl: useWorkerFetch ? cMapUrl : null,\n            standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n        }\n    };\n    const transportParams = {\n        disableFontFace,\n        fontExtraProperties,\n        ownerDocument,\n        pdfBug,\n        styleElement,\n        loadingParams: {\n            disableAutoFetch,\n            enableXfa\n        }\n    };\n    worker.promise.then(function() {\n        if (task.destroyed) {\n            throw new Error(\"Loading aborted\");\n        }\n        if (worker.destroyed) {\n            throw new Error(\"Worker was destroyed\");\n        }\n        const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [\n            data.buffer\n        ] : null);\n        let networkStream;\n        if (rangeTransport) {\n            networkStream = new PDFDataTransportStream(rangeTransport, {\n                disableRange,\n                disableStream\n            });\n        } else if (!data) {\n            if (!url) {\n                throw new Error(\"getDocument - no `url` parameter provided.\");\n            }\n            let NetworkStream;\n            if (isNodeJS) {\n                const isFetchSupported = typeof fetch !== \"undefined\" && typeof Response !== \"undefined\" && \"body\" in Response.prototype;\n                NetworkStream = isFetchSupported && isValidFetchUrl(url) ? PDFFetchStream : PDFNodeStream;\n            } else {\n                NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : PDFNetworkStream;\n            }\n            networkStream = new NetworkStream({\n                url,\n                length,\n                httpHeaders,\n                withCredentials,\n                rangeChunkSize,\n                disableRange,\n                disableStream\n            });\n        }\n        return workerIdPromise.then((workerId)=>{\n            if (task.destroyed) {\n                throw new Error(\"Loading aborted\");\n            }\n            if (worker.destroyed) {\n                throw new Error(\"Worker was destroyed\");\n            }\n            const messageHandler = new MessageHandler(docId, workerId, worker.port);\n            const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n            task._transport = transport;\n            messageHandler.send(\"Ready\", null);\n        });\n    }).catch(task._capability.reject);\n    return task;\n}\nfunction getUrlProp(val) {\n    if (val instanceof URL) {\n        return val.href;\n    }\n    try {\n        return new URL(val, window.location).href;\n    } catch  {\n        if (isNodeJS && typeof val === \"string\") {\n            return val;\n        }\n    }\n    throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n    if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n        throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n    }\n    if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n        return val;\n    }\n    if (typeof val === \"string\") {\n        return stringToBytes(val);\n    }\n    if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n        return new Uint8Array(val);\n    }\n    throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction isRefProxy(ref) {\n    return typeof ref === \"object\" && Number.isInteger(ref?.num) && ref.num >= 0 && Number.isInteger(ref?.gen) && ref.gen >= 0;\n}\nclass PDFDocumentLoadingTask {\n    static #docId = 0;\n    constructor(){\n        this._capability = Promise.withResolvers();\n        this._transport = null;\n        this._worker = null;\n        this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n        this.destroyed = false;\n        this.onPassword = null;\n        this.onProgress = null;\n    }\n    get promise() {\n        return this._capability.promise;\n    }\n    async destroy() {\n        this.destroyed = true;\n        try {\n            if (this._worker?.port) {\n                this._worker._pendingDestroy = true;\n            }\n            await this._transport?.destroy();\n        } catch (ex) {\n            if (this._worker?.port) {\n                delete this._worker._pendingDestroy;\n            }\n            throw ex;\n        }\n        this._transport = null;\n        if (this._worker) {\n            this._worker.destroy();\n            this._worker = null;\n        }\n    }\n}\nclass PDFDataRangeTransport {\n    constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null){\n        this.length = length;\n        this.initialData = initialData;\n        this.progressiveDone = progressiveDone;\n        this.contentDispositionFilename = contentDispositionFilename;\n        this._rangeListeners = [];\n        this._progressListeners = [];\n        this._progressiveReadListeners = [];\n        this._progressiveDoneListeners = [];\n        this._readyCapability = Promise.withResolvers();\n    }\n    addRangeListener(listener) {\n        this._rangeListeners.push(listener);\n    }\n    addProgressListener(listener) {\n        this._progressListeners.push(listener);\n    }\n    addProgressiveReadListener(listener) {\n        this._progressiveReadListeners.push(listener);\n    }\n    addProgressiveDoneListener(listener) {\n        this._progressiveDoneListeners.push(listener);\n    }\n    onDataRange(begin, chunk) {\n        for (const listener of this._rangeListeners){\n            listener(begin, chunk);\n        }\n    }\n    onDataProgress(loaded, total) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressListeners){\n                listener(loaded, total);\n            }\n        });\n    }\n    onDataProgressiveRead(chunk) {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveReadListeners){\n                listener(chunk);\n            }\n        });\n    }\n    onDataProgressiveDone() {\n        this._readyCapability.promise.then(()=>{\n            for (const listener of this._progressiveDoneListeners){\n                listener();\n            }\n        });\n    }\n    transportReady() {\n        this._readyCapability.resolve();\n    }\n    requestDataRange(begin, end) {\n        unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n    abort() {}\n}\nclass PDFDocumentProxy {\n    constructor(pdfInfo, transport){\n        this._pdfInfo = pdfInfo;\n        this._transport = transport;\n    }\n    get annotationStorage() {\n        return this._transport.annotationStorage;\n    }\n    get canvasFactory() {\n        return this._transport.canvasFactory;\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get numPages() {\n        return this._pdfInfo.numPages;\n    }\n    get fingerprints() {\n        return this._pdfInfo.fingerprints;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    get allXfaHtml() {\n        return this._transport._htmlForXfa;\n    }\n    getPage(pageNumber) {\n        return this._transport.getPage(pageNumber);\n    }\n    getPageIndex(ref) {\n        return this._transport.getPageIndex(ref);\n    }\n    getDestinations() {\n        return this._transport.getDestinations();\n    }\n    getDestination(id) {\n        return this._transport.getDestination(id);\n    }\n    getPageLabels() {\n        return this._transport.getPageLabels();\n    }\n    getPageLayout() {\n        return this._transport.getPageLayout();\n    }\n    getPageMode() {\n        return this._transport.getPageMode();\n    }\n    getViewerPreferences() {\n        return this._transport.getViewerPreferences();\n    }\n    getOpenAction() {\n        return this._transport.getOpenAction();\n    }\n    getAttachments() {\n        return this._transport.getAttachments();\n    }\n    getJSActions() {\n        return this._transport.getDocJSActions();\n    }\n    getOutline() {\n        return this._transport.getOutline();\n    }\n    getOptionalContentConfig({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getOptionalContentConfig(renderingIntent);\n    }\n    getPermissions() {\n        return this._transport.getPermissions();\n    }\n    getMetadata() {\n        return this._transport.getMetadata();\n    }\n    getMarkInfo() {\n        return this._transport.getMarkInfo();\n    }\n    getData() {\n        return this._transport.getData();\n    }\n    saveDocument() {\n        return this._transport.saveDocument();\n    }\n    getDownloadInfo() {\n        return this._transport.downloadInfoCapability.promise;\n    }\n    cleanup(keepLoadedFonts = false) {\n        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n    }\n    destroy() {\n        return this.loadingTask.destroy();\n    }\n    cachedPageNumber(ref) {\n        return this._transport.cachedPageNumber(ref);\n    }\n    get loadingParams() {\n        return this._transport.loadingParams;\n    }\n    get loadingTask() {\n        return this._transport.loadingTask;\n    }\n    getFieldObjects() {\n        return this._transport.getFieldObjects();\n    }\n    hasJSActions() {\n        return this._transport.hasJSActions();\n    }\n    getCalculationOrderIds() {\n        return this._transport.getCalculationOrderIds();\n    }\n}\nclass PDFPageProxy {\n    #delayedCleanupTimeout;\n    #pendingCleanup;\n    constructor(pageIndex, pageInfo, transport, pdfBug = false){\n        this.#delayedCleanupTimeout = null;\n        this.#pendingCleanup = false;\n        this._pageIndex = pageIndex;\n        this._pageInfo = pageInfo;\n        this._transport = transport;\n        this._stats = pdfBug ? new StatTimer() : null;\n        this._pdfBug = pdfBug;\n        this.commonObjs = transport.commonObjs;\n        this.objs = new PDFObjects();\n        this._maybeCleanupAfterRender = false;\n        this._intentStates = new Map();\n        this.destroyed = false;\n    }\n    get pageNumber() {\n        return this._pageIndex + 1;\n    }\n    get rotate() {\n        return this._pageInfo.rotate;\n    }\n    get ref() {\n        return this._pageInfo.ref;\n    }\n    get userUnit() {\n        return this._pageInfo.userUnit;\n    }\n    get view() {\n        return this._pageInfo.view;\n    }\n    getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) {\n        return new PageViewport({\n            viewBox: this.view,\n            scale,\n            rotation,\n            offsetX,\n            offsetY,\n            dontFlip\n        });\n    }\n    getAnnotations({ intent = \"display\" } = {}) {\n        const { renderingIntent } = this._transport.getRenderingIntent(intent);\n        return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n    }\n    getJSActions() {\n        return this._transport.getPageJSActions(this._pageIndex);\n    }\n    get filterFactory() {\n        return this._transport.filterFactory;\n    }\n    get isPureXfa() {\n        return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n    }\n    async getXfa() {\n        return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n    }\n    render({ canvasContext, viewport, intent = \"display\", annotationMode = AnnotationMode.ENABLE, transform = null, background = null, optionalContentConfigPromise = null, annotationCanvasMap = null, pageColors = null, printAnnotationStorage = null, isEditing = false }) {\n        this._stats?.time(\"Overall\");\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n        const { renderingIntent, cacheKey } = intentArgs;\n        this.#pendingCleanup = false;\n        this.#abortDelayedCleanup();\n        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n        let intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(cacheKey, intentState);\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n        if (!intentState.displayReadyCapability) {\n            intentState.displayReadyCapability = Promise.withResolvers();\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        const complete = (error)=>{\n            intentState.renderTasks.delete(internalRenderTask);\n            if (this._maybeCleanupAfterRender || intentPrint) {\n                this.#pendingCleanup = true;\n            }\n            this.#tryCleanup(!intentPrint);\n            if (error) {\n                internalRenderTask.capability.reject(error);\n                this._abortOperatorList({\n                    intentState,\n                    reason: error instanceof Error ? error : new Error(error)\n                });\n            } else {\n                internalRenderTask.capability.resolve();\n            }\n            if (this._stats) {\n                this._stats.timeEnd(\"Rendering\");\n                this._stats.timeEnd(\"Overall\");\n                if (globalThis.Stats?.enabled) {\n                    globalThis.Stats.add(this.pageNumber, this._stats);\n                }\n            }\n        };\n        const internalRenderTask = new InternalRenderTask({\n            callback: complete,\n            params: {\n                canvasContext,\n                viewport,\n                transform,\n                background\n            },\n            objs: this.objs,\n            commonObjs: this.commonObjs,\n            annotationCanvasMap,\n            operatorList: intentState.operatorList,\n            pageIndex: this._pageIndex,\n            canvasFactory: this._transport.canvasFactory,\n            filterFactory: this._transport.filterFactory,\n            useRequestAnimationFrame: !intentPrint,\n            pdfBug: this._pdfBug,\n            pageColors\n        });\n        (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n        const renderTask = internalRenderTask.task;\n        Promise.all([\n            intentState.displayReadyCapability.promise,\n            optionalContentConfigPromise\n        ]).then(([transparency, optionalContentConfig])=>{\n            if (this.destroyed) {\n                complete();\n                return;\n            }\n            this._stats?.time(\"Rendering\");\n            if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n                throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n            }\n            internalRenderTask.initializeGraphics({\n                transparency,\n                optionalContentConfig\n            });\n            internalRenderTask.operatorListChanged();\n        }).catch(complete);\n        return renderTask;\n    }\n    getOperatorList({ intent = \"display\", annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false } = {}) {\n        function operatorListChanged() {\n            if (intentState.operatorList.lastChunk) {\n                intentState.opListReadCapability.resolve(intentState.operatorList);\n                intentState.renderTasks.delete(opListTask);\n            }\n        }\n        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n        let intentState = this._intentStates.get(intentArgs.cacheKey);\n        if (!intentState) {\n            intentState = Object.create(null);\n            this._intentStates.set(intentArgs.cacheKey, intentState);\n        }\n        let opListTask;\n        if (!intentState.opListReadCapability) {\n            opListTask = Object.create(null);\n            opListTask.operatorListChanged = operatorListChanged;\n            intentState.opListReadCapability = Promise.withResolvers();\n            (intentState.renderTasks ||= new Set()).add(opListTask);\n            intentState.operatorList = {\n                fnArray: [],\n                argsArray: [],\n                lastChunk: false,\n                separateAnnots: null\n            };\n            this._stats?.time(\"Page Request\");\n            this._pumpOperatorList(intentArgs);\n        }\n        return intentState.opListReadCapability.promise;\n    }\n    streamTextContent({ includeMarkedContent = false, disableNormalization = false } = {}) {\n        const TEXT_CONTENT_CHUNK_SIZE = 100;\n        return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n            pageIndex: this._pageIndex,\n            includeMarkedContent: includeMarkedContent === true,\n            disableNormalization: disableNormalization === true\n        }, {\n            highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n            size (textContent) {\n                return textContent.items.length;\n            }\n        });\n    }\n    getTextContent(params = {}) {\n        if (this._transport._htmlForXfa) {\n            return this.getXfa().then((xfa)=>XfaText.textContent(xfa));\n        }\n        const readableStream = this.streamTextContent(params);\n        return new Promise(function(resolve, reject) {\n            function pump() {\n                reader.read().then(function({ value, done }) {\n                    if (done) {\n                        resolve(textContent);\n                        return;\n                    }\n                    textContent.lang ??= value.lang;\n                    Object.assign(textContent.styles, value.styles);\n                    textContent.items.push(...value.items);\n                    pump();\n                }, reject);\n            }\n            const reader = readableStream.getReader();\n            const textContent = {\n                items: [],\n                styles: Object.create(null),\n                lang: null\n            };\n            pump();\n        });\n    }\n    getStructTree() {\n        return this._transport.getStructTree(this._pageIndex);\n    }\n    _destroy() {\n        this.destroyed = true;\n        const waitOn = [];\n        for (const intentState of this._intentStates.values()){\n            this._abortOperatorList({\n                intentState,\n                reason: new Error(\"Page was destroyed.\"),\n                force: true\n            });\n            if (intentState.opListReadCapability) {\n                continue;\n            }\n            for (const internalRenderTask of intentState.renderTasks){\n                waitOn.push(internalRenderTask.completed);\n                internalRenderTask.cancel();\n            }\n        }\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        this.#abortDelayedCleanup();\n        return Promise.all(waitOn);\n    }\n    cleanup(resetStats = false) {\n        this.#pendingCleanup = true;\n        const success = this.#tryCleanup(false);\n        if (resetStats && success) {\n            this._stats &&= new StatTimer();\n        }\n        return success;\n    }\n    #tryCleanup(delayed = false) {\n        this.#abortDelayedCleanup();\n        if (!this.#pendingCleanup || this.destroyed) {\n            return false;\n        }\n        if (delayed) {\n            this.#delayedCleanupTimeout = setTimeout(()=>{\n                this.#delayedCleanupTimeout = null;\n                this.#tryCleanup(false);\n            }, DELAYED_CLEANUP_TIMEOUT);\n            return false;\n        }\n        for (const { renderTasks, operatorList } of this._intentStates.values()){\n            if (renderTasks.size > 0 || !operatorList.lastChunk) {\n                return false;\n            }\n        }\n        this._intentStates.clear();\n        this.objs.clear();\n        this.#pendingCleanup = false;\n        return true;\n    }\n    #abortDelayedCleanup() {\n        if (this.#delayedCleanupTimeout) {\n            clearTimeout(this.#delayedCleanupTimeout);\n            this.#delayedCleanupTimeout = null;\n        }\n    }\n    _startRenderPage(transparency, cacheKey) {\n        const intentState = this._intentStates.get(cacheKey);\n        if (!intentState) {\n            return;\n        }\n        this._stats?.timeEnd(\"Page Request\");\n        intentState.displayReadyCapability?.resolve(transparency);\n    }\n    _renderPageChunk(operatorListChunk, intentState) {\n        for(let i = 0, ii = operatorListChunk.length; i < ii; i++){\n            intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n            intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n        }\n        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n        for (const internalRenderTask of intentState.renderTasks){\n            internalRenderTask.operatorListChanged();\n        }\n        if (operatorListChunk.lastChunk) {\n            this.#tryCleanup(true);\n        }\n    }\n    _pumpOperatorList({ renderingIntent, cacheKey, annotationStorageSerializable, modifiedIds }) {\n        const { map, transfer } = annotationStorageSerializable;\n        const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n            pageIndex: this._pageIndex,\n            intent: renderingIntent,\n            cacheKey,\n            annotationStorage: map,\n            modifiedIds\n        }, transfer);\n        const reader = readableStream.getReader();\n        const intentState = this._intentStates.get(cacheKey);\n        intentState.streamReader = reader;\n        const pump = ()=>{\n            reader.read().then(({ value, done })=>{\n                if (done) {\n                    intentState.streamReader = null;\n                    return;\n                }\n                if (this._transport.destroyed) {\n                    return;\n                }\n                this._renderPageChunk(value, intentState);\n                pump();\n            }, (reason)=>{\n                intentState.streamReader = null;\n                if (this._transport.destroyed) {\n                    return;\n                }\n                if (intentState.operatorList) {\n                    intentState.operatorList.lastChunk = true;\n                    for (const internalRenderTask of intentState.renderTasks){\n                        internalRenderTask.operatorListChanged();\n                    }\n                    this.#tryCleanup(true);\n                }\n                if (intentState.displayReadyCapability) {\n                    intentState.displayReadyCapability.reject(reason);\n                } else if (intentState.opListReadCapability) {\n                    intentState.opListReadCapability.reject(reason);\n                } else {\n                    throw reason;\n                }\n            });\n        };\n        pump();\n    }\n    _abortOperatorList({ intentState, reason, force = false }) {\n        if (!intentState.streamReader) {\n            return;\n        }\n        if (intentState.streamReaderCancelTimeout) {\n            clearTimeout(intentState.streamReaderCancelTimeout);\n            intentState.streamReaderCancelTimeout = null;\n        }\n        if (!force) {\n            if (intentState.renderTasks.size > 0) {\n                return;\n            }\n            if (reason instanceof RenderingCancelledException) {\n                let delay = RENDERING_CANCELLED_TIMEOUT;\n                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n                    delay += reason.extraDelay;\n                }\n                intentState.streamReaderCancelTimeout = setTimeout(()=>{\n                    intentState.streamReaderCancelTimeout = null;\n                    this._abortOperatorList({\n                        intentState,\n                        reason,\n                        force: true\n                    });\n                }, delay);\n                return;\n            }\n        }\n        intentState.streamReader.cancel(new AbortException(reason.message)).catch(()=>{});\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n            return;\n        }\n        for (const [curCacheKey, curIntentState] of this._intentStates){\n            if (curIntentState === intentState) {\n                this._intentStates.delete(curCacheKey);\n                break;\n            }\n        }\n        this.cleanup();\n    }\n    get stats() {\n        return this._stats;\n    }\n}\nclass LoopbackPort {\n    #listeners;\n    #deferred;\n    postMessage(obj, transfer) {\n        const event = {\n            data: structuredClone(obj, transfer ? {\n                transfer\n            } : null)\n        };\n        this.#deferred.then(()=>{\n            for (const [listener] of this.#listeners){\n                listener.call(this, event);\n            }\n        });\n    }\n    addEventListener(name, listener, options = null) {\n        let rmAbort = null;\n        if (options?.signal instanceof AbortSignal) {\n            const { signal } = options;\n            if (signal.aborted) {\n                warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n                return;\n            }\n            const onAbort = ()=>this.removeEventListener(name, listener);\n            rmAbort = ()=>signal.removeEventListener(\"abort\", onAbort);\n            signal.addEventListener(\"abort\", onAbort);\n        }\n        this.#listeners.set(listener, rmAbort);\n    }\n    removeEventListener(name, listener) {\n        const rmAbort = this.#listeners.get(listener);\n        rmAbort?.();\n        this.#listeners.delete(listener);\n    }\n    terminate() {\n        for (const [, rmAbort] of this.#listeners){\n            rmAbort?.();\n        }\n        this.#listeners.clear();\n    }\n    constructor(){\n        this.#listeners = new Map();\n        this.#deferred = Promise.resolve();\n    }\n}\nclass PDFWorker {\n    static #fakeWorkerId = 0;\n    static #isWorkerDisabled = false;\n    static #workerPorts;\n    static{\n        if (isNodeJS) {\n            this.#isWorkerDisabled = true;\n            GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n        }\n        this._isSameOrigin = (baseUrl, otherUrl)=>{\n            let base;\n            try {\n                base = new URL(baseUrl);\n                if (!base.origin || base.origin === \"null\") {\n                    return false;\n                }\n            } catch  {\n                return false;\n            }\n            const other = new URL(otherUrl, base);\n            return base.origin === other.origin;\n        };\n        this._createCDNWrapper = (url)=>{\n            const wrapper = `await import(\"${url}\");`;\n            return URL.createObjectURL(new Blob([\n                wrapper\n            ], {\n                type: \"text/javascript\"\n            }));\n        };\n    }\n    constructor({ name = null, port = null, verbosity = getVerbosityLevel() } = {}){\n        this.name = name;\n        this.destroyed = false;\n        this.verbosity = verbosity;\n        this._readyCapability = Promise.withResolvers();\n        this._port = null;\n        this._webWorker = null;\n        this._messageHandler = null;\n        if (port) {\n            if (PDFWorker.#workerPorts?.has(port)) {\n                throw new Error(\"Cannot use more than one PDFWorker per port.\");\n            }\n            (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n            this._initializeFromPort(port);\n            return;\n        }\n        this._initialize();\n    }\n    get promise() {\n        if (isNodeJS) {\n            return Promise.all([\n                NodePackages.promise,\n                this._readyCapability.promise\n            ]);\n        }\n        return this._readyCapability.promise;\n    }\n    #resolve() {\n        this._readyCapability.resolve();\n        this._messageHandler.send(\"configure\", {\n            verbosity: this.verbosity\n        });\n    }\n    get port() {\n        return this._port;\n    }\n    get messageHandler() {\n        return this._messageHandler;\n    }\n    _initializeFromPort(port) {\n        this._port = port;\n        this._messageHandler = new MessageHandler(\"main\", \"worker\", port);\n        this._messageHandler.on(\"ready\", function() {});\n        this.#resolve();\n    }\n    _initialize() {\n        if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n            this._setupFakeWorker();\n            return;\n        }\n        let { workerSrc } = PDFWorker;\n        try {\n            if (!PDFWorker._isSameOrigin(window.location.href, workerSrc)) {\n                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n            const worker = new Worker(workerSrc, {\n                type: \"module\"\n            });\n            const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n            const terminateEarly = ()=>{\n                ac.abort();\n                messageHandler.destroy();\n                worker.terminate();\n                if (this.destroyed) {\n                    this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                } else {\n                    this._setupFakeWorker();\n                }\n            };\n            const ac = new AbortController();\n            worker.addEventListener(\"error\", ()=>{\n                if (!this._webWorker) {\n                    terminateEarly();\n                }\n            }, {\n                signal: ac.signal\n            });\n            messageHandler.on(\"test\", (data)=>{\n                ac.abort();\n                if (this.destroyed || !data) {\n                    terminateEarly();\n                    return;\n                }\n                this._messageHandler = messageHandler;\n                this._port = worker;\n                this._webWorker = worker;\n                this.#resolve();\n            });\n            messageHandler.on(\"ready\", (data)=>{\n                ac.abort();\n                if (this.destroyed) {\n                    terminateEarly();\n                    return;\n                }\n                try {\n                    sendTest();\n                } catch  {\n                    this._setupFakeWorker();\n                }\n            });\n            const sendTest = ()=>{\n                const testObj = new Uint8Array();\n                messageHandler.send(\"test\", testObj, [\n                    testObj.buffer\n                ]);\n            };\n            sendTest();\n            return;\n        } catch  {\n            info(\"The worker has been disabled.\");\n        }\n        this._setupFakeWorker();\n    }\n    _setupFakeWorker() {\n        if (!PDFWorker.#isWorkerDisabled) {\n            warn(\"Setting up fake worker.\");\n            PDFWorker.#isWorkerDisabled = true;\n        }\n        PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler)=>{\n            if (this.destroyed) {\n                this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n                return;\n            }\n            const port = new LoopbackPort();\n            this._port = port;\n            const id = `fake${PDFWorker.#fakeWorkerId++}`;\n            const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n            WorkerMessageHandler.setup(workerHandler, port);\n            this._messageHandler = new MessageHandler(id, id + \"_worker\", port);\n            this.#resolve();\n        }).catch((reason)=>{\n            this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n        });\n    }\n    destroy() {\n        this.destroyed = true;\n        if (this._webWorker) {\n            this._webWorker.terminate();\n            this._webWorker = null;\n        }\n        PDFWorker.#workerPorts?.delete(this._port);\n        this._port = null;\n        if (this._messageHandler) {\n            this._messageHandler.destroy();\n            this._messageHandler = null;\n        }\n    }\n    static fromPort(params) {\n        if (!params?.port) {\n            throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n        const cachedPort = this.#workerPorts?.get(params.port);\n        if (cachedPort) {\n            if (cachedPort._pendingDestroy) {\n                throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n            }\n            return cachedPort;\n        }\n        return new PDFWorker(params);\n    }\n    static get workerSrc() {\n        if (GlobalWorkerOptions.workerSrc) {\n            return GlobalWorkerOptions.workerSrc;\n        }\n        throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n    }\n    static get #mainThreadWorkerMessageHandler() {\n        try {\n            return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n        } catch  {\n            return null;\n        }\n    }\n    static get _setupFakeWorkerGlobal() {\n        const loader = async ()=>{\n            if (this.#mainThreadWorkerMessageHandler) {\n                return this.#mainThreadWorkerMessageHandler;\n            }\n            const worker = await import(/*webpackIgnore: true*/ this.workerSrc);\n            return worker.WorkerMessageHandler;\n        };\n        return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n    }\n}\nclass WorkerTransport {\n    #methodPromises;\n    #pageCache;\n    #pagePromises;\n    #pageRefCache;\n    #passwordCapability;\n    constructor(messageHandler, loadingTask, networkStream, params, factory){\n        this.#methodPromises = new Map();\n        this.#pageCache = new Map();\n        this.#pagePromises = new Map();\n        this.#pageRefCache = new Map();\n        this.#passwordCapability = null;\n        this.messageHandler = messageHandler;\n        this.loadingTask = loadingTask;\n        this.commonObjs = new PDFObjects();\n        this.fontLoader = new FontLoader({\n            ownerDocument: params.ownerDocument,\n            styleElement: params.styleElement\n        });\n        this.loadingParams = params.loadingParams;\n        this._params = params;\n        this.canvasFactory = factory.canvasFactory;\n        this.filterFactory = factory.filterFactory;\n        this.cMapReaderFactory = factory.cMapReaderFactory;\n        this.standardFontDataFactory = factory.standardFontDataFactory;\n        this.destroyed = false;\n        this.destroyCapability = null;\n        this._networkStream = networkStream;\n        this._fullReader = null;\n        this._lastProgress = null;\n        this.downloadInfoCapability = Promise.withResolvers();\n        this.setupMessageHandler();\n    }\n    #cacheSimpleMethod(name, data = null) {\n        const cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, data);\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    get annotationStorage() {\n        return shadow(this, \"annotationStorage\", new AnnotationStorage());\n    }\n    getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n        let renderingIntent = RenderingIntentFlag.DISPLAY;\n        let annotationStorageSerializable = SerializableEmpty;\n        switch(intent){\n            case \"any\":\n                renderingIntent = RenderingIntentFlag.ANY;\n                break;\n            case \"display\":\n                break;\n            case \"print\":\n                renderingIntent = RenderingIntentFlag.PRINT;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid intent: ${intent}`);\n        }\n        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        switch(annotationMode){\n            case AnnotationMode.DISABLE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n                break;\n            case AnnotationMode.ENABLE:\n                break;\n            case AnnotationMode.ENABLE_FORMS:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n                break;\n            case AnnotationMode.ENABLE_STORAGE:\n                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n                annotationStorageSerializable = annotationStorage.serializable;\n                break;\n            default:\n                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n        }\n        if (isEditing) {\n            renderingIntent += RenderingIntentFlag.IS_EDITING;\n        }\n        if (isOpList) {\n            renderingIntent += RenderingIntentFlag.OPLIST;\n        }\n        const { ids: modifiedIds, hash: modifiedIdsHash } = annotationStorage.modifiedIds;\n        const cacheKeyBuf = [\n            renderingIntent,\n            annotationStorageSerializable.hash,\n            modifiedIdsHash\n        ];\n        return {\n            renderingIntent,\n            cacheKey: cacheKeyBuf.join(\"_\"),\n            annotationStorageSerializable,\n            modifiedIds\n        };\n    }\n    destroy() {\n        if (this.destroyCapability) {\n            return this.destroyCapability.promise;\n        }\n        this.destroyed = true;\n        this.destroyCapability = Promise.withResolvers();\n        this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n        const waitOn = [];\n        for (const page of this.#pageCache.values()){\n            waitOn.push(page._destroy());\n        }\n        this.#pageCache.clear();\n        this.#pagePromises.clear();\n        this.#pageRefCache.clear();\n        if (this.hasOwnProperty(\"annotationStorage\")) {\n            this.annotationStorage.resetModified();\n        }\n        const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n        waitOn.push(terminated);\n        Promise.all(waitOn).then(()=>{\n            this.commonObjs.clear();\n            this.fontLoader.clear();\n            this.#methodPromises.clear();\n            this.filterFactory.destroy();\n            TextLayer.cleanup();\n            this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n            if (this.messageHandler) {\n                this.messageHandler.destroy();\n                this.messageHandler = null;\n            }\n            this.destroyCapability.resolve();\n        }, this.destroyCapability.reject);\n        return this.destroyCapability.promise;\n    }\n    setupMessageHandler() {\n        const { messageHandler, loadingTask } = this;\n        messageHandler.on(\"GetReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n            this._fullReader = this._networkStream.getFullReader();\n            this._fullReader.onProgress = (evt)=>{\n                this._lastProgress = {\n                    loaded: evt.loaded,\n                    total: evt.total\n                };\n            };\n            sink.onPull = ()=>{\n                this._fullReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                this._fullReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"ReaderHeadersReady\", async (data)=>{\n            await this._fullReader.headersReady;\n            const { isStreamingSupported, isRangeSupported, contentLength } = this._fullReader;\n            if (!isStreamingSupported || !isRangeSupported) {\n                if (this._lastProgress) {\n                    loadingTask.onProgress?.(this._lastProgress);\n                }\n                this._fullReader.onProgress = (evt)=>{\n                    loadingTask.onProgress?.({\n                        loaded: evt.loaded,\n                        total: evt.total\n                    });\n                };\n            }\n            return {\n                isStreamingSupported,\n                isRangeSupported,\n                contentLength\n            };\n        });\n        messageHandler.on(\"GetRangeReader\", (data, sink)=>{\n            assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n            const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n            if (!rangeReader) {\n                sink.close();\n                return;\n            }\n            sink.onPull = ()=>{\n                rangeReader.read().then(function({ value, done }) {\n                    if (done) {\n                        sink.close();\n                        return;\n                    }\n                    assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n                    sink.enqueue(new Uint8Array(value), 1, [\n                        value\n                    ]);\n                }).catch((reason)=>{\n                    sink.error(reason);\n                });\n            };\n            sink.onCancel = (reason)=>{\n                rangeReader.cancel(reason);\n                sink.ready.catch((readyReason)=>{\n                    if (this.destroyed) {\n                        return;\n                    }\n                    throw readyReason;\n                });\n            };\n        });\n        messageHandler.on(\"GetDoc\", ({ pdfInfo })=>{\n            this._numPages = pdfInfo.numPages;\n            this._htmlForXfa = pdfInfo.htmlForXfa;\n            delete pdfInfo.htmlForXfa;\n            loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n        });\n        messageHandler.on(\"DocException\", function(ex) {\n            let reason;\n            switch(ex.name){\n                case \"PasswordException\":\n                    reason = new PasswordException(ex.message, ex.code);\n                    break;\n                case \"InvalidPDFException\":\n                    reason = new InvalidPDFException(ex.message);\n                    break;\n                case \"MissingPDFException\":\n                    reason = new MissingPDFException(ex.message);\n                    break;\n                case \"UnexpectedResponseException\":\n                    reason = new UnexpectedResponseException(ex.message, ex.status);\n                    break;\n                case \"UnknownErrorException\":\n                    reason = new UnknownErrorException(ex.message, ex.details);\n                    break;\n                default:\n                    unreachable(\"DocException - expected a valid Error.\");\n            }\n            loadingTask._capability.reject(reason);\n        });\n        messageHandler.on(\"PasswordRequest\", (exception)=>{\n            this.#passwordCapability = Promise.withResolvers();\n            if (loadingTask.onPassword) {\n                const updatePassword = (password)=>{\n                    if (password instanceof Error) {\n                        this.#passwordCapability.reject(password);\n                    } else {\n                        this.#passwordCapability.resolve({\n                            password\n                        });\n                    }\n                };\n                try {\n                    loadingTask.onPassword(updatePassword, exception.code);\n                } catch (ex) {\n                    this.#passwordCapability.reject(ex);\n                }\n            } else {\n                this.#passwordCapability.reject(new PasswordException(exception.message, exception.code));\n            }\n            return this.#passwordCapability.promise;\n        });\n        messageHandler.on(\"DataLoaded\", (data)=>{\n            loadingTask.onProgress?.({\n                loaded: data.length,\n                total: data.length\n            });\n            this.downloadInfoCapability.resolve(data);\n        });\n        messageHandler.on(\"StartRenderPage\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            const page = this.#pageCache.get(data.pageIndex);\n            page._startRenderPage(data.transparency, data.cacheKey);\n        });\n        messageHandler.on(\"commonobj\", ([id, type, exportedData])=>{\n            if (this.destroyed) {\n                return null;\n            }\n            if (this.commonObjs.has(id)) {\n                return null;\n            }\n            switch(type){\n                case \"Font\":\n                    const { disableFontFace, fontExtraProperties, pdfBug } = this._params;\n                    if (\"error\" in exportedData) {\n                        const exportedError = exportedData.error;\n                        warn(`Error during font loading: ${exportedError}`);\n                        this.commonObjs.resolve(id, exportedError);\n                        break;\n                    }\n                    const inspectFont = pdfBug && globalThis.FontInspector?.enabled ? (font, url)=>globalThis.FontInspector.fontAdded(font, url) : null;\n                    const font = new FontFaceObject(exportedData, {\n                        disableFontFace,\n                        inspectFont\n                    });\n                    this.fontLoader.bind(font).catch(()=>messageHandler.sendWithPromise(\"FontFallback\", {\n                            id\n                        })).finally(()=>{\n                        if (!fontExtraProperties && font.data) {\n                            font.data = null;\n                        }\n                        this.commonObjs.resolve(id, font);\n                    });\n                    break;\n                case \"CopyLocalImage\":\n                    const { imageRef } = exportedData;\n                    assert(imageRef, \"The imageRef must be defined.\");\n                    for (const pageProxy of this.#pageCache.values()){\n                        for (const [, data] of pageProxy.objs){\n                            if (data?.ref !== imageRef) {\n                                continue;\n                            }\n                            if (!data.dataLen) {\n                                return null;\n                            }\n                            this.commonObjs.resolve(id, structuredClone(data));\n                            return data.dataLen;\n                        }\n                    }\n                    break;\n                case \"FontPath\":\n                case \"Image\":\n                case \"Pattern\":\n                    this.commonObjs.resolve(id, exportedData);\n                    break;\n                default:\n                    throw new Error(`Got unknown common object type ${type}`);\n            }\n            return null;\n        });\n        messageHandler.on(\"obj\", ([id, pageIndex, type, imageData])=>{\n            if (this.destroyed) {\n                return;\n            }\n            const pageProxy = this.#pageCache.get(pageIndex);\n            if (pageProxy.objs.has(id)) {\n                return;\n            }\n            if (pageProxy._intentStates.size === 0) {\n                imageData?.bitmap?.close();\n                return;\n            }\n            switch(type){\n                case \"Image\":\n                    pageProxy.objs.resolve(id, imageData);\n                    if (imageData?.dataLen > MAX_IMAGE_SIZE_TO_CACHE) {\n                        pageProxy._maybeCleanupAfterRender = true;\n                    }\n                    break;\n                case \"Pattern\":\n                    pageProxy.objs.resolve(id, imageData);\n                    break;\n                default:\n                    throw new Error(`Got unknown object type ${type}`);\n            }\n        });\n        messageHandler.on(\"DocProgress\", (data)=>{\n            if (this.destroyed) {\n                return;\n            }\n            loadingTask.onProgress?.({\n                loaded: data.loaded,\n                total: data.total\n            });\n        });\n        messageHandler.on(\"FetchBuiltInCMap\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            if (!this.cMapReaderFactory) {\n                throw new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\");\n            }\n            return this.cMapReaderFactory.fetch(data);\n        });\n        messageHandler.on(\"FetchStandardFontData\", async (data)=>{\n            if (this.destroyed) {\n                throw new Error(\"Worker was destroyed.\");\n            }\n            if (!this.standardFontDataFactory) {\n                throw new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\");\n            }\n            return this.standardFontDataFactory.fetch(data);\n        });\n    }\n    getData() {\n        return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n    saveDocument() {\n        if (this.annotationStorage.size <= 0) {\n            warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n        }\n        const { map, transfer } = this.annotationStorage.serializable;\n        return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n            isPureXfa: !!this._htmlForXfa,\n            numPages: this._numPages,\n            annotationStorage: map,\n            filename: this._fullReader?.filename ?? null\n        }, transfer).finally(()=>{\n            this.annotationStorage.resetModified();\n        });\n    }\n    getPage(pageNumber) {\n        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n            return Promise.reject(new Error(\"Invalid page request.\"));\n        }\n        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n            pageIndex\n        }).then((pageInfo)=>{\n            if (this.destroyed) {\n                throw new Error(\"Transport destroyed\");\n            }\n            if (pageInfo.refStr) {\n                this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n            }\n            const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n            this.#pageCache.set(pageIndex, page);\n            return page;\n        });\n        this.#pagePromises.set(pageIndex, promise);\n        return promise;\n    }\n    getPageIndex(ref) {\n        if (!isRefProxy(ref)) {\n            return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n            num: ref.num,\n            gen: ref.gen\n        });\n    }\n    getAnnotations(pageIndex, intent) {\n        return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n            pageIndex,\n            intent\n        });\n    }\n    getFieldObjects() {\n        return this.#cacheSimpleMethod(\"GetFieldObjects\");\n    }\n    hasJSActions() {\n        return this.#cacheSimpleMethod(\"HasJSActions\");\n    }\n    getCalculationOrderIds() {\n        return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n    }\n    getDestinations() {\n        return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n    getDestination(id) {\n        if (typeof id !== \"string\") {\n            return Promise.reject(new Error(\"Invalid destination request.\"));\n        }\n        return this.messageHandler.sendWithPromise(\"GetDestination\", {\n            id\n        });\n    }\n    getPageLabels() {\n        return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n    getPageLayout() {\n        return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n    getPageMode() {\n        return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n    getViewerPreferences() {\n        return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n    getOpenAction() {\n        return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n    getAttachments() {\n        return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n    getDocJSActions() {\n        return this.#cacheSimpleMethod(\"GetDocJSActions\");\n    }\n    getPageJSActions(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n            pageIndex\n        });\n    }\n    getStructTree(pageIndex) {\n        return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n            pageIndex\n        });\n    }\n    getOutline() {\n        return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n    getOptionalContentConfig(renderingIntent) {\n        return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then((data)=>new OptionalContentConfig(data, renderingIntent));\n    }\n    getPermissions() {\n        return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n    getMetadata() {\n        const name = \"GetMetadata\", cachedPromise = this.#methodPromises.get(name);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n        const promise = this.messageHandler.sendWithPromise(name, null).then((results)=>({\n                info: results[0],\n                metadata: results[1] ? new Metadata(results[1]) : null,\n                contentDispositionFilename: this._fullReader?.filename ?? null,\n                contentLength: this._fullReader?.contentLength ?? null\n            }));\n        this.#methodPromises.set(name, promise);\n        return promise;\n    }\n    getMarkInfo() {\n        return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n    }\n    async startCleanup(keepLoadedFonts = false) {\n        if (this.destroyed) {\n            return;\n        }\n        await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n        for (const page of this.#pageCache.values()){\n            const cleanupSuccessful = page.cleanup();\n            if (!cleanupSuccessful) {\n                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n            }\n        }\n        this.commonObjs.clear();\n        if (!keepLoadedFonts) {\n            this.fontLoader.clear();\n        }\n        this.#methodPromises.clear();\n        this.filterFactory.destroy(true);\n        TextLayer.cleanup();\n    }\n    cachedPageNumber(ref) {\n        if (!isRefProxy(ref)) {\n            return null;\n        }\n        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n        return this.#pageRefCache.get(refStr) ?? null;\n    }\n}\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n    #objs;\n    #ensureObj(objId) {\n        return this.#objs[objId] ||= {\n            ...Promise.withResolvers(),\n            data: INITIAL_DATA\n        };\n    }\n    get(objId, callback = null) {\n        if (callback) {\n            const obj = this.#ensureObj(objId);\n            obj.promise.then(()=>callback(obj.data));\n            return null;\n        }\n        const obj = this.#objs[objId];\n        if (!obj || obj.data === INITIAL_DATA) {\n            throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n        }\n        return obj.data;\n    }\n    has(objId) {\n        const obj = this.#objs[objId];\n        return !!obj && obj.data !== INITIAL_DATA;\n    }\n    resolve(objId, data = null) {\n        const obj = this.#ensureObj(objId);\n        obj.data = data;\n        obj.resolve();\n    }\n    clear() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            data?.bitmap?.close();\n        }\n        this.#objs = Object.create(null);\n    }\n    *[Symbol.iterator]() {\n        for(const objId in this.#objs){\n            const { data } = this.#objs[objId];\n            if (data === INITIAL_DATA) {\n                continue;\n            }\n            yield [\n                objId,\n                data\n            ];\n        }\n    }\n    constructor(){\n        this.#objs = Object.create(null);\n    }\n}\nclass RenderTask {\n    #internalRenderTask;\n    constructor(internalRenderTask){\n        this.#internalRenderTask = null;\n        this.#internalRenderTask = internalRenderTask;\n        this.onContinue = null;\n    }\n    get promise() {\n        return this.#internalRenderTask.capability.promise;\n    }\n    cancel(extraDelay = 0) {\n        this.#internalRenderTask.cancel(null, extraDelay);\n    }\n    get separateAnnots() {\n        const { separateAnnots } = this.#internalRenderTask.operatorList;\n        if (!separateAnnots) {\n            return false;\n        }\n        const { annotationCanvasMap } = this.#internalRenderTask;\n        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n    }\n}\nclass InternalRenderTask {\n    #rAF;\n    static #canvasInUse = new WeakSet();\n    constructor({ callback, params, objs, commonObjs, annotationCanvasMap, operatorList, pageIndex, canvasFactory, filterFactory, useRequestAnimationFrame = false, pdfBug = false, pageColors = null }){\n        this.#rAF = null;\n        this.callback = callback;\n        this.params = params;\n        this.objs = objs;\n        this.commonObjs = commonObjs;\n        this.annotationCanvasMap = annotationCanvasMap;\n        this.operatorListIdx = null;\n        this.operatorList = operatorList;\n        this._pageIndex = pageIndex;\n        this.canvasFactory = canvasFactory;\n        this.filterFactory = filterFactory;\n        this._pdfBug = pdfBug;\n        this.pageColors = pageColors;\n        this.running = false;\n        this.graphicsReadyCallback = null;\n        this.graphicsReady = false;\n        this._useRequestAnimationFrame = useRequestAnimationFrame === true && \"undefined\" !== \"undefined\";\n        this.cancelled = false;\n        this.capability = Promise.withResolvers();\n        this.task = new RenderTask(this);\n        this._cancelBound = this.cancel.bind(this);\n        this._continueBound = this._continue.bind(this);\n        this._scheduleNextBound = this._scheduleNext.bind(this);\n        this._nextBound = this._next.bind(this);\n        this._canvas = params.canvasContext.canvas;\n    }\n    get completed() {\n        return this.capability.promise.catch(function() {});\n    }\n    initializeGraphics({ transparency = false, optionalContentConfig }) {\n        if (this.cancelled) {\n            return;\n        }\n        if (this._canvas) {\n            if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n                throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n            }\n            InternalRenderTask.#canvasInUse.add(this._canvas);\n        }\n        if (this._pdfBug && globalThis.StepperManager?.enabled) {\n            this.stepper = globalThis.StepperManager.create(this._pageIndex);\n            this.stepper.init(this.operatorList);\n            this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n        const { canvasContext, viewport, transform, background } = this.params;\n        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig\n        }, this.annotationCanvasMap, this.pageColors);\n        this.gfx.beginDrawing({\n            transform,\n            viewport,\n            transparency,\n            background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n        this.graphicsReadyCallback?.();\n    }\n    cancel(error = null, extraDelay = 0) {\n        this.running = false;\n        this.cancelled = true;\n        this.gfx?.endDrawing();\n        if (this.#rAF) {\n            window.cancelAnimationFrame(this.#rAF);\n            this.#rAF = null;\n        }\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback(error || new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n    }\n    operatorListChanged() {\n        if (!this.graphicsReady) {\n            this.graphicsReadyCallback ||= this._continueBound;\n            return;\n        }\n        this.stepper?.updateOperatorList(this.operatorList);\n        if (this.running) {\n            return;\n        }\n        this._continue();\n    }\n    _continue() {\n        this.running = true;\n        if (this.cancelled) {\n            return;\n        }\n        if (this.task.onContinue) {\n            this.task.onContinue(this._scheduleNextBound);\n        } else {\n            this._scheduleNext();\n        }\n    }\n    _scheduleNext() {\n        if (this._useRequestAnimationFrame) {\n            this.#rAF = window.requestAnimationFrame(()=>{\n                this.#rAF = null;\n                this._nextBound().catch(this._cancelBound);\n            });\n        } else {\n            Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n        }\n    }\n    async _next() {\n        if (this.cancelled) {\n            return;\n        }\n        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n        if (this.operatorListIdx === this.operatorList.argsArray.length) {\n            this.running = false;\n            if (this.operatorList.lastChunk) {\n                this.gfx.endDrawing();\n                InternalRenderTask.#canvasInUse.delete(this._canvas);\n                this.callback();\n            }\n        }\n    }\n}\nconst version = \"4.8.69\";\nconst build = \"3634dab10\";\n; // ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n    return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n    return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n    static CMYK_G([c, y, m, k]) {\n        return [\n            \"G\",\n            1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)\n        ];\n    }\n    static G_CMYK([g]) {\n        return [\n            \"CMYK\",\n            0,\n            0,\n            0,\n            1 - g\n        ];\n    }\n    static G_RGB([g]) {\n        return [\n            \"RGB\",\n            g,\n            g,\n            g\n        ];\n    }\n    static G_rgb([g]) {\n        g = scaleAndClamp(g);\n        return [\n            g,\n            g,\n            g\n        ];\n    }\n    static G_HTML([g]) {\n        const G = makeColorComp(g);\n        return `#${G}${G}${G}`;\n    }\n    static RGB_G([r, g, b]) {\n        return [\n            \"G\",\n            0.3 * r + 0.59 * g + 0.11 * b\n        ];\n    }\n    static RGB_rgb(color) {\n        return color.map(scaleAndClamp);\n    }\n    static RGB_HTML(color) {\n        return `#${color.map(makeColorComp).join(\"\")}`;\n    }\n    static T_HTML() {\n        return \"#00000000\";\n    }\n    static T_rgb() {\n        return [\n            null\n        ];\n    }\n    static CMYK_RGB([c, y, m, k]) {\n        return [\n            \"RGB\",\n            1 - Math.min(1, c + k),\n            1 - Math.min(1, m + k),\n            1 - Math.min(1, y + k)\n        ];\n    }\n    static CMYK_rgb([c, y, m, k]) {\n        return [\n            scaleAndClamp(1 - Math.min(1, c + k)),\n            scaleAndClamp(1 - Math.min(1, m + k)),\n            scaleAndClamp(1 - Math.min(1, y + k))\n        ];\n    }\n    static CMYK_HTML(components) {\n        const rgb = this.CMYK_RGB(components).slice(1);\n        return this.RGB_HTML(rgb);\n    }\n    static RGB_CMYK([r, g, b]) {\n        const c = 1 - r;\n        const m = 1 - g;\n        const y = 1 - b;\n        const k = Math.min(c, m, y);\n        return [\n            \"CMYK\",\n            c,\n            m,\n            y,\n            k\n        ];\n    }\n}\n; // ./src/display/svg_factory.js\nclass BaseSVGFactory {\n    create(width, height, skipDimensions = false) {\n        if (width <= 0 || height <= 0) {\n            throw new Error(\"Invalid SVG dimensions\");\n        }\n        const svg = this._createSVG(\"svg:svg\");\n        svg.setAttribute(\"version\", \"1.1\");\n        if (!skipDimensions) {\n            svg.setAttribute(\"width\", `${width}px`);\n            svg.setAttribute(\"height\", `${height}px`);\n        }\n        svg.setAttribute(\"preserveAspectRatio\", \"none\");\n        svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n        return svg;\n    }\n    createElement(type) {\n        if (typeof type !== \"string\") {\n            throw new Error(\"Invalid SVG element type\");\n        }\n        return this._createSVG(type);\n    }\n    _createSVG(type) {\n        unreachable(\"Abstract method `_createSVG` called.\");\n    }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n    _createSVG(type) {\n        return document.createElementNS(SVG_NS, type);\n    }\n}\n; // ./src/display/xfa_layer.js\nclass XfaLayer {\n    static setupStorage(html, id, element, storage, intent) {\n        const storedData = storage.getValue(id, {\n            value: null\n        });\n        switch(element.name){\n            case \"textarea\":\n                if (storedData.value !== null) {\n                    html.textContent = storedData.value;\n                }\n                if (intent === \"print\") {\n                    break;\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    storage.setValue(id, {\n                        value: event.target.value\n                    });\n                });\n                break;\n            case \"input\":\n                if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n                    if (storedData.value === element.attributes.xfaOn) {\n                        html.setAttribute(\"checked\", true);\n                    } else if (storedData.value === element.attributes.xfaOff) {\n                        html.removeAttribute(\"checked\");\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"change\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n                        });\n                    });\n                } else {\n                    if (storedData.value !== null) {\n                        html.setAttribute(\"value\", storedData.value);\n                    }\n                    if (intent === \"print\") {\n                        break;\n                    }\n                    html.addEventListener(\"input\", (event)=>{\n                        storage.setValue(id, {\n                            value: event.target.value\n                        });\n                    });\n                }\n                break;\n            case \"select\":\n                if (storedData.value !== null) {\n                    html.setAttribute(\"value\", storedData.value);\n                    for (const option of element.children){\n                        if (option.attributes.value === storedData.value) {\n                            option.attributes.selected = true;\n                        } else if (option.attributes.hasOwnProperty(\"selected\")) {\n                            delete option.attributes.selected;\n                        }\n                    }\n                }\n                html.addEventListener(\"input\", (event)=>{\n                    const options = event.target.options;\n                    const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n                    storage.setValue(id, {\n                        value\n                    });\n                });\n                break;\n        }\n    }\n    static setAttributes({ html, element, storage = null, intent, linkService }) {\n        const { attributes } = element;\n        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n        if (attributes.type === \"radio\") {\n            attributes.name = `${attributes.name}-${intent}`;\n        }\n        for (const [key, value] of Object.entries(attributes)){\n            if (value === null || value === undefined) {\n                continue;\n            }\n            switch(key){\n                case \"class\":\n                    if (value.length) {\n                        html.setAttribute(key, value.join(\" \"));\n                    }\n                    break;\n                case \"dataId\":\n                    break;\n                case \"id\":\n                    html.setAttribute(\"data-element-id\", value);\n                    break;\n                case \"style\":\n                    Object.assign(html.style, value);\n                    break;\n                case \"textContent\":\n                    html.textContent = value;\n                    break;\n                default:\n                    if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n                        html.setAttribute(key, value);\n                    }\n            }\n        }\n        if (isHTMLAnchorElement) {\n            linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n        }\n        if (storage && attributes.dataId) {\n            this.setupStorage(html, attributes.dataId, element, storage);\n        }\n    }\n    static render(parameters) {\n        const storage = parameters.annotationStorage;\n        const linkService = parameters.linkService;\n        const root = parameters.xfaHtml;\n        const intent = parameters.intent || \"display\";\n        const rootHtml = document.createElement(root.name);\n        if (root.attributes) {\n            this.setAttributes({\n                html: rootHtml,\n                element: root,\n                intent,\n                linkService\n            });\n        }\n        const isNotForRichText = intent !== \"richText\";\n        const rootDiv = parameters.div;\n        rootDiv.append(rootHtml);\n        if (parameters.viewport) {\n            const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n            rootDiv.style.transform = transform;\n        }\n        if (isNotForRichText) {\n            rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n        }\n        const textDivs = [];\n        if (root.children.length === 0) {\n            if (root.value) {\n                const node = document.createTextNode(root.value);\n                rootHtml.append(node);\n                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n                    textDivs.push(node);\n                }\n            }\n            return {\n                textDivs\n            };\n        }\n        const stack = [\n            [\n                root,\n                -1,\n                rootHtml\n            ]\n        ];\n        while(stack.length > 0){\n            const [parent, i, html] = stack.at(-1);\n            if (i + 1 === parent.children.length) {\n                stack.pop();\n                continue;\n            }\n            const child = parent.children[++stack.at(-1)[1]];\n            if (child === null) {\n                continue;\n            }\n            const { name } = child;\n            if (name === \"#text\") {\n                const node = document.createTextNode(child.value);\n                textDivs.push(node);\n                html.append(node);\n                continue;\n            }\n            const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n            html.append(childHtml);\n            if (child.attributes) {\n                this.setAttributes({\n                    html: childHtml,\n                    element: child,\n                    storage,\n                    intent,\n                    linkService\n                });\n            }\n            if (child.children?.length > 0) {\n                stack.push([\n                    child,\n                    -1,\n                    childHtml\n                ]);\n            } else if (child.value) {\n                const node = document.createTextNode(child.value);\n                if (isNotForRichText && XfaText.shouldBuildText(name)) {\n                    textDivs.push(node);\n                }\n                childHtml.append(node);\n            }\n        }\n        for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")){\n            el.setAttribute(\"readOnly\", true);\n        }\n        return {\n            textDivs\n        };\n    }\n    static update(parameters) {\n        const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n        parameters.div.style.transform = transform;\n        parameters.div.hidden = false;\n    }\n}\n; // ./src/display/annotation_layer.js\nconst DEFAULT_TAB_INDEX = 1000;\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nfunction getRectDims(rect) {\n    return {\n        width: rect[2] - rect[0],\n        height: rect[3] - rect[1]\n    };\n}\nclass AnnotationElementFactory {\n    static create(parameters) {\n        const subtype = parameters.data.annotationType;\n        switch(subtype){\n            case AnnotationType.LINK:\n                return new LinkAnnotationElement(parameters);\n            case AnnotationType.TEXT:\n                return new TextAnnotationElement(parameters);\n            case AnnotationType.WIDGET:\n                const fieldType = parameters.data.fieldType;\n                switch(fieldType){\n                    case \"Tx\":\n                        return new TextWidgetAnnotationElement(parameters);\n                    case \"Btn\":\n                        if (parameters.data.radioButton) {\n                            return new RadioButtonWidgetAnnotationElement(parameters);\n                        } else if (parameters.data.checkBox) {\n                            return new CheckboxWidgetAnnotationElement(parameters);\n                        }\n                        return new PushButtonWidgetAnnotationElement(parameters);\n                    case \"Ch\":\n                        return new ChoiceWidgetAnnotationElement(parameters);\n                    case \"Sig\":\n                        return new SignatureWidgetAnnotationElement(parameters);\n                }\n                return new WidgetAnnotationElement(parameters);\n            case AnnotationType.POPUP:\n                return new PopupAnnotationElement(parameters);\n            case AnnotationType.FREETEXT:\n                return new FreeTextAnnotationElement(parameters);\n            case AnnotationType.LINE:\n                return new LineAnnotationElement(parameters);\n            case AnnotationType.SQUARE:\n                return new SquareAnnotationElement(parameters);\n            case AnnotationType.CIRCLE:\n                return new CircleAnnotationElement(parameters);\n            case AnnotationType.POLYLINE:\n                return new PolylineAnnotationElement(parameters);\n            case AnnotationType.CARET:\n                return new CaretAnnotationElement(parameters);\n            case AnnotationType.INK:\n                return new InkAnnotationElement(parameters);\n            case AnnotationType.POLYGON:\n                return new PolygonAnnotationElement(parameters);\n            case AnnotationType.HIGHLIGHT:\n                return new HighlightAnnotationElement(parameters);\n            case AnnotationType.UNDERLINE:\n                return new UnderlineAnnotationElement(parameters);\n            case AnnotationType.SQUIGGLY:\n                return new SquigglyAnnotationElement(parameters);\n            case AnnotationType.STRIKEOUT:\n                return new StrikeOutAnnotationElement(parameters);\n            case AnnotationType.STAMP:\n                return new StampAnnotationElement(parameters);\n            case AnnotationType.FILEATTACHMENT:\n                return new FileAttachmentAnnotationElement(parameters);\n            default:\n                return new AnnotationElement(parameters);\n        }\n    }\n}\nclass AnnotationElement {\n    #updates;\n    #hasBorder;\n    #popupElement;\n    constructor(parameters, { isRenderable = false, ignoreBorder = false, createQuadrilaterals = false } = {}){\n        this.#updates = null;\n        this.#hasBorder = false;\n        this.#popupElement = null;\n        this.isRenderable = isRenderable;\n        this.data = parameters.data;\n        this.layer = parameters.layer;\n        this.linkService = parameters.linkService;\n        this.downloadManager = parameters.downloadManager;\n        this.imageResourcesPath = parameters.imageResourcesPath;\n        this.renderForms = parameters.renderForms;\n        this.svgFactory = parameters.svgFactory;\n        this.annotationStorage = parameters.annotationStorage;\n        this.enableScripting = parameters.enableScripting;\n        this.hasJSActions = parameters.hasJSActions;\n        this._fieldObjects = parameters.fieldObjects;\n        this.parent = parameters.parent;\n        if (isRenderable) {\n            this.container = this._createContainer(ignoreBorder);\n        }\n        if (createQuadrilaterals) {\n            this._createQuadrilaterals();\n        }\n    }\n    static _hasPopupData({ titleObj, contentsObj, richText }) {\n        return !!(titleObj?.str || contentsObj?.str || richText?.str);\n    }\n    get _isEditable() {\n        return this.data.isEditable;\n    }\n    get hasPopupData() {\n        return AnnotationElement._hasPopupData(this.data);\n    }\n    updateEdited(params) {\n        if (!this.container) {\n            return;\n        }\n        this.#updates ||= {\n            rect: this.data.rect.slice(0)\n        };\n        const { rect } = params;\n        if (rect) {\n            this.#setRectEdited(rect);\n        }\n        this.#popupElement?.popup.updateEdited(params);\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        this.#setRectEdited(this.#updates.rect);\n        this.#popupElement?.popup.resetEdited();\n        this.#updates = null;\n    }\n    #setRectEdited(rect) {\n        const { container: { style }, data: { rect: currentRect, rotation }, parent: { viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } } = this;\n        currentRect?.splice(0, 4, ...rect);\n        const { width, height } = getRectDims(rect);\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n        if (rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation);\n        }\n    }\n    _createContainer(ignoreBorder) {\n        const { data, parent: { page, viewport } } = this;\n        const container = document.createElement(\"section\");\n        container.setAttribute(\"data-annotation-id\", data.id);\n        if (!(this instanceof WidgetAnnotationElement)) {\n            container.tabIndex = DEFAULT_TAB_INDEX;\n        }\n        const { style } = container;\n        style.zIndex = this.parent.zIndex++;\n        if (data.alternativeText) {\n            container.title = data.alternativeText;\n        }\n        if (data.noRotate) {\n            container.classList.add(\"norotate\");\n        }\n        if (!data.rect || this instanceof PopupAnnotationElement) {\n            const { rotation } = data;\n            if (!data.hasOwnCanvas && rotation !== 0) {\n                this.setRotation(rotation, container);\n            }\n            return container;\n        }\n        const { width, height } = getRectDims(data.rect);\n        if (!ignoreBorder && data.borderStyle.width > 0) {\n            style.borderWidth = `${data.borderStyle.width}px`;\n            const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n            const verticalRadius = data.borderStyle.verticalCornerRadius;\n            if (horizontalRadius > 0 || verticalRadius > 0) {\n                const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n                style.borderRadius = radius;\n            } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n                const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n                style.borderRadius = radius;\n            }\n            switch(data.borderStyle.style){\n                case AnnotationBorderStyleType.SOLID:\n                    style.borderStyle = \"solid\";\n                    break;\n                case AnnotationBorderStyleType.DASHED:\n                    style.borderStyle = \"dashed\";\n                    break;\n                case AnnotationBorderStyleType.BEVELED:\n                    warn(\"Unimplemented border style: beveled\");\n                    break;\n                case AnnotationBorderStyleType.INSET:\n                    warn(\"Unimplemented border style: inset\");\n                    break;\n                case AnnotationBorderStyleType.UNDERLINE:\n                    style.borderBottomStyle = \"solid\";\n                    break;\n                default:\n                    break;\n            }\n            const borderColor = data.borderColor || null;\n            if (borderColor) {\n                this.#hasBorder = true;\n                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n            } else {\n                style.borderWidth = 0;\n            }\n        }\n        const rect = Util.normalizeRect([\n            data.rect[0],\n            page.view[3] - data.rect[1] + page.view[1],\n            data.rect[2],\n            page.view[3] - data.rect[3] + page.view[1]\n        ]);\n        const { pageWidth, pageHeight, pageX, pageY } = viewport.rawDims;\n        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n        const { rotation } = data;\n        if (data.hasOwnCanvas || rotation === 0) {\n            style.width = `${100 * width / pageWidth}%`;\n            style.height = `${100 * height / pageHeight}%`;\n        } else {\n            this.setRotation(rotation, container);\n        }\n        return container;\n    }\n    setRotation(angle, container = this.container) {\n        if (!this.data.rect) {\n            return;\n        }\n        const { pageWidth, pageHeight } = this.parent.viewport.rawDims;\n        const { width, height } = getRectDims(this.data.rect);\n        let elementWidth, elementHeight;\n        if (angle % 180 === 0) {\n            elementWidth = 100 * width / pageWidth;\n            elementHeight = 100 * height / pageHeight;\n        } else {\n            elementWidth = 100 * height / pageWidth;\n            elementHeight = 100 * width / pageHeight;\n        }\n        container.style.width = `${elementWidth}%`;\n        container.style.height = `${elementHeight}%`;\n        container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n    }\n    get _commonActions() {\n        const setColor = (jsName, styleName, event)=>{\n            const color = event.detail[jsName];\n            const colorType = color[0];\n            const colorArray = color.slice(1);\n            event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n            this.annotationStorage.setValue(this.data.id, {\n                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n            });\n        };\n        return shadow(this, \"_commonActions\", {\n            display: (event)=>{\n                const { display } = event.detail;\n                const hidden = display % 2 === 1;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noView: hidden,\n                    noPrint: display === 1 || display === 2\n                });\n            },\n            print: (event)=>{\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: !event.detail.print\n                });\n            },\n            hidden: (event)=>{\n                const { hidden } = event.detail;\n                this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n                this.annotationStorage.setValue(this.data.id, {\n                    noPrint: hidden,\n                    noView: hidden\n                });\n            },\n            focus: (event)=>{\n                setTimeout(()=>event.target.focus({\n                        preventScroll: false\n                    }), 0);\n            },\n            userName: (event)=>{\n                event.target.title = event.detail.userName;\n            },\n            readonly: (event)=>{\n                event.target.disabled = event.detail.readonly;\n            },\n            required: (event)=>{\n                this._setRequired(event.target, event.detail.required);\n            },\n            bgColor: (event)=>{\n                setColor(\"bgColor\", \"backgroundColor\", event);\n            },\n            fillColor: (event)=>{\n                setColor(\"fillColor\", \"backgroundColor\", event);\n            },\n            fgColor: (event)=>{\n                setColor(\"fgColor\", \"color\", event);\n            },\n            textColor: (event)=>{\n                setColor(\"textColor\", \"color\", event);\n            },\n            borderColor: (event)=>{\n                setColor(\"borderColor\", \"borderColor\", event);\n            },\n            strokeColor: (event)=>{\n                setColor(\"strokeColor\", \"borderColor\", event);\n            },\n            rotation: (event)=>{\n                const angle = event.detail.rotation;\n                this.setRotation(angle);\n                this.annotationStorage.setValue(this.data.id, {\n                    rotation: angle\n                });\n            }\n        });\n    }\n    _dispatchEventFromSandbox(actions, jsEvent) {\n        const commonActions = this._commonActions;\n        for (const name of Object.keys(jsEvent.detail)){\n            const action = actions[name] || commonActions[name];\n            action?.(jsEvent);\n        }\n    }\n    _setDefaultPropertiesFromJS(element) {\n        if (!this.enableScripting) {\n            return;\n        }\n        const storedData = this.annotationStorage.getRawValue(this.data.id);\n        if (!storedData) {\n            return;\n        }\n        const commonActions = this._commonActions;\n        for (const [actionName, detail] of Object.entries(storedData)){\n            const action = commonActions[actionName];\n            if (action) {\n                const eventProxy = {\n                    detail: {\n                        [actionName]: detail\n                    },\n                    target: element\n                };\n                action(eventProxy);\n                delete storedData[actionName];\n            }\n        }\n    }\n    _createQuadrilaterals() {\n        if (!this.container) {\n            return;\n        }\n        const { quadPoints } = this.data;\n        if (!quadPoints) {\n            return;\n        }\n        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x)=>Math.fround(x));\n        if (quadPoints.length === 8) {\n            const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n            if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n                return;\n            }\n        }\n        const { style } = this.container;\n        let svgBuffer;\n        if (this.#hasBorder) {\n            const { borderColor, borderWidth } = style;\n            style.borderWidth = 0;\n            svgBuffer = [\n                \"url('data:image/svg+xml;utf8,\",\n                `<svg xmlns=\"http://www.w3.org/2000/svg\"`,\n                ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`,\n                `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`\n            ];\n            this.container.classList.add(\"hasBorder\");\n        }\n        const width = rectTrX - rectBlX;\n        const height = rectTrY - rectBlY;\n        const { svgFactory } = this;\n        const svg = svgFactory.createElement(\"svg\");\n        svg.classList.add(\"quadrilateralsContainer\");\n        svg.setAttribute(\"width\", 0);\n        svg.setAttribute(\"height\", 0);\n        const defs = svgFactory.createElement(\"defs\");\n        svg.append(defs);\n        const clipPath = svgFactory.createElement(\"clipPath\");\n        const id = `clippath_${this.data.id}`;\n        clipPath.setAttribute(\"id\", id);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        defs.append(clipPath);\n        for(let i = 2, ii = quadPoints.length; i < ii; i += 8){\n            const trX = quadPoints[i];\n            const trY = quadPoints[i + 1];\n            const blX = quadPoints[i + 2];\n            const blY = quadPoints[i + 3];\n            const rect = svgFactory.createElement(\"rect\");\n            const x = (blX - rectBlX) / width;\n            const y = (rectTrY - trY) / height;\n            const rectWidth = (trX - blX) / width;\n            const rectHeight = (trY - blY) / height;\n            rect.setAttribute(\"x\", x);\n            rect.setAttribute(\"y\", y);\n            rect.setAttribute(\"width\", rectWidth);\n            rect.setAttribute(\"height\", rectHeight);\n            clipPath.append(rect);\n            svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n        }\n        if (this.#hasBorder) {\n            svgBuffer.push(`</g></svg>')`);\n            style.backgroundImage = svgBuffer.join(\"\");\n        }\n        this.container.append(svg);\n        this.container.style.clipPath = `url(#${id})`;\n    }\n    _createPopup() {\n        const { data } = this;\n        const popup = this.#popupElement = new PopupAnnotationElement({\n            data: {\n                color: data.color,\n                titleObj: data.titleObj,\n                modificationDate: data.modificationDate,\n                contentsObj: data.contentsObj,\n                richText: data.richText,\n                parentRect: data.rect,\n                borderStyle: 0,\n                id: `popup_${data.id}`,\n                rotation: data.rotation\n            },\n            parent: this.parent,\n            elements: [\n                this\n            ]\n        });\n        this.parent.div.append(popup.render());\n    }\n    render() {\n        unreachable(\"Abstract method `AnnotationElement.render` called\");\n    }\n    _getElementsByName(name, skipId = null) {\n        const fields = [];\n        if (this._fieldObjects) {\n            const fieldObj = this._fieldObjects[name];\n            if (fieldObj) {\n                for (const { page, id, exportValues } of fieldObj){\n                    if (page === -1) {\n                        continue;\n                    }\n                    if (id === skipId) {\n                        continue;\n                    }\n                    const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n                    const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                    if (domElement && !GetElementsByNameSet.has(domElement)) {\n                        warn(`_getElementsByName - element not allowed: ${id}`);\n                        continue;\n                    }\n                    fields.push({\n                        id,\n                        exportValue,\n                        domElement\n                    });\n                }\n            }\n            return fields;\n        }\n        for (const domElement of document.getElementsByName(name)){\n            const { exportValue } = domElement;\n            const id = domElement.getAttribute(\"data-element-id\");\n            if (id === skipId) {\n                continue;\n            }\n            if (!GetElementsByNameSet.has(domElement)) {\n                continue;\n            }\n            fields.push({\n                id,\n                exportValue,\n                domElement\n            });\n        }\n        return fields;\n    }\n    show() {\n        if (this.container) {\n            this.container.hidden = false;\n        }\n        this.popup?.maybeShow();\n    }\n    hide() {\n        if (this.container) {\n            this.container.hidden = true;\n        }\n        this.popup?.forceHide();\n    }\n    getElementsToTriggerPopup() {\n        return this.container;\n    }\n    addHighlightArea() {\n        const triggers = this.getElementsToTriggerPopup();\n        if (Array.isArray(triggers)) {\n            for (const element of triggers){\n                element.classList.add(\"highlightArea\");\n            }\n        } else {\n            triggers.classList.add(\"highlightArea\");\n        }\n    }\n    _editOnDoubleClick() {\n        if (!this._isEditable) {\n            return;\n        }\n        const { annotationEditorType: mode, data: { id: editId } } = this;\n        this.container.addEventListener(\"dblclick\", ()=>{\n            this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n                source: this,\n                mode,\n                editId\n            });\n        });\n    }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n    constructor(parameters, options = null){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: !!options?.ignoreBorder,\n            createQuadrilaterals: true\n        });\n        this.isTooltipOnly = parameters.data.isTooltipOnly;\n    }\n    render() {\n        const { data, linkService } = this;\n        const link = document.createElement(\"a\");\n        link.setAttribute(\"data-element-id\", data.id);\n        let isBound = false;\n        if (data.url) {\n            linkService.addLinkAttributes(link, data.url, data.newWindow);\n            isBound = true;\n        } else if (data.action) {\n            this._bindNamedAction(link, data.action);\n            isBound = true;\n        } else if (data.attachment) {\n            this.#bindAttachment(link, data.attachment, data.attachmentDest);\n            isBound = true;\n        } else if (data.setOCGState) {\n            this.#bindSetOCGState(link, data.setOCGState);\n            isBound = true;\n        } else if (data.dest) {\n            this._bindLink(link, data.dest);\n            isBound = true;\n        } else {\n            if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n                this._bindJSAction(link, data);\n                isBound = true;\n            }\n            if (data.resetForm) {\n                this._bindResetFormAction(link, data.resetForm);\n                isBound = true;\n            } else if (this.isTooltipOnly && !isBound) {\n                this._bindLink(link, \"\");\n                isBound = true;\n            }\n        }\n        this.container.classList.add(\"linkAnnotation\");\n        if (isBound) {\n            this.container.append(link);\n        }\n        return this.container;\n    }\n    #setInternalLink() {\n        this.container.setAttribute(\"data-internal-link\", \"\");\n    }\n    _bindLink(link, destination) {\n        link.href = this.linkService.getDestinationHash(destination);\n        link.onclick = ()=>{\n            if (destination) {\n                this.linkService.goToDestination(destination);\n            }\n            return false;\n        };\n        if (destination || destination === \"\") {\n            this.#setInternalLink();\n        }\n    }\n    _bindNamedAction(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeNamedAction(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindAttachment(link, attachment, dest = null) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        if (attachment.description) {\n            link.title = attachment.description;\n        }\n        link.onclick = ()=>{\n            this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    #bindSetOCGState(link, action) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        link.onclick = ()=>{\n            this.linkService.executeSetOCGState(action);\n            return false;\n        };\n        this.#setInternalLink();\n    }\n    _bindJSAction(link, data) {\n        link.href = this.linkService.getAnchorUrl(\"\");\n        const map = new Map([\n            [\n                \"Action\",\n                \"onclick\"\n            ],\n            [\n                \"Mouse Up\",\n                \"onmouseup\"\n            ],\n            [\n                \"Mouse Down\",\n                \"onmousedown\"\n            ]\n        ]);\n        for (const name of Object.keys(data.actions)){\n            const jsName = map.get(name);\n            if (!jsName) {\n                continue;\n            }\n            link[jsName] = ()=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: data.id,\n                        name\n                    }\n                });\n                return false;\n            };\n        }\n        if (!link.onclick) {\n            link.onclick = ()=>false;\n        }\n        this.#setInternalLink();\n    }\n    _bindResetFormAction(link, resetForm) {\n        const otherClickAction = link.onclick;\n        if (!otherClickAction) {\n            link.href = this.linkService.getAnchorUrl(\"\");\n        }\n        this.#setInternalLink();\n        if (!this._fieldObjects) {\n            warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n            if (!otherClickAction) {\n                link.onclick = ()=>false;\n            }\n            return;\n        }\n        link.onclick = ()=>{\n            otherClickAction?.();\n            const { fields: resetFormFields, refs: resetFormRefs, include } = resetForm;\n            const allFields = [];\n            if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n                const fieldIds = new Set(resetFormRefs);\n                for (const fieldName of resetFormFields){\n                    const fields = this._fieldObjects[fieldName] || [];\n                    for (const { id } of fields){\n                        fieldIds.add(id);\n                    }\n                }\n                for (const fields of Object.values(this._fieldObjects)){\n                    for (const field of fields){\n                        if (fieldIds.has(field.id) === include) {\n                            allFields.push(field);\n                        }\n                    }\n                }\n            } else {\n                for (const fields of Object.values(this._fieldObjects)){\n                    allFields.push(...fields);\n                }\n            }\n            const storage = this.annotationStorage;\n            const allIds = [];\n            for (const field of allFields){\n                const { id } = field;\n                allIds.push(id);\n                switch(field.type){\n                    case \"text\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"checkbox\":\n                    case \"radiobutton\":\n                        {\n                            const value = field.defaultValue === field.exportValues;\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    case \"combobox\":\n                    case \"listbox\":\n                        {\n                            const value = field.defaultValue || \"\";\n                            storage.setValue(id, {\n                                value\n                            });\n                            break;\n                        }\n                    default:\n                        continue;\n                }\n                const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n                if (!domElement) {\n                    continue;\n                } else if (!GetElementsByNameSet.has(domElement)) {\n                    warn(`_bindResetFormAction - element not allowed: ${id}`);\n                    continue;\n                }\n                domElement.dispatchEvent(new Event(\"resetform\"));\n            }\n            if (this.enableScripting) {\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: \"app\",\n                        ids: allIds,\n                        name: \"ResetForm\"\n                    }\n                });\n            }\n            return false;\n        };\n    }\n}\nclass TextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"textAnnotation\");\n        const image = document.createElement(\"img\");\n        image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n        image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n        image.setAttribute(\"data-l10n-args\", JSON.stringify({\n            type: this.data.name\n        }));\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(image);\n        return this.container;\n    }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n    render() {\n        return this.container;\n    }\n    showElementAndHideCanvas(element) {\n        if (this.data.hasOwnCanvas) {\n            if (element.previousSibling?.nodeName === \"CANVAS\") {\n                element.previousSibling.hidden = true;\n            }\n            element.hidden = false;\n        }\n    }\n    _getKeyModifier(event) {\n        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n    }\n    _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n        if (baseName.includes(\"mouse\")) {\n            element.addEventListener(baseName, (event)=>{\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event),\n                        shift: event.shiftKey,\n                        modifier: this._getKeyModifier(event)\n                    }\n                });\n            });\n        } else {\n            element.addEventListener(baseName, (event)=>{\n                if (baseName === \"blur\") {\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    elementData.focused = false;\n                } else if (baseName === \"focus\") {\n                    if (elementData.focused) {\n                        return;\n                    }\n                    elementData.focused = true;\n                }\n                if (!valueGetter) {\n                    return;\n                }\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id: this.data.id,\n                        name: eventName,\n                        value: valueGetter(event)\n                    }\n                });\n            });\n        }\n    }\n    _setEventListeners(element, elementData, names, getter) {\n        for (const [baseName, eventName] of names){\n            if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n                if (eventName === \"Focus\" || eventName === \"Blur\") {\n                    elementData ||= {\n                        focused: false\n                    };\n                }\n                this._setEventListener(element, elementData, baseName, eventName, getter);\n                if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n                    this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n                } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n                    this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n                }\n            }\n        }\n    }\n    _setBackgroundColor(element) {\n        const color = this.data.backgroundColor || null;\n        element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n    }\n    _setTextStyle(element) {\n        const TEXT_ALIGNMENT = [\n            \"left\",\n            \"center\",\n            \"right\"\n        ];\n        const { fontColor } = this.data.defaultAppearanceData;\n        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n        const style = element.style;\n        let computedFontSize;\n        const BORDER_SIZE = 2;\n        const roundToOneDecimal = (x)=>Math.round(10 * x) / 10;\n        if (this.data.multiLine) {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n            const lineHeight = height / numberOfLines;\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n        } else {\n            const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n            computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n        }\n        style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n        if (this.data.textAlignment !== null) {\n            style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n        }\n    }\n    _setRequired(element, isRequired) {\n        if (isRequired) {\n            element.setAttribute(\"required\", true);\n        } else {\n            element.removeAttribute(\"required\");\n        }\n        element.setAttribute(\"aria-required\", isRequired);\n    }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n        super(parameters, {\n            isRenderable\n        });\n    }\n    setPropertyOnSiblings(base, key, value, keyInStorage) {\n        const storage = this.annotationStorage;\n        for (const element of this._getElementsByName(base.name, base.id)){\n            if (element.domElement) {\n                element.domElement[key] = value;\n            }\n            storage.setValue(element.id, {\n                [keyInStorage]: value\n            });\n        }\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        this.container.classList.add(\"textWidgetAnnotation\");\n        let element = null;\n        if (this.renderForms) {\n            const storedData = storage.getValue(id, {\n                value: this.data.fieldValue\n            });\n            let textContent = storedData.value || \"\";\n            const maxLen = storage.getValue(id, {\n                charLimit: this.data.maxLen\n            }).charLimit;\n            if (maxLen && textContent.length > maxLen) {\n                textContent = textContent.slice(0, maxLen);\n            }\n            let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n            if (fieldFormattedValues && this.data.comb) {\n                fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n            }\n            const elementData = {\n                userValue: textContent,\n                formattedValue: fieldFormattedValues,\n                lastCommittedValue: null,\n                commitKey: 1,\n                focused: false\n            };\n            if (this.data.multiLine) {\n                element = document.createElement(\"textarea\");\n                element.textContent = fieldFormattedValues ?? textContent;\n                if (this.data.doNotScroll) {\n                    element.style.overflowY = \"hidden\";\n                }\n            } else {\n                element = document.createElement(\"input\");\n                element.type = \"text\";\n                element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n                if (this.data.doNotScroll) {\n                    element.style.overflowX = \"hidden\";\n                }\n            }\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n            GetElementsByNameSet.add(element);\n            element.setAttribute(\"data-element-id\", id);\n            element.disabled = this.data.readOnly;\n            element.name = this.data.fieldName;\n            element.tabIndex = DEFAULT_TAB_INDEX;\n            this._setRequired(element, this.data.required);\n            if (maxLen) {\n                element.maxLength = maxLen;\n            }\n            element.addEventListener(\"input\", (event)=>{\n                storage.setValue(id, {\n                    value: event.target.value\n                });\n                this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n                elementData.formattedValue = null;\n            });\n            element.addEventListener(\"resetform\", (event)=>{\n                const defaultValue = this.data.defaultFieldValue ?? \"\";\n                element.value = elementData.userValue = defaultValue;\n                elementData.formattedValue = null;\n            });\n            let blurListener = (event)=>{\n                const { formattedValue } = elementData;\n                if (formattedValue !== null && formattedValue !== undefined) {\n                    event.target.value = formattedValue;\n                }\n                event.target.scrollLeft = 0;\n            };\n            if (this.enableScripting && this.hasJSActions) {\n                element.addEventListener(\"focus\", (event)=>{\n                    if (elementData.focused) {\n                        return;\n                    }\n                    const { target } = event;\n                    if (elementData.userValue) {\n                        target.value = elementData.userValue;\n                    }\n                    elementData.lastCommittedValue = target.value;\n                    elementData.commitKey = 1;\n                    if (!this.data.actions?.Focus) {\n                        elementData.focused = true;\n                    }\n                });\n                element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                    this.showElementAndHideCanvas(jsEvent.target);\n                    const actions = {\n                        value (event) {\n                            elementData.userValue = event.detail.value ?? \"\";\n                            storage.setValue(id, {\n                                value: elementData.userValue.toString()\n                            });\n                            event.target.value = elementData.userValue;\n                        },\n                        formattedValue (event) {\n                            const { formattedValue } = event.detail;\n                            elementData.formattedValue = formattedValue;\n                            if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                                event.target.value = formattedValue;\n                            }\n                            storage.setValue(id, {\n                                formattedValue\n                            });\n                        },\n                        selRange (event) {\n                            event.target.setSelectionRange(...event.detail.selRange);\n                        },\n                        charLimit: (event)=>{\n                            const { charLimit } = event.detail;\n                            const { target } = event;\n                            if (charLimit === 0) {\n                                target.removeAttribute(\"maxLength\");\n                                return;\n                            }\n                            target.setAttribute(\"maxLength\", charLimit);\n                            let value = elementData.userValue;\n                            if (!value || value.length <= charLimit) {\n                                return;\n                            }\n                            value = value.slice(0, charLimit);\n                            target.value = elementData.userValue = value;\n                            storage.setValue(id, {\n                                value\n                            });\n                            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                                source: this,\n                                detail: {\n                                    id,\n                                    name: \"Keystroke\",\n                                    value,\n                                    willCommit: true,\n                                    commitKey: 1,\n                                    selStart: target.selectionStart,\n                                    selEnd: target.selectionEnd\n                                }\n                            });\n                        }\n                    };\n                    this._dispatchEventFromSandbox(actions, jsEvent);\n                });\n                element.addEventListener(\"keydown\", (event)=>{\n                    elementData.commitKey = 1;\n                    let commitKey = -1;\n                    if (event.key === \"Escape\") {\n                        commitKey = 0;\n                    } else if (event.key === \"Enter\" && !this.data.multiLine) {\n                        commitKey = 2;\n                    } else if (event.key === \"Tab\") {\n                        elementData.commitKey = 3;\n                    }\n                    if (commitKey === -1) {\n                        return;\n                    }\n                    const { value } = event.target;\n                    if (elementData.lastCommittedValue === value) {\n                        return;\n                    }\n                    elementData.lastCommittedValue = value;\n                    elementData.userValue = value;\n                    this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                        source: this,\n                        detail: {\n                            id,\n                            name: \"Keystroke\",\n                            value,\n                            willCommit: true,\n                            commitKey,\n                            selStart: event.target.selectionStart,\n                            selEnd: event.target.selectionEnd\n                        }\n                    });\n                });\n                const _blurListener = blurListener;\n                blurListener = null;\n                element.addEventListener(\"blur\", (event)=>{\n                    if (!elementData.focused || !event.relatedTarget) {\n                        return;\n                    }\n                    if (!this.data.actions?.Blur) {\n                        elementData.focused = false;\n                    }\n                    const { value } = event.target;\n                    elementData.userValue = value;\n                    if (elementData.lastCommittedValue !== value) {\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                willCommit: true,\n                                commitKey: elementData.commitKey,\n                                selStart: event.target.selectionStart,\n                                selEnd: event.target.selectionEnd\n                            }\n                        });\n                    }\n                    _blurListener(event);\n                });\n                if (this.data.actions?.Keystroke) {\n                    element.addEventListener(\"beforeinput\", (event)=>{\n                        elementData.lastCommittedValue = null;\n                        const { data, target } = event;\n                        const { value, selectionStart, selectionEnd } = target;\n                        let selStart = selectionStart, selEnd = selectionEnd;\n                        switch(event.inputType){\n                            case \"deleteWordBackward\":\n                                {\n                                    const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                                    if (match) {\n                                        selStart -= match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteWordForward\":\n                                {\n                                    const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                                    if (match) {\n                                        selEnd += match[0].length;\n                                    }\n                                    break;\n                                }\n                            case \"deleteContentBackward\":\n                                if (selectionStart === selectionEnd) {\n                                    selStart -= 1;\n                                }\n                                break;\n                            case \"deleteContentForward\":\n                                if (selectionStart === selectionEnd) {\n                                    selEnd += 1;\n                                }\n                                break;\n                        }\n                        event.preventDefault();\n                        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                            source: this,\n                            detail: {\n                                id,\n                                name: \"Keystroke\",\n                                value,\n                                change: data || \"\",\n                                willCommit: false,\n                                selStart,\n                                selEnd\n                            }\n                        });\n                    });\n                }\n                this._setEventListeners(element, elementData, [\n                    [\n                        \"focus\",\n                        \"Focus\"\n                    ],\n                    [\n                        \"blur\",\n                        \"Blur\"\n                    ],\n                    [\n                        \"mousedown\",\n                        \"Mouse Down\"\n                    ],\n                    [\n                        \"mouseenter\",\n                        \"Mouse Enter\"\n                    ],\n                    [\n                        \"mouseleave\",\n                        \"Mouse Exit\"\n                    ],\n                    [\n                        \"mouseup\",\n                        \"Mouse Up\"\n                    ]\n                ], (event)=>event.target.value);\n            }\n            if (blurListener) {\n                element.addEventListener(\"blur\", blurListener);\n            }\n            if (this.data.comb) {\n                const fieldWidth = this.data.rect[2] - this.data.rect[0];\n                const combWidth = fieldWidth / maxLen;\n                element.classList.add(\"comb\");\n                element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n            }\n        } else {\n            element = document.createElement(\"div\");\n            element.textContent = this.data.fieldValue;\n            element.style.verticalAlign = \"middle\";\n            element.style.display = \"table-cell\";\n            if (this.data.hasOwnCanvas) {\n                element.hidden = true;\n            }\n        }\n        this._setTextStyle(element);\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: !!parameters.data.hasOwnCanvas\n        });\n    }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.exportValue === data.fieldValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== \"Off\";\n            storage.setValue(id, {\n                value\n            });\n        }\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"checkbox\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.setAttribute(\"exportValue\", data.exportValue);\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const checkbox of this._getElementsByName(name, id)){\n                const curChecked = checked && checkbox.exportValue === data.exportValue;\n                if (checkbox.domElement) {\n                    checkbox.domElement.checked = curChecked;\n                }\n                storage.setValue(checkbox.id, {\n                    value: curChecked\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue || \"Off\";\n            event.target.checked = defaultValue === data.exportValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        event.target.checked = event.detail.value !== \"Off\";\n                        storage.setValue(id, {\n                            value: event.target.checked\n                        });\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n        const storage = this.annotationStorage;\n        const data = this.data;\n        const id = data.id;\n        let value = storage.getValue(id, {\n            value: data.fieldValue === data.buttonValue\n        }).value;\n        if (typeof value === \"string\") {\n            value = value !== data.buttonValue;\n            storage.setValue(id, {\n                value\n            });\n        }\n        if (value) {\n            for (const radio of this._getElementsByName(data.fieldName, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n        }\n        const element = document.createElement(\"input\");\n        GetElementsByNameSet.add(element);\n        element.setAttribute(\"data-element-id\", id);\n        element.disabled = data.readOnly;\n        this._setRequired(element, this.data.required);\n        element.type = \"radio\";\n        element.name = data.fieldName;\n        if (value) {\n            element.setAttribute(\"checked\", true);\n        }\n        element.tabIndex = DEFAULT_TAB_INDEX;\n        element.addEventListener(\"change\", (event)=>{\n            const { name, checked } = event.target;\n            for (const radio of this._getElementsByName(name, id)){\n                storage.setValue(radio.id, {\n                    value: false\n                });\n            }\n            storage.setValue(id, {\n                value: checked\n            });\n        });\n        element.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = data.defaultFieldValue;\n            event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n        });\n        if (this.enableScripting && this.hasJSActions) {\n            const pdfButtonValue = data.buttonValue;\n            element.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value: (event)=>{\n                        const checked = pdfButtonValue === event.detail.value;\n                        for (const radio of this._getElementsByName(event.target.name)){\n                            const curChecked = checked && radio.id === id;\n                            if (radio.domElement) {\n                                radio.domElement.checked = curChecked;\n                            }\n                            storage.setValue(radio.id, {\n                                value: curChecked\n                            });\n                        }\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            this._setEventListeners(element, null, [\n                [\n                    \"change\",\n                    \"Validate\"\n                ],\n                [\n                    \"change\",\n                    \"Action\"\n                ],\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ]\n            ], (event)=>event.target.checked);\n        }\n        this._setBackgroundColor(element);\n        this._setDefaultPropertiesFromJS(element);\n        this.container.append(element);\n        return this.container;\n    }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            ignoreBorder: parameters.data.hasAppearance\n        });\n    }\n    render() {\n        const container = super.render();\n        container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n        const linkElement = container.lastChild;\n        if (this.enableScripting && this.hasJSActions && linkElement) {\n            this._setDefaultPropertiesFromJS(linkElement);\n            linkElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                this._dispatchEventFromSandbox({}, jsEvent);\n            });\n        }\n        return container;\n    }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: parameters.renderForms\n        });\n    }\n    render() {\n        this.container.classList.add(\"choiceWidgetAnnotation\");\n        const storage = this.annotationStorage;\n        const id = this.data.id;\n        const storedData = storage.getValue(id, {\n            value: this.data.fieldValue\n        });\n        const selectElement = document.createElement(\"select\");\n        GetElementsByNameSet.add(selectElement);\n        selectElement.setAttribute(\"data-element-id\", id);\n        selectElement.disabled = this.data.readOnly;\n        this._setRequired(selectElement, this.data.required);\n        selectElement.name = this.data.fieldName;\n        selectElement.tabIndex = DEFAULT_TAB_INDEX;\n        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n        if (!this.data.combo) {\n            selectElement.size = this.data.options.length;\n            if (this.data.multiSelect) {\n                selectElement.multiple = true;\n            }\n        }\n        selectElement.addEventListener(\"resetform\", (event)=>{\n            const defaultValue = this.data.defaultFieldValue;\n            for (const option of selectElement.options){\n                option.selected = option.value === defaultValue;\n            }\n        });\n        for (const option of this.data.options){\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = option.displayValue;\n            optionElement.value = option.exportValue;\n            if (storedData.value.includes(option.exportValue)) {\n                optionElement.setAttribute(\"selected\", true);\n                addAnEmptyEntry = false;\n            }\n            selectElement.append(optionElement);\n        }\n        let removeEmptyEntry = null;\n        if (addAnEmptyEntry) {\n            const noneOptionElement = document.createElement(\"option\");\n            noneOptionElement.value = \" \";\n            noneOptionElement.setAttribute(\"hidden\", true);\n            noneOptionElement.setAttribute(\"selected\", true);\n            selectElement.prepend(noneOptionElement);\n            removeEmptyEntry = ()=>{\n                noneOptionElement.remove();\n                selectElement.removeEventListener(\"input\", removeEmptyEntry);\n                removeEmptyEntry = null;\n            };\n            selectElement.addEventListener(\"input\", removeEmptyEntry);\n        }\n        const getValue = (isExport)=>{\n            const name = isExport ? \"value\" : \"textContent\";\n            const { options, multiple } = selectElement;\n            if (!multiple) {\n                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n            }\n            return Array.prototype.filter.call(options, (option)=>option.selected).map((option)=>option[name]);\n        };\n        let selectedValues = getValue(false);\n        const getItems = (event)=>{\n            const options = event.target.options;\n            return Array.prototype.map.call(options, (option)=>({\n                    displayValue: option.textContent,\n                    exportValue: option.value\n                }));\n        };\n        if (this.enableScripting && this.hasJSActions) {\n            selectElement.addEventListener(\"updatefromsandbox\", (jsEvent)=>{\n                const actions = {\n                    value (event) {\n                        removeEmptyEntry?.();\n                        const value = event.detail.value;\n                        const values = new Set(Array.isArray(value) ? value : [\n                            value\n                        ]);\n                        for (const option of selectElement.options){\n                            option.selected = values.has(option.value);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    multipleSelection (event) {\n                        selectElement.multiple = true;\n                    },\n                    remove (event) {\n                        const options = selectElement.options;\n                        const index = event.detail.remove;\n                        options[index].selected = false;\n                        selectElement.remove(index);\n                        if (options.length > 0) {\n                            const i = Array.prototype.findIndex.call(options, (option)=>option.selected);\n                            if (i === -1) {\n                                options[0].selected = true;\n                            }\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    clear (event) {\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        storage.setValue(id, {\n                            value: null,\n                            items: []\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    insert (event) {\n                        const { index, displayValue, exportValue } = event.detail.insert;\n                        const selectChild = selectElement.children[index];\n                        const optionElement = document.createElement(\"option\");\n                        optionElement.textContent = displayValue;\n                        optionElement.value = exportValue;\n                        if (selectChild) {\n                            selectChild.before(optionElement);\n                        } else {\n                            selectElement.append(optionElement);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    items (event) {\n                        const { items } = event.detail;\n                        while(selectElement.length !== 0){\n                            selectElement.remove(0);\n                        }\n                        for (const item of items){\n                            const { displayValue, exportValue } = item;\n                            const optionElement = document.createElement(\"option\");\n                            optionElement.textContent = displayValue;\n                            optionElement.value = exportValue;\n                            selectElement.append(optionElement);\n                        }\n                        if (selectElement.options.length > 0) {\n                            selectElement.options[0].selected = true;\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true),\n                            items: getItems(event)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    indices (event) {\n                        const indices = new Set(event.detail.indices);\n                        for (const option of event.target.options){\n                            option.selected = indices.has(option.index);\n                        }\n                        storage.setValue(id, {\n                            value: getValue(true)\n                        });\n                        selectedValues = getValue(false);\n                    },\n                    editable (event) {\n                        event.target.disabled = !event.detail.editable;\n                    }\n                };\n                this._dispatchEventFromSandbox(actions, jsEvent);\n            });\n            selectElement.addEventListener(\"input\", (event)=>{\n                const exportValue = getValue(true);\n                const change = getValue(false);\n                storage.setValue(id, {\n                    value: exportValue\n                });\n                event.preventDefault();\n                this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                    source: this,\n                    detail: {\n                        id,\n                        name: \"Keystroke\",\n                        value: selectedValues,\n                        change,\n                        changeEx: exportValue,\n                        willCommit: false,\n                        commitKey: 1,\n                        keyDown: false\n                    }\n                });\n            });\n            this._setEventListeners(selectElement, null, [\n                [\n                    \"focus\",\n                    \"Focus\"\n                ],\n                [\n                    \"blur\",\n                    \"Blur\"\n                ],\n                [\n                    \"mousedown\",\n                    \"Mouse Down\"\n                ],\n                [\n                    \"mouseenter\",\n                    \"Mouse Enter\"\n                ],\n                [\n                    \"mouseleave\",\n                    \"Mouse Exit\"\n                ],\n                [\n                    \"mouseup\",\n                    \"Mouse Up\"\n                ],\n                [\n                    \"input\",\n                    \"Action\"\n                ],\n                [\n                    \"input\",\n                    \"Validate\"\n                ]\n            ], (event)=>event.target.value);\n        } else {\n            selectElement.addEventListener(\"input\", function(event) {\n                storage.setValue(id, {\n                    value: getValue(true)\n                });\n            });\n        }\n        if (this.data.combo) {\n            this._setTextStyle(selectElement);\n        } else {}\n        this._setBackgroundColor(selectElement);\n        this._setDefaultPropertiesFromJS(selectElement);\n        this.container.append(selectElement);\n        return this.container;\n    }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        const { data, elements } = parameters;\n        super(parameters, {\n            isRenderable: AnnotationElement._hasPopupData(data)\n        });\n        this.elements = elements;\n        this.popup = null;\n    }\n    render() {\n        this.container.classList.add(\"popupAnnotation\");\n        const popup = this.popup = new PopupElement({\n            container: this.container,\n            color: this.data.color,\n            titleObj: this.data.titleObj,\n            modificationDate: this.data.modificationDate,\n            contentsObj: this.data.contentsObj,\n            richText: this.data.richText,\n            rect: this.data.rect,\n            parentRect: this.data.parentRect || null,\n            parent: this.parent,\n            elements: this.elements,\n            open: this.data.open\n        });\n        const elementIds = [];\n        for (const element of this.elements){\n            element.popup = popup;\n            element.container.ariaHasPopup = \"dialog\";\n            elementIds.push(element.data.id);\n            element.addHighlightArea();\n        }\n        this.container.setAttribute(\"aria-controls\", elementIds.map((id)=>`${AnnotationPrefix}${id}`).join(\",\"));\n        return this.container;\n    }\n}\nclass PopupElement {\n    #boundKeyDown;\n    #boundHide;\n    #boundShow;\n    #boundToggle;\n    #color;\n    #container;\n    #contentsObj;\n    #dateObj;\n    #elements;\n    #parent;\n    #parentRect;\n    #pinned;\n    #popup;\n    #position;\n    #rect;\n    #richText;\n    #titleObj;\n    #updates;\n    #wasVisible;\n    constructor({ container, color, elements, titleObj, modificationDate, contentsObj, richText, parent, rect, parentRect, open }){\n        this.#boundKeyDown = this.#keyDown.bind(this);\n        this.#boundHide = this.#hide.bind(this);\n        this.#boundShow = this.#show.bind(this);\n        this.#boundToggle = this.#toggle.bind(this);\n        this.#color = null;\n        this.#container = null;\n        this.#contentsObj = null;\n        this.#dateObj = null;\n        this.#elements = null;\n        this.#parent = null;\n        this.#parentRect = null;\n        this.#pinned = false;\n        this.#popup = null;\n        this.#position = null;\n        this.#rect = null;\n        this.#richText = null;\n        this.#titleObj = null;\n        this.#updates = null;\n        this.#wasVisible = false;\n        this.#container = container;\n        this.#titleObj = titleObj;\n        this.#contentsObj = contentsObj;\n        this.#richText = richText;\n        this.#parent = parent;\n        this.#color = color;\n        this.#rect = rect;\n        this.#parentRect = parentRect;\n        this.#elements = elements;\n        this.#dateObj = PDFDateString.toDateObject(modificationDate);\n        this.trigger = elements.flatMap((e)=>e.getElementsToTriggerPopup());\n        for (const element of this.trigger){\n            element.addEventListener(\"click\", this.#boundToggle);\n            element.addEventListener(\"mouseenter\", this.#boundShow);\n            element.addEventListener(\"mouseleave\", this.#boundHide);\n            element.classList.add(\"popupTriggerArea\");\n        }\n        for (const element of elements){\n            element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n        }\n        this.#container.hidden = true;\n        if (open) {\n            this.#toggle();\n        }\n    }\n    render() {\n        if (this.#popup) {\n            return;\n        }\n        const popup = this.#popup = document.createElement(\"div\");\n        popup.className = \"popup\";\n        if (this.#color) {\n            const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n            if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n                popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n            } else {\n                const BACKGROUND_ENLIGHT = 0.7;\n                popup.style.backgroundColor = Util.makeHexColor(...this.#color.map((c)=>Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n            }\n        }\n        const header = document.createElement(\"span\");\n        header.className = \"header\";\n        const title = document.createElement(\"h1\");\n        header.append(title);\n        ({ dir: title.dir, str: title.textContent } = this.#titleObj);\n        popup.append(header);\n        if (this.#dateObj) {\n            const modificationDate = document.createElement(\"span\");\n            modificationDate.classList.add(\"popupDate\");\n            modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n            modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n                dateObj: this.#dateObj.valueOf()\n            }));\n            header.append(modificationDate);\n        }\n        const html = this.#html;\n        if (html) {\n            XfaLayer.render({\n                xfaHtml: html,\n                intent: \"richText\",\n                div: popup\n            });\n            popup.lastChild.classList.add(\"richText\", \"popupContent\");\n        } else {\n            const contents = this._formatContents(this.#contentsObj);\n            popup.append(contents);\n        }\n        this.#container.append(popup);\n    }\n    get #html() {\n        const richText = this.#richText;\n        const contentsObj = this.#contentsObj;\n        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n            return this.#richText.html || null;\n        }\n        return null;\n    }\n    get #fontSize() {\n        return this.#html?.attributes?.style?.fontSize || 0;\n    }\n    get #fontColor() {\n        return this.#html?.attributes?.style?.color || null;\n    }\n    #makePopupContent(text) {\n        const popupLines = [];\n        const popupContent = {\n            str: text,\n            html: {\n                name: \"div\",\n                attributes: {\n                    dir: \"auto\"\n                },\n                children: [\n                    {\n                        name: \"p\",\n                        children: popupLines\n                    }\n                ]\n            }\n        };\n        const lineAttributes = {\n            style: {\n                color: this.#fontColor,\n                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--scale-factor))` : \"\"\n            }\n        };\n        for (const line of text.split(\"\\n\")){\n            popupLines.push({\n                name: \"span\",\n                value: line,\n                attributes: lineAttributes\n            });\n        }\n        return popupContent;\n    }\n    _formatContents({ str, dir }) {\n        const p = document.createElement(\"p\");\n        p.classList.add(\"popupContent\");\n        p.dir = dir;\n        const lines = str.split(/(?:\\r\\n?|\\n)/);\n        for(let i = 0, ii = lines.length; i < ii; ++i){\n            const line = lines[i];\n            p.append(document.createTextNode(line));\n            if (i < ii - 1) {\n                p.append(document.createElement(\"br\"));\n            }\n        }\n        return p;\n    }\n    #keyDown(event) {\n        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n            return;\n        }\n        if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n            this.#toggle();\n        }\n    }\n    updateEdited({ rect, popupContent }) {\n        this.#updates ||= {\n            contentsObj: this.#contentsObj,\n            richText: this.#richText\n        };\n        if (rect) {\n            this.#position = null;\n        }\n        if (popupContent) {\n            this.#richText = this.#makePopupContent(popupContent);\n            this.#contentsObj = null;\n        }\n        this.#popup?.remove();\n        this.#popup = null;\n    }\n    resetEdited() {\n        if (!this.#updates) {\n            return;\n        }\n        ({ contentsObj: this.#contentsObj, richText: this.#richText } = this.#updates);\n        this.#updates = null;\n        this.#popup?.remove();\n        this.#popup = null;\n        this.#position = null;\n    }\n    #setPosition() {\n        if (this.#position !== null) {\n            return;\n        }\n        const { page: { view }, viewport: { rawDims: { pageWidth, pageHeight, pageX, pageY } } } = this.#parent;\n        let useParentRect = !!this.#parentRect;\n        let rect = useParentRect ? this.#parentRect : this.#rect;\n        for (const element of this.#elements){\n            if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n                rect = element.data.rect;\n                useParentRect = true;\n                break;\n            }\n        }\n        const normalizedRect = Util.normalizeRect([\n            rect[0],\n            view[3] - rect[1] + view[1],\n            rect[2],\n            view[3] - rect[3] + view[1]\n        ]);\n        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n        const popupLeft = normalizedRect[0] + parentWidth;\n        const popupTop = normalizedRect[1];\n        this.#position = [\n            100 * (popupLeft - pageX) / pageWidth,\n            100 * (popupTop - pageY) / pageHeight\n        ];\n        const { style } = this.#container;\n        style.left = `${this.#position[0]}%`;\n        style.top = `${this.#position[1]}%`;\n    }\n    #toggle() {\n        this.#pinned = !this.#pinned;\n        if (this.#pinned) {\n            this.#show();\n            this.#container.addEventListener(\"click\", this.#boundToggle);\n            this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n        } else {\n            this.#hide();\n            this.#container.removeEventListener(\"click\", this.#boundToggle);\n            this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n        }\n    }\n    #show() {\n        if (!this.#popup) {\n            this.render();\n        }\n        if (!this.isVisible) {\n            this.#setPosition();\n            this.#container.hidden = false;\n            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n        } else if (this.#pinned) {\n            this.#container.classList.add(\"focused\");\n        }\n    }\n    #hide() {\n        this.#container.classList.remove(\"focused\");\n        if (this.#pinned || !this.isVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n    }\n    forceHide() {\n        this.#wasVisible = this.isVisible;\n        if (!this.#wasVisible) {\n            return;\n        }\n        this.#container.hidden = true;\n    }\n    maybeShow() {\n        if (!this.#wasVisible) {\n            return;\n        }\n        if (!this.#popup) {\n            this.#show();\n        }\n        this.#wasVisible = false;\n        this.#container.hidden = false;\n    }\n    get isVisible() {\n        return this.#container.hidden === false;\n    }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.textContent = parameters.data.textContent;\n        this.textPosition = parameters.data.textPosition;\n        this.annotationEditorType = AnnotationEditorType.FREETEXT;\n    }\n    render() {\n        this.container.classList.add(\"freeTextAnnotation\");\n        if (this.textContent) {\n            const content = document.createElement(\"div\");\n            content.classList.add(\"annotationTextContent\");\n            content.setAttribute(\"role\", \"comment\");\n            for (const line of this.textContent){\n                const lineSpan = document.createElement(\"span\");\n                lineSpan.textContent = line;\n                content.append(lineSpan);\n            }\n            this.container.append(content);\n        }\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass LineAnnotationElement extends AnnotationElement {\n    #line;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#line = null;\n    }\n    render() {\n        this.container.classList.add(\"lineAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n        line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n        line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n        line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n        line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n        line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n        line.setAttribute(\"stroke\", \"transparent\");\n        line.setAttribute(\"fill\", \"transparent\");\n        svg.append(line);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#line;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n    #square;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#square = null;\n    }\n    render() {\n        this.container.classList.add(\"squareAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n        square.setAttribute(\"x\", borderWidth / 2);\n        square.setAttribute(\"y\", borderWidth / 2);\n        square.setAttribute(\"width\", width - borderWidth);\n        square.setAttribute(\"height\", height - borderWidth);\n        square.setAttribute(\"stroke-width\", borderWidth || 1);\n        square.setAttribute(\"stroke\", \"transparent\");\n        square.setAttribute(\"fill\", \"transparent\");\n        svg.append(square);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#square;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n    #circle;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#circle = null;\n    }\n    render() {\n        this.container.classList.add(\"circleAnnotation\");\n        const data = this.data;\n        const { width, height } = getRectDims(data.rect);\n        const svg = this.svgFactory.create(width, height, true);\n        const borderWidth = data.borderStyle.width;\n        const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n        circle.setAttribute(\"cx\", width / 2);\n        circle.setAttribute(\"cy\", height / 2);\n        circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n        circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n        circle.setAttribute(\"stroke-width\", borderWidth || 1);\n        circle.setAttribute(\"stroke\", \"transparent\");\n        circle.setAttribute(\"fill\", \"transparent\");\n        svg.append(circle);\n        this.container.append(svg);\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#circle;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n    #polyline;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polyline = null;\n        this.containerClassName = \"polylineAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, vertices, borderStyle, popupRef } } = this;\n        if (!vertices) {\n            return this.container;\n        }\n        const { width, height } = getRectDims(rect);\n        const svg = this.svgFactory.create(width, height, true);\n        let points = [];\n        for(let i = 0, ii = vertices.length; i < ii; i += 2){\n            const x = vertices[i] - rect[0];\n            const y = rect[3] - vertices[i + 1];\n            points.push(`${x},${y}`);\n        }\n        points = points.join(\" \");\n        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n        polyline.setAttribute(\"points\", points);\n        polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n        polyline.setAttribute(\"stroke\", \"transparent\");\n        polyline.setAttribute(\"fill\", \"transparent\");\n        svg.append(polyline);\n        this.container.append(svg);\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polyline;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n    constructor(parameters){\n        super(parameters);\n        this.containerClassName = \"polygonAnnotation\";\n        this.svgElementName = \"svg:polygon\";\n    }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n    }\n    render() {\n        this.container.classList.add(\"caretAnnotation\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        return this.container;\n    }\n}\nclass InkAnnotationElement extends AnnotationElement {\n    #polylines;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.#polylines = [];\n        this.containerClassName = \"inkAnnotation\";\n        this.svgElementName = \"svg:polyline\";\n        this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n    }\n    render() {\n        this.container.classList.add(this.containerClassName);\n        const { data: { rect, inkLists, borderStyle, popupRef } } = this;\n        const { width, height } = getRectDims(rect);\n        const svg = this.svgFactory.create(width, height, true);\n        for (const inkList of inkLists){\n            let points = [];\n            for(let i = 0, ii = inkList.length; i < ii; i += 2){\n                const x = inkList[i] - rect[0];\n                const y = rect[3] - inkList[i + 1];\n                points.push(`${x},${y}`);\n            }\n            points = points.join(\" \");\n            const polyline = this.svgFactory.createElement(this.svgElementName);\n            this.#polylines.push(polyline);\n            polyline.setAttribute(\"points\", points);\n            polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n            polyline.setAttribute(\"stroke\", \"transparent\");\n            polyline.setAttribute(\"fill\", \"transparent\");\n            svg.append(polyline);\n        }\n        if (!popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.append(svg);\n        this._editOnDoubleClick();\n        return this.container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#polylines;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"highlightAnnotation\");\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"underlineAnnotation\");\n        return this.container;\n    }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"squigglyAnnotation\");\n        return this.container;\n    }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true,\n            createQuadrilaterals: true\n        });\n    }\n    render() {\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this.container.classList.add(\"strikeoutAnnotation\");\n        return this.container;\n    }\n}\nclass StampAnnotationElement extends AnnotationElement {\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true,\n            ignoreBorder: true\n        });\n        this.annotationEditorType = AnnotationEditorType.STAMP;\n    }\n    render() {\n        this.container.classList.add(\"stampAnnotation\");\n        this.container.setAttribute(\"role\", \"img\");\n        if (!this.data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        }\n        this._editOnDoubleClick();\n        return this.container;\n    }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n    #trigger;\n    constructor(parameters){\n        super(parameters, {\n            isRenderable: true\n        });\n        this.#trigger = null;\n        const { file } = this.data;\n        this.filename = file.filename;\n        this.content = file.content;\n        this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n            source: this,\n            ...file\n        });\n    }\n    render() {\n        this.container.classList.add(\"fileAttachmentAnnotation\");\n        const { container, data } = this;\n        let trigger;\n        if (data.hasAppearance || data.fillAlpha === 0) {\n            trigger = document.createElement(\"div\");\n        } else {\n            trigger = document.createElement(\"img\");\n            trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n            if (data.fillAlpha && data.fillAlpha < 1) {\n                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n            }\n        }\n        trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n        this.#trigger = trigger;\n        const { isMac } = util_FeatureTest.platform;\n        container.addEventListener(\"keydown\", (evt)=>{\n            if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n                this.#download();\n            }\n        });\n        if (!data.popupRef && this.hasPopupData) {\n            this._createPopup();\n        } else {\n            trigger.classList.add(\"popupTriggerArea\");\n        }\n        container.append(trigger);\n        return container;\n    }\n    getElementsToTriggerPopup() {\n        return this.#trigger;\n    }\n    addHighlightArea() {\n        this.container.classList.add(\"highlightArea\");\n    }\n    #download() {\n        this.downloadManager?.openOrDownloadData(this.content, this.filename);\n    }\n}\nclass AnnotationLayer {\n    #accessibilityManager;\n    #annotationCanvasMap;\n    #editableAnnotations;\n    #structTreeLayer;\n    constructor({ div, accessibilityManager, annotationCanvasMap, annotationEditorUIManager, page, viewport, structTreeLayer }){\n        this.#accessibilityManager = null;\n        this.#annotationCanvasMap = null;\n        this.#editableAnnotations = new Map();\n        this.#structTreeLayer = null;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationCanvasMap = annotationCanvasMap;\n        this.#structTreeLayer = structTreeLayer || null;\n        this.page = page;\n        this.viewport = viewport;\n        this.zIndex = 0;\n        this._annotationEditorUIManager = annotationEditorUIManager;\n    }\n    hasEditableAnnotations() {\n        return this.#editableAnnotations.size > 0;\n    }\n    async #appendElement(element, id) {\n        const contentElement = element.firstChild || element;\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);\n        if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes){\n                contentElement.setAttribute(key, value);\n            }\n        }\n        this.div.append(element);\n        this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n    }\n    async render(params) {\n        const { annotations } = params;\n        const layer = this.div;\n        setLayerDimensions(layer, this.viewport);\n        const popupToElements = new Map();\n        const elementParams = {\n            data: null,\n            layer,\n            linkService: params.linkService,\n            downloadManager: params.downloadManager,\n            imageResourcesPath: params.imageResourcesPath || \"\",\n            renderForms: params.renderForms !== false,\n            svgFactory: new DOMSVGFactory(),\n            annotationStorage: params.annotationStorage || new AnnotationStorage(),\n            enableScripting: params.enableScripting === true,\n            hasJSActions: params.hasJSActions,\n            fieldObjects: params.fieldObjects,\n            parent: this,\n            elements: null\n        };\n        for (const data of annotations){\n            if (data.noHTML) {\n                continue;\n            }\n            const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n            if (!isPopupAnnotation) {\n                const { width, height } = getRectDims(data.rect);\n                if (width <= 0 || height <= 0) {\n                    continue;\n                }\n            } else {\n                const elements = popupToElements.get(data.id);\n                if (!elements) {\n                    continue;\n                }\n                elementParams.elements = elements;\n            }\n            elementParams.data = data;\n            const element = AnnotationElementFactory.create(elementParams);\n            if (!element.isRenderable) {\n                continue;\n            }\n            if (!isPopupAnnotation && data.popupRef) {\n                const elements = popupToElements.get(data.popupRef);\n                if (!elements) {\n                    popupToElements.set(data.popupRef, [\n                        element\n                    ]);\n                } else {\n                    elements.push(element);\n                }\n            }\n            const rendered = element.render();\n            if (data.hidden) {\n                rendered.style.visibility = \"hidden\";\n            }\n            await this.#appendElement(rendered, data.id);\n            if (element._isEditable) {\n                this.#editableAnnotations.set(element.data.id, element);\n                this._annotationEditorUIManager?.renderAnnotationElement(element);\n            }\n        }\n        this.#setAnnotationCanvasMap();\n    }\n    update({ viewport }) {\n        const layer = this.div;\n        this.viewport = viewport;\n        setLayerDimensions(layer, {\n            rotation: viewport.rotation\n        });\n        this.#setAnnotationCanvasMap();\n        layer.hidden = false;\n    }\n    #setAnnotationCanvasMap() {\n        if (!this.#annotationCanvasMap) {\n            return;\n        }\n        const layer = this.div;\n        for (const [id, canvas] of this.#annotationCanvasMap){\n            const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n            if (!element) {\n                continue;\n            }\n            canvas.className = \"annotationContent\";\n            const { firstChild } = element;\n            if (!firstChild) {\n                element.append(canvas);\n            } else if (firstChild.nodeName === \"CANVAS\") {\n                firstChild.replaceWith(canvas);\n            } else if (!firstChild.classList.contains(\"annotationContent\")) {\n                firstChild.before(canvas);\n            } else {\n                firstChild.after(canvas);\n            }\n        }\n        this.#annotationCanvasMap.clear();\n    }\n    getEditableAnnotations() {\n        return Array.from(this.#editableAnnotations.values());\n    }\n    getEditableAnnotation(id) {\n        return this.#editableAnnotations.get(id);\n    }\n}\n; // ./src/display/editor/freetext.js\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n    #color;\n    #content;\n    #editorDivId;\n    #editModeAC;\n    #fontSize;\n    static{\n        this._freeTextDefaultContent = \"\";\n    }\n    static{\n        this._internalPadding = 0;\n    }\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultFontSize = 10;\n    }\n    static get _keyboardManager() {\n        const proto = FreeTextEditor.prototype;\n        const arrowChecker = (self)=>self.isEmpty();\n        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n        const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ctrl+s\",\n                    \"mac+meta+s\",\n                    \"ctrl+p\",\n                    \"mac+meta+p\"\n                ],\n                proto.commitOrRemove,\n                {\n                    bubbles: true\n                }\n            ],\n            [\n                [\n                    \"ctrl+Enter\",\n                    \"mac+meta+Enter\",\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                proto.commitOrRemove\n            ],\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowLeft\",\n                    \"mac+shift+ArrowLeft\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        -big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        small,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowRight\",\n                    \"mac+shift+ArrowRight\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        big,\n                        0\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowUp\",\n                    \"mac+shift+ArrowUp\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        -big\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        small\n                    ],\n                    checker: arrowChecker\n                }\n            ],\n            [\n                [\n                    \"ctrl+ArrowDown\",\n                    \"mac+shift+ArrowDown\"\n                ],\n                proto._translateEmpty,\n                {\n                    args: [\n                        0,\n                        big\n                    ],\n                    checker: arrowChecker\n                }\n            ]\n        ]));\n    }\n    static{\n        this._type = \"freetext\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.FREETEXT;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"freeTextEditor\"\n        });\n        this.#content = \"\";\n        this.#editorDivId = `${this.id}-editor`;\n        this.#editModeAC = null;\n        this.#color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n        this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        const style = getComputedStyle(document.documentElement);\n        this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                FreeTextEditor._defaultFontSize = value;\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                FreeTextEditor._defaultColor = value;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.FREETEXT_SIZE:\n                this.#updateFontSize(value);\n                break;\n            case AnnotationEditorParamsType.FREETEXT_COLOR:\n                this.#updateColor(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                FreeTextEditor._defaultFontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.FREETEXT_SIZE,\n                this.#fontSize\n            ],\n            [\n                AnnotationEditorParamsType.FREETEXT_COLOR,\n                this.#color\n            ]\n        ];\n    }\n    #updateFontSize(fontSize) {\n        const setFontsize = (size)=>{\n            this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n            this.translate(0, -(size - this.#fontSize) * this.parentScale);\n            this.#fontSize = size;\n            this.#setEditorDimensions();\n        };\n        const savedFontsize = this.#fontSize;\n        this.addCommands({\n            cmd: setFontsize.bind(this, fontSize),\n            undo: setFontsize.bind(this, savedFontsize),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_SIZE,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.#color = this.editorDiv.style.color = col;\n        };\n        const savedColor = this.#color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.FREETEXT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    _translateEmpty(x, y) {\n        this._uiManager.translateSelectedEditors(x, y, true);\n    }\n    getInitialTranslation() {\n        const scale = this.parentScale;\n        return [\n            -FreeTextEditor._internalPadding * scale,\n            -(FreeTextEditor._internalPadding + this.#fontSize) * scale\n        ];\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    enableEditMode() {\n        if (this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(false);\n        this.parent.updateToolbar(AnnotationEditorType.FREETEXT);\n        super.enableEditMode();\n        this.overlayDiv.classList.remove(\"enabled\");\n        this.editorDiv.contentEditable = true;\n        this._isDraggable = false;\n        this.div.removeAttribute(\"aria-activedescendant\");\n        this.#editModeAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#editModeAC);\n        this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n            signal\n        });\n        this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n            signal\n        });\n    }\n    disableEditMode() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        this.parent.setEditingState(true);\n        super.disableEditMode();\n        this.overlayDiv.classList.add(\"enabled\");\n        this.editorDiv.contentEditable = false;\n        this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n        this._isDraggable = true;\n        this.#editModeAC?.abort();\n        this.#editModeAC = null;\n        this.div.focus({\n            preventScroll: true\n        });\n        this.isEditing = false;\n        this.parent.div.classList.add(\"freetextEditing\");\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        if (event.target !== this.editorDiv) {\n            this.editorDiv.focus();\n        }\n    }\n    onceAdded() {\n        if (this.width) {\n            return;\n        }\n        this.enableEditMode();\n        this.editorDiv.focus();\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        }\n        this._initialOptions = null;\n    }\n    isEmpty() {\n        return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n    }\n    remove() {\n        this.isEditing = false;\n        if (this.parent) {\n            this.parent.setEditingState(true);\n            this.parent.div.classList.add(\"freetextEditing\");\n        }\n        super.remove();\n    }\n    #extractText() {\n        const buffer = [];\n        this.editorDiv.normalize();\n        let prevChild = null;\n        for (const child of this.editorDiv.childNodes){\n            if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n                continue;\n            }\n            buffer.push(FreeTextEditor.#getNodeContent(child));\n            prevChild = child;\n        }\n        return buffer.join(\"\\n\");\n    }\n    #setEditorDimensions() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        let rect;\n        if (this.isAttachedToDOM) {\n            rect = this.div.getBoundingClientRect();\n        } else {\n            const { currentLayer, div } = this;\n            const savedDisplay = div.style.display;\n            const savedVisibility = div.classList.contains(\"hidden\");\n            div.classList.remove(\"hidden\");\n            div.style.display = \"hidden\";\n            currentLayer.div.append(this.div);\n            rect = div.getBoundingClientRect();\n            div.remove();\n            div.style.display = savedDisplay;\n            div.classList.toggle(\"hidden\", savedVisibility);\n        }\n        if (this.rotation % 180 === this.parentRotation % 180) {\n            this.width = rect.width / parentWidth;\n            this.height = rect.height / parentHeight;\n        } else {\n            this.width = rect.height / parentWidth;\n            this.height = rect.width / parentHeight;\n        }\n        this.fixAndSetPosition();\n    }\n    commit() {\n        if (!this.isInEditMode()) {\n            return;\n        }\n        super.commit();\n        this.disableEditMode();\n        const savedText = this.#content;\n        const newText = this.#content = this.#extractText().trimEnd();\n        if (savedText === newText) {\n            return;\n        }\n        const setText = (text)=>{\n            this.#content = text;\n            if (!text) {\n                this.remove();\n                return;\n            }\n            this.#setContent();\n            this._uiManager.rebuild(this);\n            this.#setEditorDimensions();\n        };\n        this.addCommands({\n            cmd: ()=>{\n                setText(newText);\n            },\n            undo: ()=>{\n                setText(savedText);\n            },\n            mustExec: false\n        });\n        this.#setEditorDimensions();\n    }\n    shouldGetKeyboardEvents() {\n        return this.isInEditMode();\n    }\n    enterInEditMode() {\n        this.enableEditMode();\n        this.editorDiv.focus();\n    }\n    dblclick(event) {\n        this.enterInEditMode();\n    }\n    keydown(event) {\n        if (event.target === this.div && event.key === \"Enter\") {\n            this.enterInEditMode();\n            event.preventDefault();\n        }\n    }\n    editorDivKeydown(event) {\n        FreeTextEditor._keyboardManager.exec(this, event);\n    }\n    editorDivFocus(event) {\n        this.isEditing = true;\n    }\n    editorDivBlur(event) {\n        this.isEditing = false;\n    }\n    editorDivInput(event) {\n        this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n    }\n    disableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"comment\");\n        this.editorDiv.removeAttribute(\"aria-multiline\");\n    }\n    enableEditing() {\n        this.editorDiv.setAttribute(\"role\", \"textbox\");\n        this.editorDiv.setAttribute(\"aria-multiline\", true);\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this.width) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.editorDiv = document.createElement(\"div\");\n        this.editorDiv.className = \"internal\";\n        this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n        this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n        this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n        this.enableEditing();\n        this.editorDiv.contentEditable = true;\n        const { style } = this.editorDiv;\n        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n        style.color = this.#color;\n        this.div.append(this.editorDiv);\n        this.overlayDiv = document.createElement(\"div\");\n        this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n        this.div.append(this.overlayDiv);\n        bindEvents(this, this.div, [\n            \"dblclick\",\n            \"keydown\"\n        ]);\n        if (this.width) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            if (this.annotationElementId) {\n                const { position } = this._initialData;\n                let [tx, ty] = this.getInitialTranslation();\n                [tx, ty] = this.pageTranslationToScreen(tx, ty);\n                const [pageWidth, pageHeight] = this.pageDimensions;\n                const [pageX, pageY] = this.pageTranslation;\n                let posX, posY;\n                switch(this.rotation){\n                    case 0:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n                        break;\n                    case 90:\n                        posX = baseX + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            ty,\n                            -tx\n                        ];\n                        break;\n                    case 180:\n                        posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n                        posY = baseY - (position[1] - pageY) / pageHeight;\n                        [tx, ty] = [\n                            -tx,\n                            -ty\n                        ];\n                        break;\n                    case 270:\n                        posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n                        posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n                        [tx, ty] = [\n                            -ty,\n                            tx\n                        ];\n                        break;\n                }\n                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n            } else {\n                this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n            }\n            this.#setContent();\n            this._isDraggable = true;\n            this.editorDiv.contentEditable = false;\n        } else {\n            this._isDraggable = false;\n            this.editorDiv.contentEditable = true;\n        }\n        return this.div;\n    }\n    static #getNodeContent(node) {\n        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n    }\n    editorDivPaste(event) {\n        const clipboardData = event.clipboardData || window.clipboardData;\n        const { types } = clipboardData;\n        if (types.length === 1 && types[0] === \"text/plain\") {\n            return;\n        }\n        event.preventDefault();\n        const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n        if (!paste) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (!selection.rangeCount) {\n            return;\n        }\n        this.editorDiv.normalize();\n        selection.deleteFromDocument();\n        const range = selection.getRangeAt(0);\n        if (!paste.includes(\"\\n\")) {\n            range.insertNode(document.createTextNode(paste));\n            this.editorDiv.normalize();\n            selection.collapseToStart();\n            return;\n        }\n        const { startContainer, startOffset } = range;\n        const bufferBefore = [];\n        const bufferAfter = [];\n        if (startContainer.nodeType === Node.TEXT_NODE) {\n            const parent = startContainer.parentElement;\n            bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n            if (parent !== this.editorDiv) {\n                let buffer = bufferBefore;\n                for (const child of this.editorDiv.childNodes){\n                    if (child === parent) {\n                        buffer = bufferAfter;\n                        continue;\n                    }\n                    buffer.push(FreeTextEditor.#getNodeContent(child));\n                }\n            }\n            bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n        } else if (startContainer === this.editorDiv) {\n            let buffer = bufferBefore;\n            let i = 0;\n            for (const child of this.editorDiv.childNodes){\n                if (i++ === startOffset) {\n                    buffer = bufferAfter;\n                }\n                buffer.push(FreeTextEditor.#getNodeContent(child));\n            }\n        }\n        this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n        this.#setContent();\n        const newRange = new Range();\n        let beforeLength = bufferBefore.reduce((acc, line)=>acc + line.length, 0);\n        for (const { firstChild } of this.editorDiv.childNodes){\n            if (firstChild.nodeType === Node.TEXT_NODE) {\n                const length = firstChild.nodeValue.length;\n                if (beforeLength <= length) {\n                    newRange.setStart(firstChild, beforeLength);\n                    newRange.setEnd(firstChild, beforeLength);\n                    break;\n                }\n                beforeLength -= length;\n            }\n        }\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n    }\n    #setContent() {\n        this.editorDiv.replaceChildren();\n        if (!this.#content) {\n            return;\n        }\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            this.editorDiv.append(div);\n        }\n    }\n    #serializeContent() {\n        return this.#content.replaceAll(\"\\xa0\", \" \");\n    }\n    static #deserializeContent(content) {\n        return content.replaceAll(\" \", \"\\xa0\");\n    }\n    get contentDiv() {\n        return this.editorDiv;\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof FreeTextAnnotationElement) {\n            const { data: { defaultAppearanceData: { fontSize, fontColor }, rect, rotation, id, popupRef }, textContent, textPosition, parent: { page: { pageNumber } } } = data;\n            if (!textContent || textContent.length === 0) {\n                return null;\n            }\n            initialData = data = {\n                annotationType: AnnotationEditorType.FREETEXT,\n                color: Array.from(fontColor),\n                fontSize,\n                value: textContent.join(\"\\n\"),\n                position: textPosition,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.#fontSize = data.fontSize;\n        editor.#color = Util.makeHexColor(...data.color);\n        editor.#content = FreeTextEditor.#deserializeContent(data.value);\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        const rect = this.getRect(padding, padding);\n        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n        const serialized = {\n            annotationType: AnnotationEditorType.FREETEXT,\n            color,\n            fontSize: this.#fontSize,\n            value: this.#serializeContent(),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            return serialized;\n        }\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { value, fontSize, color, pageIndex } = this._initialData;\n        return this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i)=>c !== color[i]) || serialized.pageIndex !== pageIndex;\n    }\n    renderAnnotationElement(annotation) {\n        const content = super.renderAnnotationElement(annotation);\n        if (this.deleted) {\n            return content;\n        }\n        const { style } = content;\n        style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n        style.color = this.#color;\n        content.replaceChildren();\n        for (const line of this.#content.split(\"\\n\")){\n            const div = document.createElement(\"div\");\n            div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n            content.append(div);\n        }\n        const padding = FreeTextEditor._internalPadding * this.parentScale;\n        annotation.updateEdited({\n            rect: this.getRect(padding, padding),\n            popupContent: this.#content\n        });\n        return content;\n    }\n    resetAnnotationElement(annotation) {\n        super.resetAnnotationElement(annotation);\n        annotation.resetEdited();\n    }\n}\n; // ./src/display/editor/drawers/outline.js\nclass Outline {\n    toSVGPath() {\n        unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n    }\n    get box() {\n        unreachable(\"Abstract getter `box` must be implemented.\");\n    }\n    serialize(_bbox, _rotation) {\n        unreachable(\"Abstract method `serialize` must be implemented.\");\n    }\n    get classNamesForDrawing() {\n        unreachable(\"Abstract getter `classNamesForDrawing` must be implemented.\");\n    }\n    get classNamesForOutlining() {\n        unreachable(\"Abstract getter `classNamesForOutlining` must be implemented.\");\n    }\n    get mustRemoveSelfIntersections() {\n        return false;\n    }\n}\n; // ./src/display/editor/drawers/freedraw.js\nclass FreeDrawOutliner {\n    #box;\n    #bottom;\n    #innerMargin;\n    #isLTR;\n    #top;\n    #last;\n    #lastX;\n    #lastY;\n    #min;\n    #min_dist;\n    #scaleFactor;\n    #thickness;\n    #points;\n    static #MIN_DIST = 8;\n    static #MIN_DIFF = 2;\n    static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n    constructor({ x, y }, box, scaleFactor, thickness, isLTR, innerMargin = 0){\n        this.#bottom = [];\n        this.#top = [];\n        this.#last = new Float64Array(18);\n        this.#points = [];\n        this.#box = box;\n        this.#thickness = thickness * scaleFactor;\n        this.#isLTR = isLTR;\n        this.#last.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            x,\n            y\n        ], 6);\n        this.#innerMargin = innerMargin;\n        this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n        this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n        this.#scaleFactor = scaleFactor;\n        this.#points.push(x, y);\n    }\n    isEmpty() {\n        return isNaN(this.#last[8]);\n    }\n    #getLastCoords() {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [x, y, width, height] = this.#box;\n        return [\n            (this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width,\n            (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height,\n            (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width,\n            (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height\n        ];\n    }\n    add({ x, y }) {\n        this.#lastX = x;\n        this.#lastY = y;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n        const diffX = x - x2;\n        const diffY = y - y2;\n        const d = Math.hypot(diffX, diffY);\n        if (d < this.#min) {\n            return false;\n        }\n        const diffD = d - this.#min_dist;\n        const K = diffD / d;\n        const shiftX = K * diffX;\n        const shiftY = K * diffY;\n        let x0 = x1;\n        let y0 = y1;\n        x1 = x2;\n        y1 = y2;\n        x2 += shiftX;\n        y2 += shiftY;\n        this.#points?.push(x, y);\n        const nX = -shiftY / diffD;\n        const nY = shiftX / diffD;\n        const thX = nX * this.#thickness;\n        const thY = nY * this.#thickness;\n        this.#last.set(this.#last.subarray(2, 8), 0);\n        this.#last.set([\n            x2 + thX,\n            y2 + thY\n        ], 4);\n        this.#last.set(this.#last.subarray(14, 18), 12);\n        this.#last.set([\n            x2 - thX,\n            y2 - thY\n        ], 16);\n        if (isNaN(this.#last[6])) {\n            if (this.#top.length === 0) {\n                this.#last.set([\n                    x1 + thX,\n                    y1 + thY\n                ], 2);\n                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n                this.#last.set([\n                    x1 - thX,\n                    y1 - thY\n                ], 14);\n                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n            }\n            this.#last.set([\n                x0,\n                y0,\n                x1,\n                y1,\n                x2,\n                y2\n            ], 6);\n            return !this.isEmpty();\n        }\n        this.#last.set([\n            x0,\n            y0,\n            x1,\n            y1,\n            x2,\n            y2\n        ], 6);\n        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n        if (angle < Math.PI / 2) {\n            [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n            this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n            [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n            this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n            return true;\n        }\n        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n        return true;\n    }\n    toSVGPath() {\n        if (this.isEmpty()) {\n            return \"\";\n        }\n        const top = this.#top;\n        const bottom = this.#bottom;\n        if (isNaN(this.#last[6]) && !this.isEmpty()) {\n            return this.#toSVGPathTwoPoints();\n        }\n        const buffer = [];\n        buffer.push(`M${top[4]} ${top[5]}`);\n        for(let i = 6; i < top.length; i += 6){\n            if (isNaN(top[i])) {\n                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n            } else {\n                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n            }\n        }\n        this.#toSVGPathEnd(buffer);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            if (isNaN(bottom[i])) {\n                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n            } else {\n                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n            }\n        }\n        this.#toSVGPathStart(buffer);\n        return buffer.join(\" \");\n    }\n    #toSVGPathTwoPoints() {\n        const [x, y, width, height] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n    }\n    #toSVGPathStart(buffer) {\n        const bottom = this.#bottom;\n        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n    }\n    #toSVGPathEnd(buffer) {\n        const [x, y, width, height] = this.#box;\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n    }\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    getOutlines() {\n        const top = this.#top;\n        const bottom = this.#bottom;\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const points = new Float64Array((this.#points?.length ?? 0) + 2);\n        for(let i = 0, ii = points.length - 2; i < ii; i += 2){\n            points[i] = (this.#points[i] - layerX) / layerWidth;\n            points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n        }\n        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n        if (isNaN(last[6]) && !this.isEmpty()) {\n            return this.#getOutlineTwoPoints(points);\n        }\n        const outline = new Float64Array(this.#top.length + 24 + this.#bottom.length);\n        let N = top.length;\n        for(let i = 0; i < N; i += 2){\n            if (isNaN(top[i])) {\n                outline[i] = outline[i + 1] = NaN;\n                continue;\n            }\n            outline[i] = top[i];\n            outline[i + 1] = top[i + 1];\n        }\n        N = this.#getOutlineEnd(outline, N);\n        for(let i = bottom.length - 6; i >= 6; i -= 6){\n            for(let j = 0; j < 6; j += 2){\n                if (isNaN(bottom[i + j])) {\n                    outline[N] = outline[N + 1] = NaN;\n                    N += 2;\n                    continue;\n                }\n                outline[N] = bottom[i + j];\n                outline[N + 1] = bottom[i + j + 1];\n                N += 2;\n            }\n        }\n        this.#getOutlineStart(outline, N);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineTwoPoints(points) {\n        const last = this.#last;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        const outline = new Float64Array(36);\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[2] - layerX) / layerWidth,\n            (last[3] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[4] - layerX) / layerWidth,\n            (last[5] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[16] - layerX) / layerWidth,\n            (last[17] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (last[14] - layerX) / layerWidth,\n            (last[15] - layerY) / layerHeight\n        ], 0);\n        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n    }\n    #getOutlineStart(outline, pos) {\n        const bottom = this.#bottom;\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            bottom[4],\n            bottom[5]\n        ], pos);\n        return pos += 6;\n    }\n    #getOutlineEnd(outline, pos) {\n        const lastTop = this.#last.subarray(4, 6);\n        const lastBottom = this.#last.subarray(16, 18);\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n        outline.set([\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastTop[0] - layerX) / layerWidth,\n            (lastTop[1] - layerY) / layerHeight,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastTopX,\n            lastTopY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            lastBottomX,\n            lastBottomY,\n            NaN,\n            NaN,\n            NaN,\n            NaN,\n            (lastBottom[0] - layerX) / layerWidth,\n            (lastBottom[1] - layerY) / layerHeight\n        ], pos);\n        return pos += 24;\n    }\n}\nclass FreeDrawOutline extends Outline {\n    #box;\n    #bbox;\n    #innerMargin;\n    #isLTR;\n    #points;\n    #scaleFactor;\n    #outline;\n    constructor(outline, points, box, scaleFactor, innerMargin, isLTR){\n        super();\n        this.#bbox = null;\n        this.#outline = outline;\n        this.#points = points;\n        this.#box = box;\n        this.#scaleFactor = scaleFactor;\n        this.#innerMargin = innerMargin;\n        this.#isLTR = isLTR;\n        this.#computeMinMax(isLTR);\n        const { x, y, width, height } = this.#bbox;\n        for(let i = 0, ii = outline.length; i < ii; i += 2){\n            outline[i] = (outline[i] - x) / width;\n            outline[i + 1] = (outline[i + 1] - y) / height;\n        }\n        for(let i = 0, ii = points.length; i < ii; i += 2){\n            points[i] = (points[i] - x) / width;\n            points[i + 1] = (points[i + 1] - y) / height;\n        }\n    }\n    toSVGPath() {\n        const buffer = [\n            `M${this.#outline[4]} ${this.#outline[5]}`\n        ];\n        for(let i = 6, ii = this.#outline.length; i < ii; i += 6){\n            if (isNaN(this.#outline[i])) {\n                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n                continue;\n            }\n            buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        }\n        buffer.push(\"Z\");\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], rotation) {\n        const width = trX - blX;\n        const height = trY - blY;\n        let outline;\n        let points;\n        switch(rotation){\n            case 0:\n                outline = this.#rescale(this.#outline, blX, trY, width, -height);\n                points = this.#rescale(this.#points, blX, trY, width, -height);\n                break;\n            case 90:\n                outline = this.#rescaleAndSwap(this.#outline, blX, blY, width, height);\n                points = this.#rescaleAndSwap(this.#points, blX, blY, width, height);\n                break;\n            case 180:\n                outline = this.#rescale(this.#outline, trX, blY, -width, height);\n                points = this.#rescale(this.#points, trX, blY, -width, height);\n                break;\n            case 270:\n                outline = this.#rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n                points = this.#rescaleAndSwap(this.#points, trX, trY, -width, -height);\n                break;\n        }\n        return {\n            outline: Array.from(outline),\n            points: [\n                Array.from(points)\n            ]\n        };\n    }\n    #rescale(src, tx, ty, sx, sy) {\n        const dest = new Float64Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i] * sx;\n            dest[i + 1] = ty + src[i + 1] * sy;\n        }\n        return dest;\n    }\n    #rescaleAndSwap(src, tx, ty, sx, sy) {\n        const dest = new Float64Array(src.length);\n        for(let i = 0, ii = src.length; i < ii; i += 2){\n            dest[i] = tx + src[i + 1] * sx;\n            dest[i + 1] = ty + src[i] * sy;\n        }\n        return dest;\n    }\n    #computeMinMax(isLTR) {\n        const outline = this.#outline;\n        let lastX = outline[4];\n        let lastY = outline[5];\n        let minX = lastX;\n        let minY = lastY;\n        let maxX = lastX;\n        let maxY = lastY;\n        let lastPointX = lastX;\n        let lastPointY = lastY;\n        const ltrCallback = isLTR ? Math.max : Math.min;\n        for(let i = 6, ii = outline.length; i < ii; i += 6){\n            if (isNaN(outline[i])) {\n                minX = Math.min(minX, outline[i + 4]);\n                minY = Math.min(minY, outline[i + 5]);\n                maxX = Math.max(maxX, outline[i + 4]);\n                maxY = Math.max(maxY, outline[i + 5]);\n                if (lastPointY < outline[i + 5]) {\n                    lastPointX = outline[i + 4];\n                    lastPointY = outline[i + 5];\n                } else if (lastPointY === outline[i + 5]) {\n                    lastPointX = ltrCallback(lastPointX, outline[i + 4]);\n                }\n            } else {\n                const bbox = Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6));\n                minX = Math.min(minX, bbox[0]);\n                minY = Math.min(minY, bbox[1]);\n                maxX = Math.max(maxX, bbox[2]);\n                maxY = Math.max(maxY, bbox[3]);\n                if (lastPointY < bbox[3]) {\n                    lastPointX = bbox[2];\n                    lastPointY = bbox[3];\n                } else if (lastPointY === bbox[3]) {\n                    lastPointX = ltrCallback(lastPointX, bbox[2]);\n                }\n            }\n            lastX = outline[i + 4];\n            lastY = outline[i + 5];\n        }\n        const x = minX - this.#innerMargin, y = minY - this.#innerMargin, width = maxX - minX + 2 * this.#innerMargin, height = maxY - minY + 2 * this.#innerMargin;\n        this.#bbox = {\n            x,\n            y,\n            width,\n            height,\n            lastPoint: [\n                lastPointX,\n                lastPointY\n            ]\n        };\n    }\n    get box() {\n        return this.#bbox;\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n    getNewOutline(thickness, innerMargin) {\n        const { x, y, width, height } = this.#bbox;\n        const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n        const sx = width * layerWidth;\n        const sy = height * layerHeight;\n        const tx = x * layerWidth + layerX;\n        const ty = y * layerHeight + layerY;\n        const outliner = this.newOutliner({\n            x: this.#points[0] * sx + tx,\n            y: this.#points[1] * sy + ty\n        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n        for(let i = 2; i < this.#points.length; i += 2){\n            outliner.add({\n                x: this.#points[i] * sx + tx,\n                y: this.#points[i + 1] * sy + ty\n            });\n        }\n        return outliner.getOutlines();\n    }\n    get mustRemoveSelfIntersections() {\n        return true;\n    }\n}\n; // ./src/display/editor/drawers/highlight.js\nclass HighlightOutliner {\n    #box;\n    #verticalEdges;\n    #intervals;\n    constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true){\n        this.#verticalEdges = [];\n        this.#intervals = [];\n        let minX = Infinity;\n        let maxX = -Infinity;\n        let minY = Infinity;\n        let maxY = -Infinity;\n        const NUMBER_OF_DIGITS = 4;\n        const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n        for (const { x, y, width, height } of boxes){\n            const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n            const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n            const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n            const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n            const left = [\n                x1,\n                y1,\n                y2,\n                true\n            ];\n            const right = [\n                x2,\n                y1,\n                y2,\n                false\n            ];\n            this.#verticalEdges.push(left, right);\n            minX = Math.min(minX, x1);\n            maxX = Math.max(maxX, x2);\n            minY = Math.min(minY, y1);\n            maxY = Math.max(maxY, y2);\n        }\n        const bboxWidth = maxX - minX + 2 * innerMargin;\n        const bboxHeight = maxY - minY + 2 * innerMargin;\n        const shiftedMinX = minX - innerMargin;\n        const shiftedMinY = minY - innerMargin;\n        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n        const lastPoint = [\n            lastEdge[0],\n            lastEdge[2]\n        ];\n        for (const edge of this.#verticalEdges){\n            const [x, y1, y2] = edge;\n            edge[0] = (x - shiftedMinX) / bboxWidth;\n            edge[1] = (y1 - shiftedMinY) / bboxHeight;\n            edge[2] = (y2 - shiftedMinY) / bboxHeight;\n        }\n        this.#box = {\n            x: shiftedMinX,\n            y: shiftedMinY,\n            width: bboxWidth,\n            height: bboxHeight,\n            lastPoint\n        };\n    }\n    getOutlines() {\n        this.#verticalEdges.sort((a, b)=>a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n        const outlineVerticalEdges = [];\n        for (const edge of this.#verticalEdges){\n            if (edge[3]) {\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n                this.#insert(edge);\n            } else {\n                this.#remove(edge);\n                outlineVerticalEdges.push(...this.#breakEdge(edge));\n            }\n        }\n        return this.#getOutlines(outlineVerticalEdges);\n    }\n    #getOutlines(outlineVerticalEdges) {\n        const edges = [];\n        const allEdges = new Set();\n        for (const edge of outlineVerticalEdges){\n            const [x, y1, y2] = edge;\n            edges.push([\n                x,\n                y1,\n                edge\n            ], [\n                x,\n                y2,\n                edge\n            ]);\n        }\n        edges.sort((a, b)=>a[1] - b[1] || a[0] - b[0]);\n        for(let i = 0, ii = edges.length; i < ii; i += 2){\n            const edge1 = edges[i][2];\n            const edge2 = edges[i + 1][2];\n            edge1.push(edge2);\n            edge2.push(edge1);\n            allEdges.add(edge1);\n            allEdges.add(edge2);\n        }\n        const outlines = [];\n        let outline;\n        while(allEdges.size > 0){\n            const edge = allEdges.values().next().value;\n            let [x, y1, y2, edge1, edge2] = edge;\n            allEdges.delete(edge);\n            let lastPointX = x;\n            let lastPointY = y1;\n            outline = [\n                x,\n                y2\n            ];\n            outlines.push(outline);\n            while(true){\n                let e;\n                if (allEdges.has(edge1)) {\n                    e = edge1;\n                } else if (allEdges.has(edge2)) {\n                    e = edge2;\n                } else {\n                    break;\n                }\n                allEdges.delete(e);\n                [x, y1, y2, edge1, edge2] = e;\n                if (lastPointX !== x) {\n                    outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n                    lastPointX = x;\n                }\n                lastPointY = lastPointY === y1 ? y2 : y1;\n            }\n            outline.push(lastPointX, lastPointY);\n        }\n        return new HighlightOutline(outlines, this.#box);\n    }\n    #binarySearch(y) {\n        const array = this.#intervals;\n        let start = 0;\n        let end = array.length - 1;\n        while(start <= end){\n            const middle = start + end >> 1;\n            const y1 = array[middle][0];\n            if (y1 === y) {\n                return middle;\n            }\n            if (y1 < y) {\n                start = middle + 1;\n            } else {\n                end = middle - 1;\n            }\n        }\n        return end + 1;\n    }\n    #insert([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        this.#intervals.splice(index, 0, [\n            y1,\n            y2\n        ]);\n    }\n    #remove([, y1, y2]) {\n        const index = this.#binarySearch(y1);\n        for(let i = index; i < this.#intervals.length; i++){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n        for(let i = index - 1; i >= 0; i--){\n            const [start, end] = this.#intervals[i];\n            if (start !== y1) {\n                break;\n            }\n            if (start === y1 && end === y2) {\n                this.#intervals.splice(i, 1);\n                return;\n            }\n        }\n    }\n    #breakEdge(edge) {\n        const [x, y1, y2] = edge;\n        const results = [\n            [\n                x,\n                y1,\n                y2\n            ]\n        ];\n        const index = this.#binarySearch(y2);\n        for(let i = 0; i < index; i++){\n            const [start, end] = this.#intervals[i];\n            for(let j = 0, jj = results.length; j < jj; j++){\n                const [, y3, y4] = results[j];\n                if (end <= y3 || y4 <= start) {\n                    continue;\n                }\n                if (y3 >= start) {\n                    if (y4 > end) {\n                        results[j][1] = end;\n                    } else {\n                        if (jj === 1) {\n                            return [];\n                        }\n                        results.splice(j, 1);\n                        j--;\n                        jj--;\n                    }\n                    continue;\n                }\n                results[j][2] = start;\n                if (y4 > end) {\n                    results.push([\n                        x,\n                        end,\n                        y4\n                    ]);\n                }\n            }\n        }\n        return results;\n    }\n}\nclass HighlightOutline extends Outline {\n    #box;\n    #outlines;\n    constructor(outlines, box){\n        super();\n        this.#outlines = outlines;\n        this.#box = box;\n    }\n    toSVGPath() {\n        const buffer = [];\n        for (const polygon of this.#outlines){\n            let [prevX, prevY] = polygon;\n            buffer.push(`M${prevX} ${prevY}`);\n            for(let i = 2; i < polygon.length; i += 2){\n                const x = polygon[i];\n                const y = polygon[i + 1];\n                if (x === prevX) {\n                    buffer.push(`V${y}`);\n                    prevY = y;\n                } else if (y === prevY) {\n                    buffer.push(`H${x}`);\n                    prevX = x;\n                }\n            }\n            buffer.push(\"Z\");\n        }\n        return buffer.join(\" \");\n    }\n    serialize([blX, blY, trX, trY], _rotation) {\n        const outlines = [];\n        const width = trX - blX;\n        const height = trY - blY;\n        for (const outline of this.#outlines){\n            const points = new Array(outline.length);\n            for(let i = 0; i < outline.length; i += 2){\n                points[i] = blX + outline[i] * width;\n                points[i + 1] = trY - outline[i + 1] * height;\n            }\n            outlines.push(points);\n        }\n        return outlines;\n    }\n    get box() {\n        return this.#box;\n    }\n    get classNamesForDrawing() {\n        return [\n            \"highlight\"\n        ];\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\"\n        ];\n    }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n    newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n    }\n    get classNamesForDrawing() {\n        return [\n            \"highlight\",\n            \"free\"\n        ];\n    }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n    get classNamesForDrawing() {\n        return [\n            \"highlight\",\n            \"free\"\n        ];\n    }\n    get classNamesForOutlining() {\n        return [\n            \"highlightOutline\",\n            \"free\"\n        ];\n    }\n    newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n    }\n}\n; // ./src/display/editor/color_picker.js\nclass ColorPicker {\n    #button;\n    #buttonSwatch;\n    #defaultColor;\n    #dropdown;\n    #dropdownWasFromKeyboard;\n    #isMainColorPicker;\n    #editor;\n    #eventBus;\n    #openDropdownAC;\n    #uiManager;\n    #type;\n    static #l10nColor = null;\n    static get _keyboardManager() {\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"Escape\",\n                    \"mac+Escape\"\n                ],\n                ColorPicker.prototype._hideDropdownFromKeyboard\n            ],\n            [\n                [\n                    \" \",\n                    \"mac+ \"\n                ],\n                ColorPicker.prototype._colorSelectFromKeyboard\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"ArrowRight\",\n                    \"mac+ArrowDown\",\n                    \"mac+ArrowRight\"\n                ],\n                ColorPicker.prototype._moveToNext\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"ArrowLeft\",\n                    \"mac+ArrowUp\",\n                    \"mac+ArrowLeft\"\n                ],\n                ColorPicker.prototype._moveToPrevious\n            ],\n            [\n                [\n                    \"Home\",\n                    \"mac+Home\"\n                ],\n                ColorPicker.prototype._moveToBeginning\n            ],\n            [\n                [\n                    \"End\",\n                    \"mac+End\"\n                ],\n                ColorPicker.prototype._moveToEnd\n            ]\n        ]));\n    }\n    constructor({ editor = null, uiManager = null }){\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown = null;\n        this.#dropdownWasFromKeyboard = false;\n        this.#isMainColorPicker = false;\n        this.#editor = null;\n        this.#openDropdownAC = null;\n        this.#uiManager = null;\n        if (editor) {\n            this.#isMainColorPicker = false;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_COLOR;\n            this.#editor = editor;\n        } else {\n            this.#isMainColorPicker = true;\n            this.#type = AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR;\n        }\n        this.#uiManager = editor?._uiManager || uiManager;\n        this.#eventBus = this.#uiManager._eventBus;\n        this.#defaultColor = editor?.color || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n        ColorPicker.#l10nColor ||= Object.freeze({\n            blue: \"pdfjs-editor-colorpicker-blue\",\n            green: \"pdfjs-editor-colorpicker-green\",\n            pink: \"pdfjs-editor-colorpicker-pink\",\n            red: \"pdfjs-editor-colorpicker-red\",\n            yellow: \"pdfjs-editor-colorpicker-yellow\"\n        });\n    }\n    renderButton() {\n        const button = this.#button = document.createElement(\"button\");\n        button.className = \"colorPicker\";\n        button.tabIndex = \"0\";\n        button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n        button.setAttribute(\"aria-haspopup\", true);\n        const signal = this.#uiManager._signal;\n        button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n            signal\n        });\n        button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        const swatch = this.#buttonSwatch = document.createElement(\"span\");\n        swatch.className = \"swatch\";\n        swatch.setAttribute(\"aria-hidden\", true);\n        swatch.style.backgroundColor = this.#defaultColor;\n        button.append(swatch);\n        return button;\n    }\n    renderMainDropdown() {\n        const dropdown = this.#dropdown = this.#getDropdownRoot();\n        dropdown.setAttribute(\"aria-orientation\", \"horizontal\");\n        dropdown.setAttribute(\"aria-labelledby\", \"highlightColorPickerLabel\");\n        return dropdown;\n    }\n    #getDropdownRoot() {\n        const div = document.createElement(\"div\");\n        const signal = this.#uiManager._signal;\n        div.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        div.className = \"dropdown\";\n        div.role = \"listbox\";\n        div.setAttribute(\"aria-multiselectable\", false);\n        div.setAttribute(\"aria-orientation\", \"vertical\");\n        div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n        for (const [name, color] of this.#uiManager.highlightColors){\n            const button = document.createElement(\"button\");\n            button.tabIndex = \"0\";\n            button.role = \"option\";\n            button.setAttribute(\"data-color\", color);\n            button.title = name;\n            button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n            const swatch = document.createElement(\"span\");\n            button.append(swatch);\n            swatch.className = \"swatch\";\n            swatch.style.backgroundColor = color;\n            button.setAttribute(\"aria-selected\", color === this.#defaultColor);\n            button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n                signal\n            });\n            div.append(button);\n        }\n        div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n            signal\n        });\n        return div;\n    }\n    #colorSelect(color, event) {\n        event.stopPropagation();\n        this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n            source: this,\n            type: this.#type,\n            value: color\n        });\n    }\n    _colorSelectFromKeyboard(event) {\n        if (event.target === this.#button) {\n            this.#openDropdown(event);\n            return;\n        }\n        const color = event.target.getAttribute(\"data-color\");\n        if (!color) {\n            return;\n        }\n        this.#colorSelect(color, event);\n    }\n    _moveToNext(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        if (event.target === this.#button) {\n            this.#dropdown.firstChild?.focus();\n            return;\n        }\n        event.target.nextSibling?.focus();\n    }\n    _moveToPrevious(event) {\n        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {\n            if (this.#isDropdownVisible) {\n                this._hideDropdownFromKeyboard();\n            }\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n        }\n        event.target.previousSibling?.focus();\n    }\n    _moveToBeginning(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.firstChild?.focus();\n    }\n    _moveToEnd(event) {\n        if (!this.#isDropdownVisible) {\n            this.#openDropdown(event);\n            return;\n        }\n        this.#dropdown.lastChild?.focus();\n    }\n    #keyDown(event) {\n        ColorPicker._keyboardManager.exec(this, event);\n    }\n    #openDropdown(event) {\n        if (this.#isDropdownVisible) {\n            this.hideDropdown();\n            return;\n        }\n        this.#dropdownWasFromKeyboard = event.detail === 0;\n        if (!this.#openDropdownAC) {\n            this.#openDropdownAC = new AbortController();\n            window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n            });\n        }\n        if (this.#dropdown) {\n            this.#dropdown.classList.remove(\"hidden\");\n            return;\n        }\n        const root = this.#dropdown = this.#getDropdownRoot();\n        this.#button.append(root);\n    }\n    #pointerDown(event) {\n        if (this.#dropdown?.contains(event.target)) {\n            return;\n        }\n        this.hideDropdown();\n    }\n    hideDropdown() {\n        this.#dropdown?.classList.add(\"hidden\");\n        this.#openDropdownAC?.abort();\n        this.#openDropdownAC = null;\n    }\n    get #isDropdownVisible() {\n        return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n    }\n    _hideDropdownFromKeyboard() {\n        if (this.#isMainColorPicker) {\n            return;\n        }\n        if (!this.#isDropdownVisible) {\n            this.#editor?.unselect();\n            return;\n        }\n        this.hideDropdown();\n        this.#button.focus({\n            preventScroll: true,\n            focusVisible: this.#dropdownWasFromKeyboard\n        });\n    }\n    updateColor(color) {\n        if (this.#buttonSwatch) {\n            this.#buttonSwatch.style.backgroundColor = color;\n        }\n        if (!this.#dropdown) {\n            return;\n        }\n        const i = this.#uiManager.highlightColors.values();\n        for (const child of this.#dropdown.children){\n            child.setAttribute(\"aria-selected\", i.next().value === color);\n        }\n    }\n    destroy() {\n        this.#button?.remove();\n        this.#button = null;\n        this.#buttonSwatch = null;\n        this.#dropdown?.remove();\n        this.#dropdown = null;\n    }\n}\n; // ./src/display/editor/highlight.js\nclass HighlightEditor extends AnnotationEditor {\n    #anchorNode;\n    #anchorOffset;\n    #boxes;\n    #clipPathId;\n    #colorPicker;\n    #focusOutlines;\n    #focusNode;\n    #focusOffset;\n    #highlightDiv;\n    #highlightOutlines;\n    #id;\n    #isFreeHighlight;\n    #lastPoint;\n    #opacity;\n    #outlineId;\n    #text;\n    #thickness;\n    #methodOfCreation;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 12;\n    }\n    static{\n        this._type = \"highlight\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.HIGHLIGHT;\n    }\n    static{\n        this._freeHighlightId = -1;\n    }\n    static{\n        this._freeHighlight = null;\n    }\n    static{\n        this._freeHighlightClipId = \"\";\n    }\n    static get _keyboardManager() {\n        const proto = HighlightEditor.prototype;\n        return shadow(this, \"_keyboardManager\", new KeyboardManager([\n            [\n                [\n                    \"ArrowLeft\",\n                    \"mac+ArrowLeft\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        0\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowRight\",\n                    \"mac+ArrowRight\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        1\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowUp\",\n                    \"mac+ArrowUp\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        2\n                    ]\n                }\n            ],\n            [\n                [\n                    \"ArrowDown\",\n                    \"mac+ArrowDown\"\n                ],\n                proto._moveCaret,\n                {\n                    args: [\n                        3\n                    ]\n                }\n            ]\n        ]));\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"highlightEditor\"\n        });\n        this.#anchorNode = null;\n        this.#anchorOffset = 0;\n        this.#clipPathId = null;\n        this.#colorPicker = null;\n        this.#focusOutlines = null;\n        this.#focusNode = null;\n        this.#focusOffset = 0;\n        this.#highlightDiv = null;\n        this.#highlightOutlines = null;\n        this.#id = null;\n        this.#isFreeHighlight = false;\n        this.#lastPoint = null;\n        this.#outlineId = null;\n        this.#text = \"\";\n        this.#methodOfCreation = \"\";\n        this.color = params.color || HighlightEditor._defaultColor;\n        this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n        this.#opacity = params.opacity || HighlightEditor._defaultOpacity;\n        this.#boxes = params.boxes || null;\n        this.#methodOfCreation = params.methodOfCreation || \"\";\n        this.#text = params.text || \"\";\n        this._isDraggable = false;\n        if (params.highlightId > -1) {\n            this.#isFreeHighlight = true;\n            this.#createFreeOutlines(params);\n            this.#addToDrawLayer();\n        } else if (this.#boxes) {\n            this.#anchorNode = params.anchorNode;\n            this.#anchorOffset = params.anchorOffset;\n            this.#focusNode = params.focusNode;\n            this.#focusOffset = params.focusOffset;\n            this.#createOutlines();\n            this.#addToDrawLayer();\n            this.rotate(this.rotation);\n        }\n    }\n    get telemetryInitialData() {\n        return {\n            action: \"added\",\n            type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color),\n            thickness: this.#thickness,\n            methodOfCreation: this.#methodOfCreation\n        };\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"highlight\",\n            color: this._uiManager.highlightColorNames.get(this.color)\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        return {\n            numberOfColors: data.get(\"color\").size\n        };\n    }\n    #createOutlines() {\n        const outliner = new HighlightOutliner(this.#boxes, 0.001);\n        this.#highlightOutlines = outliner.getOutlines();\n        ({ x: this.x, y: this.y, width: this.width, height: this.height } = this.#highlightOutlines.box);\n        const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n        this.#focusOutlines = outlinerForOutline.getOutlines();\n        const { lastPoint } = this.#focusOutlines.box;\n        this.#lastPoint = [\n            (lastPoint[0] - this.x) / this.width,\n            (lastPoint[1] - this.y) / this.height\n        ];\n    }\n    #createFreeOutlines({ highlightOutlines, highlightId, clipPathId }) {\n        this.#highlightOutlines = highlightOutlines;\n        const extraThickness = 1.5;\n        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n        if (highlightId >= 0) {\n            this.#id = highlightId;\n            this.#clipPathId = clipPathId;\n            this.parent.drawLayer.finalizeLine(highlightId, highlightOutlines);\n            this.#outlineId = this.parent.drawLayer.drawOutline(this.#focusOutlines);\n        } else if (this.parent) {\n            const angle = this.parent.viewport.rotation;\n            this.parent.drawLayer.updateLine(this.#id, highlightOutlines);\n            this.parent.drawLayer.updateBox(this.#id, HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360));\n            this.parent.drawLayer.updateLine(this.#outlineId, this.#focusOutlines);\n            this.parent.drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));\n        }\n        const { x, y, width, height } = highlightOutlines.box;\n        switch(this.rotation){\n            case 0:\n                this.x = x;\n                this.y = y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 90:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = y;\n                    this.y = 1 - x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n            case 180:\n                this.x = 1 - x;\n                this.y = 1 - y;\n                this.width = width;\n                this.height = height;\n                break;\n            case 270:\n                {\n                    const [pageWidth, pageHeight] = this.parentDimensions;\n                    this.x = 1 - y;\n                    this.y = x;\n                    this.width = width * pageHeight / pageWidth;\n                    this.height = height * pageWidth / pageHeight;\n                    break;\n                }\n        }\n        const { lastPoint } = this.#focusOutlines.box;\n        this.#lastPoint = [\n            (lastPoint[0] - x) / width,\n            (lastPoint[1] - y) / height\n        ];\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n        HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR:\n                HighlightEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                HighlightEditor._defaultThickness = value;\n                break;\n        }\n    }\n    translateInPage(x, y) {}\n    get toolbarPosition() {\n        return this.#lastPoint;\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n                this.#updateThickness(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_DEFAULT_COLOR,\n                HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                HighlightEditor._defaultThickness\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n                this.color || HighlightEditor._defaultColor\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_THICKNESS,\n                this.#thickness || HighlightEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.HIGHLIGHT_FREE,\n                this.#isFreeHighlight\n            ]\n        ];\n    }\n    #updateColor(color) {\n        const setColorAndOpacity = (col, opa)=>{\n            this.color = col;\n            this.parent?.drawLayer.changeColor(this.#id, col);\n            this.#colorPicker?.updateColor(col);\n            this.#opacity = opa;\n            this.parent?.drawLayer.changeOpacity(this.#id, opa);\n        };\n        const savedColor = this.color;\n        const savedOpacity = this.#opacity;\n        this.addCommands({\n            cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n            undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"color_changed\",\n            color: this._uiManager.highlightColorNames.get(color)\n        }, true);\n    }\n    #updateThickness(thickness) {\n        const savedThickness = this.#thickness;\n        const setThickness = (th)=>{\n            this.#thickness = th;\n            this.#changeThickness(th);\n        };\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n        this._reportTelemetry({\n            action: \"thickness_changed\",\n            thickness\n        }, true);\n    }\n    async addEditToolbar() {\n        const toolbar = await super.addEditToolbar();\n        if (!toolbar) {\n            return null;\n        }\n        if (this._uiManager.highlightColors) {\n            this.#colorPicker = new ColorPicker({\n                editor: this\n            });\n            toolbar.addColorPicker(this.#colorPicker);\n        }\n        return toolbar;\n    }\n    disableEditing() {\n        super.disableEditing();\n        this.div.classList.toggle(\"disabled\", true);\n    }\n    enableEditing() {\n        super.enableEditing();\n        this.div.classList.toggle(\"disabled\", false);\n    }\n    fixAndSetPosition() {\n        return super.fixAndSetPosition(this.#getRotation());\n    }\n    getBaseTranslation() {\n        return [\n            0,\n            0\n        ];\n    }\n    getRect(tx, ty) {\n        return super.getRect(tx, ty, this.#getRotation());\n    }\n    onceAdded() {\n        if (!this.annotationElementId) {\n            this.parent.addUndoableEditor(this);\n        }\n        this.div.focus();\n    }\n    remove() {\n        this.#cleanDrawLayer();\n        this._reportTelemetry({\n            action: \"deleted\"\n        });\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        this.#addToDrawLayer();\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    setParent(parent) {\n        let mustBeSelected = false;\n        if (this.parent && !parent) {\n            this.#cleanDrawLayer();\n        } else if (parent) {\n            this.#addToDrawLayer(parent);\n            mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n        }\n        super.setParent(parent);\n        this.show(this._isVisible);\n        if (mustBeSelected) {\n            this.select();\n        }\n    }\n    #changeThickness(thickness) {\n        if (!this.#isFreeHighlight) {\n            return;\n        }\n        this.#createFreeOutlines({\n            highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n        });\n        this.fixAndSetPosition();\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n    }\n    #cleanDrawLayer() {\n        if (this.#id === null || !this.parent) {\n            return;\n        }\n        this.parent.drawLayer.remove(this.#id);\n        this.#id = null;\n        this.parent.drawLayer.remove(this.#outlineId);\n        this.#outlineId = null;\n    }\n    #addToDrawLayer(parent = this.parent) {\n        if (this.#id !== null) {\n            return;\n        }\n        ({ id: this.#id, clipPathId: this.#clipPathId } = parent.drawLayer.draw(this.#highlightOutlines, this.color, this.#opacity));\n        this.#outlineId = parent.drawLayer.drawOutline(this.#focusOutlines);\n        if (this.#highlightDiv) {\n            this.#highlightDiv.style.clipPath = this.#clipPathId;\n        }\n    }\n    static #rotateBbox({ x, y, width, height }, angle) {\n        switch(angle){\n            case 90:\n                return {\n                    x: 1 - y - height,\n                    y: x,\n                    width: height,\n                    height: width\n                };\n            case 180:\n                return {\n                    x: 1 - x - width,\n                    y: 1 - y - height,\n                    width,\n                    height\n                };\n            case 270:\n                return {\n                    x: y,\n                    y: 1 - x - width,\n                    width: height,\n                    height: width\n                };\n        }\n        return {\n            x,\n            y,\n            width,\n            height\n        };\n    }\n    rotate(angle) {\n        const { drawLayer } = this.parent;\n        let box;\n        if (this.#isFreeHighlight) {\n            angle = (angle - this.rotation + 360) % 360;\n            box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n        } else {\n            box = HighlightEditor.#rotateBbox(this, angle);\n        }\n        drawLayer.rotate(this.#id, angle);\n        drawLayer.rotate(this.#outlineId, angle);\n        drawLayer.updateBox(this.#id, box);\n        drawLayer.updateBox(this.#outlineId, HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle));\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        const div = super.render();\n        if (this.#text) {\n            div.setAttribute(\"aria-label\", this.#text);\n            div.setAttribute(\"role\", \"mark\");\n        }\n        if (this.#isFreeHighlight) {\n            div.classList.add(\"free\");\n        } else {\n            this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n                signal: this._uiManager._signal\n            });\n        }\n        const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n        div.append(highlightDiv);\n        highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n        highlightDiv.className = \"internal\";\n        highlightDiv.style.clipPath = this.#clipPathId;\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(this.width * parentWidth, this.height * parentHeight);\n        bindEvents(this, this.#highlightDiv, [\n            \"pointerover\",\n            \"pointerleave\"\n        ]);\n        this.enableEditing();\n        return div;\n    }\n    pointerover() {\n        if (!this.isSelected) {\n            this.parent.drawLayer.addClass(this.#outlineId, \"hovered\");\n        }\n    }\n    pointerleave() {\n        if (!this.isSelected) {\n            this.parent.drawLayer.removeClass(this.#outlineId, \"hovered\");\n        }\n    }\n    #keydown(event) {\n        HighlightEditor._keyboardManager.exec(this, event);\n    }\n    _moveCaret(direction) {\n        this.parent.unselect(this);\n        switch(direction){\n            case 0:\n            case 2:\n                this.#setCaret(true);\n                break;\n            case 1:\n            case 3:\n                this.#setCaret(false);\n                break;\n        }\n    }\n    #setCaret(start) {\n        if (!this.#anchorNode) {\n            return;\n        }\n        const selection = window.getSelection();\n        if (start) {\n            selection.setPosition(this.#anchorNode, this.#anchorOffset);\n        } else {\n            selection.setPosition(this.#focusNode, this.#focusOffset);\n        }\n    }\n    select() {\n        super.select();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.removeClass(this.#outlineId, \"hovered\");\n        this.parent?.drawLayer.addClass(this.#outlineId, \"selected\");\n    }\n    unselect() {\n        super.unselect();\n        if (!this.#outlineId) {\n            return;\n        }\n        this.parent?.drawLayer.removeClass(this.#outlineId, \"selected\");\n        if (!this.#isFreeHighlight) {\n            this.#setCaret(false);\n        }\n    }\n    get _mustFixPosition() {\n        return !this.#isFreeHighlight;\n    }\n    show(visible = this._isVisible) {\n        super.show(visible);\n        if (this.parent) {\n            this.parent.drawLayer.show(this.#id, visible);\n            this.parent.drawLayer.show(this.#outlineId, visible);\n        }\n    }\n    #getRotation() {\n        return this.#isFreeHighlight ? this.rotation : 0;\n    }\n    #serializeBoxes() {\n        if (this.#isFreeHighlight) {\n            return null;\n        }\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        const boxes = this.#boxes;\n        const quadPoints = new Float32Array(boxes.length * 8);\n        let i = 0;\n        for (const { x, y, width, height } of boxes){\n            const sx = x * pageWidth + pageX;\n            const sy = (1 - y - height) * pageHeight + pageY;\n            quadPoints[i] = quadPoints[i + 4] = sx;\n            quadPoints[i + 1] = quadPoints[i + 3] = sy;\n            quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n            quadPoints[i + 5] = quadPoints[i + 7] = sy + height * pageHeight;\n            i += 8;\n        }\n        return quadPoints;\n    }\n    #serializeOutlines(rect) {\n        return this.#highlightOutlines.serialize(rect, this.#getRotation());\n    }\n    static startHighlighting(parent, isLTR, { target: textLayer, x, y }) {\n        const { x: layerX, y: layerY, width: parentWidth, height: parentHeight } = textLayer.getBoundingClientRect();\n        const ac = new AbortController();\n        const signal = parent.combinedSignal(ac);\n        const pointerDown = (e)=>{\n            e.preventDefault();\n            e.stopPropagation();\n        };\n        const pointerUpCallback = (e)=>{\n            ac.abort();\n            this.#endHighlight(parent, e);\n        };\n        window.addEventListener(\"blur\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerup\", pointerUpCallback, {\n            signal\n        });\n        window.addEventListener(\"pointerdown\", pointerDown, {\n            capture: true,\n            passive: false,\n            signal\n        });\n        window.addEventListener(\"contextmenu\", noContextMenu, {\n            signal\n        });\n        textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n            signal\n        });\n        this._freeHighlight = new FreeHighlightOutliner({\n            x,\n            y\n        }, [\n            layerX,\n            layerY,\n            parentWidth,\n            parentHeight\n        ], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n        ({ id: this._freeHighlightId, clipPathId: this._freeHighlightClipId } = parent.drawLayer.draw(this._freeHighlight, this._defaultColor, this._defaultOpacity, true));\n    }\n    static #highlightMove(parent, event) {\n        if (this._freeHighlight.add(event)) {\n            parent.drawLayer.updatePath(this._freeHighlightId, this._freeHighlight);\n        }\n    }\n    static #endHighlight(parent, event) {\n        if (!this._freeHighlight.isEmpty()) {\n            parent.createAndAddNewEditor(event, false, {\n                highlightId: this._freeHighlightId,\n                highlightOutlines: this._freeHighlight.getOutlines(),\n                clipPathId: this._freeHighlightClipId,\n                methodOfCreation: \"main_toolbar\"\n            });\n        } else {\n            parent.drawLayer.remove(this._freeHighlightId);\n        }\n        this._freeHighlightId = -1;\n        this._freeHighlight = null;\n        this._freeHighlightClipId = \"\";\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof HighlightAnnotationElement) {\n            const { data: { quadPoints, rect, rotation, id, color, opacity, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                opacity,\n                quadPoints,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        } else if (data instanceof InkAnnotationElement) {\n            const { data: { inkLists, rect, rotation, id, color, borderStyle: { rawWidth: thickness }, popupRef }, parent: { page: { pageNumber } } } = data;\n            initialData = data = {\n                annotationType: AnnotationEditorType.HIGHLIGHT,\n                color: Array.from(color),\n                thickness,\n                inkLists,\n                boxes: null,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                popupRef\n            };\n        }\n        const { color, quadPoints, inkLists, opacity } = data;\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.color = Util.makeHexColor(...color);\n        editor.#opacity = opacity || 1;\n        if (inkLists) {\n            editor.#thickness = data.thickness;\n        }\n        editor.annotationElementId = data.id || null;\n        editor._initialData = initialData;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const [pageX, pageY] = editor.pageTranslation;\n        if (quadPoints) {\n            const boxes = editor.#boxes = [];\n            for(let i = 0; i < quadPoints.length; i += 8){\n                boxes.push({\n                    x: (quadPoints[i] - pageX) / pageWidth,\n                    y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n                    width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n                    height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n                });\n            }\n            editor.#createOutlines();\n            editor.#addToDrawLayer();\n            editor.rotate(editor.rotation);\n        } else if (inkLists) {\n            editor.#isFreeHighlight = true;\n            const points = inkLists[0];\n            const point = {\n                x: points[0] - pageX,\n                y: pageHeight - (points[1] - pageY)\n            };\n            const outliner = new FreeHighlightOutliner(point, [\n                0,\n                0,\n                pageWidth,\n                pageHeight\n            ], 1, editor.#thickness / 2, true, 0.001);\n            for(let i = 0, ii = points.length; i < ii; i += 2){\n                point.x = points[i] - pageX;\n                point.y = pageHeight - (points[i + 1] - pageY);\n                outliner.add(point);\n            }\n            const { id, clipPathId } = parent.drawLayer.draw(outliner, editor.color, editor._defaultOpacity, true);\n            editor.#createFreeOutlines({\n                highlightOutlines: outliner.getOutlines(),\n                highlightId: id,\n                clipPathId\n            });\n            editor.#addToDrawLayer();\n        }\n        return editor;\n    }\n    serialize(isForCopying = false) {\n        if (this.isEmpty() || isForCopying) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const rect = this.getRect(0, 0);\n        const color = AnnotationEditor._colorManager.convert(this.color);\n        const serialized = {\n            annotationType: AnnotationEditorType.HIGHLIGHT,\n            color,\n            opacity: this.#opacity,\n            thickness: this.#thickness,\n            quadPoints: this.#serializeBoxes(),\n            outlines: this.#serializeOutlines(rect),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.#getRotation(),\n            structTreeParentId: this._structTreeParentId\n        };\n        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n            return null;\n        }\n        serialized.id = this.annotationElementId;\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { color } = this._initialData;\n        return serialized.color.some((c, i)=>c !== color[i]);\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n    static canCreateNewEmptyEditor() {\n        return false;\n    }\n}\n; // ./src/display/editor/ink.js\nclass InkEditor extends AnnotationEditor {\n    #baseHeight;\n    #baseWidth;\n    #canvasContextMenuTimeoutId;\n    #currentPath2D;\n    #disableEditing;\n    #drawingAC;\n    #hasSomethingToDraw;\n    #isCanvasInitialized;\n    #observer;\n    #pointerdownAC;\n    #realWidth;\n    #realHeight;\n    #requestFrameCallback;\n    static{\n        this._defaultColor = null;\n    }\n    static{\n        this._defaultOpacity = 1;\n    }\n    static{\n        this._defaultThickness = 1;\n    }\n    static{\n        this._type = \"ink\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.INK;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"inkEditor\"\n        });\n        this.#baseHeight = 0;\n        this.#baseWidth = 0;\n        this.#canvasContextMenuTimeoutId = null;\n        this.#currentPath2D = new Path2D();\n        this.#disableEditing = false;\n        this.#drawingAC = null;\n        this.#hasSomethingToDraw = false;\n        this.#isCanvasInitialized = false;\n        this.#observer = null;\n        this.#pointerdownAC = null;\n        this.#realWidth = 0;\n        this.#realHeight = 0;\n        this.#requestFrameCallback = null;\n        this.color = params.color || null;\n        this.thickness = params.thickness || null;\n        this.opacity = params.opacity || null;\n        this.paths = [];\n        this.bezierPath2D = [];\n        this.allRawPaths = [];\n        this.currentPath = [];\n        this.scaleFactor = 1;\n        this.translationX = this.translationY = 0;\n        this.x = 0;\n        this.y = 0;\n        this._willKeepAspectRatio = true;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static updateDefaultParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.INK_THICKNESS:\n                InkEditor._defaultThickness = value;\n                break;\n            case AnnotationEditorParamsType.INK_COLOR:\n                InkEditor._defaultColor = value;\n                break;\n            case AnnotationEditorParamsType.INK_OPACITY:\n                InkEditor._defaultOpacity = value / 100;\n                break;\n        }\n    }\n    updateParams(type, value) {\n        switch(type){\n            case AnnotationEditorParamsType.INK_THICKNESS:\n                this.#updateThickness(value);\n                break;\n            case AnnotationEditorParamsType.INK_COLOR:\n                this.#updateColor(value);\n                break;\n            case AnnotationEditorParamsType.INK_OPACITY:\n                this.#updateOpacity(value);\n                break;\n        }\n    }\n    static get defaultPropertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                InkEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                InkEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                Math.round(InkEditor._defaultOpacity * 100)\n            ]\n        ];\n    }\n    get propertiesToUpdate() {\n        return [\n            [\n                AnnotationEditorParamsType.INK_THICKNESS,\n                this.thickness || InkEditor._defaultThickness\n            ],\n            [\n                AnnotationEditorParamsType.INK_COLOR,\n                this.color || InkEditor._defaultColor || AnnotationEditor._defaultLineColor\n            ],\n            [\n                AnnotationEditorParamsType.INK_OPACITY,\n                Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))\n            ]\n        ];\n    }\n    #updateThickness(thickness) {\n        const setThickness = (th)=>{\n            this.thickness = th;\n            this.#fitToContent();\n        };\n        const savedThickness = this.thickness;\n        this.addCommands({\n            cmd: setThickness.bind(this, thickness),\n            undo: setThickness.bind(this, savedThickness),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_THICKNESS,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    #updateColor(color) {\n        const setColor = (col)=>{\n            this.color = col;\n            this.#redraw();\n        };\n        const savedColor = this.color;\n        this.addCommands({\n            cmd: setColor.bind(this, color),\n            undo: setColor.bind(this, savedColor),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_COLOR,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    #updateOpacity(opacity) {\n        const setOpacity = (op)=>{\n            this.opacity = op;\n            this.#redraw();\n        };\n        opacity /= 100;\n        const savedOpacity = this.opacity;\n        this.addCommands({\n            cmd: setOpacity.bind(this, opacity),\n            undo: setOpacity.bind(this, savedOpacity),\n            post: this._uiManager.updateUI.bind(this._uiManager, this),\n            mustExec: true,\n            type: AnnotationEditorParamsType.INK_OPACITY,\n            overwriteIfSameType: true,\n            keepUndo: true\n        });\n    }\n    rebuild() {\n        if (!this.parent) {\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (!this.canvas) {\n            this.#createCanvas();\n            this.#createObserver();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n            this.#setCanvasDims();\n        }\n        this.#fitToContent();\n    }\n    remove() {\n        if (this.canvas === null) {\n            return;\n        }\n        if (!this.isEmpty()) {\n            this.commit();\n        }\n        this.canvas.width = this.canvas.height = 0;\n        this.canvas.remove();\n        this.canvas = null;\n        if (this.#canvasContextMenuTimeoutId) {\n            clearTimeout(this.#canvasContextMenuTimeoutId);\n            this.#canvasContextMenuTimeoutId = null;\n        }\n        this.#observer?.disconnect();\n        this.#observer = null;\n        super.remove();\n    }\n    setParent(parent) {\n        if (!this.parent && parent) {\n            this._uiManager.removeShouldRescale(this);\n        } else if (this.parent && parent === null) {\n            this._uiManager.addShouldRescale(this);\n        }\n        super.setParent(parent);\n    }\n    onScaleChanging() {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        const width = this.width * parentWidth;\n        const height = this.height * parentHeight;\n        this.setDimensions(width, height);\n    }\n    enableEditMode() {\n        if (this.#disableEditing || this.canvas === null) {\n            return;\n        }\n        super.enableEditMode();\n        this._isDraggable = false;\n        this.#addPointerdownListener();\n    }\n    disableEditMode() {\n        if (!this.isInEditMode() || this.canvas === null) {\n            return;\n        }\n        super.disableEditMode();\n        this._isDraggable = !this.isEmpty();\n        this.div.classList.remove(\"editing\");\n        this.#removePointerdownListener();\n    }\n    onceAdded() {\n        this._isDraggable = !this.isEmpty();\n    }\n    isEmpty() {\n        return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n    }\n    #getInitialBBox() {\n        const { parentRotation, parentDimensions: [width, height] } = this;\n        switch(parentRotation){\n            case 90:\n                return [\n                    0,\n                    height,\n                    height,\n                    width\n                ];\n            case 180:\n                return [\n                    width,\n                    height,\n                    width,\n                    height\n                ];\n            case 270:\n                return [\n                    width,\n                    0,\n                    height,\n                    width\n                ];\n            default:\n                return [\n                    0,\n                    0,\n                    width,\n                    height\n                ];\n        }\n    }\n    #setStroke() {\n        const { ctx, color, opacity, thickness, parentScale, scaleFactor } = this;\n        ctx.lineWidth = thickness * parentScale / scaleFactor;\n        ctx.lineCap = \"round\";\n        ctx.lineJoin = \"round\";\n        ctx.miterLimit = 10;\n        ctx.strokeStyle = `${color}${opacityToHex(opacity)}`;\n    }\n    #startDrawing(x, y) {\n        this.canvas.addEventListener(\"contextmenu\", noContextMenu, {\n            signal: this._uiManager._signal\n        });\n        this.#removePointerdownListener();\n        this.#drawingAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#drawingAC);\n        this.canvas.addEventListener(\"pointerleave\", this.canvasPointerleave.bind(this), {\n            signal\n        });\n        this.canvas.addEventListener(\"pointermove\", this.canvasPointermove.bind(this), {\n            signal\n        });\n        this.canvas.addEventListener(\"pointerup\", this.canvasPointerup.bind(this), {\n            signal\n        });\n        this.isEditing = true;\n        if (!this.#isCanvasInitialized) {\n            this.#isCanvasInitialized = true;\n            this.#setCanvasDims();\n            this.thickness ||= InkEditor._defaultThickness;\n            this.color ||= InkEditor._defaultColor || AnnotationEditor._defaultLineColor;\n            this.opacity ??= InkEditor._defaultOpacity;\n        }\n        this.currentPath.push([\n            x,\n            y\n        ]);\n        this.#hasSomethingToDraw = false;\n        this.#setStroke();\n        this.#requestFrameCallback = ()=>{\n            this.#drawPoints();\n            if (this.#requestFrameCallback) {\n                window.requestAnimationFrame(this.#requestFrameCallback);\n            }\n        };\n        window.requestAnimationFrame(this.#requestFrameCallback);\n    }\n    #draw(x, y) {\n        const [lastX, lastY] = this.currentPath.at(-1);\n        if (this.currentPath.length > 1 && x === lastX && y === lastY) {\n            return;\n        }\n        const currentPath = this.currentPath;\n        let path2D = this.#currentPath2D;\n        currentPath.push([\n            x,\n            y\n        ]);\n        this.#hasSomethingToDraw = true;\n        if (currentPath.length <= 2) {\n            path2D.moveTo(...currentPath[0]);\n            path2D.lineTo(x, y);\n            return;\n        }\n        if (currentPath.length === 3) {\n            this.#currentPath2D = path2D = new Path2D();\n            path2D.moveTo(...currentPath[0]);\n        }\n        this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);\n    }\n    #endPath() {\n        if (this.currentPath.length === 0) {\n            return;\n        }\n        const lastPoint = this.currentPath.at(-1);\n        this.#currentPath2D.lineTo(...lastPoint);\n    }\n    #stopDrawing(x, y) {\n        this.#requestFrameCallback = null;\n        x = Math.min(Math.max(x, 0), this.canvas.width);\n        y = Math.min(Math.max(y, 0), this.canvas.height);\n        this.#draw(x, y);\n        this.#endPath();\n        let bezier;\n        if (this.currentPath.length !== 1) {\n            bezier = this.#generateBezierPoints();\n        } else {\n            const xy = [\n                x,\n                y\n            ];\n            bezier = [\n                [\n                    xy,\n                    xy.slice(),\n                    xy.slice(),\n                    xy\n                ]\n            ];\n        }\n        const path2D = this.#currentPath2D;\n        const currentPath = this.currentPath;\n        this.currentPath = [];\n        this.#currentPath2D = new Path2D();\n        const cmd = ()=>{\n            this.allRawPaths.push(currentPath);\n            this.paths.push(bezier);\n            this.bezierPath2D.push(path2D);\n            this._uiManager.rebuild(this);\n        };\n        const undo = ()=>{\n            this.allRawPaths.pop();\n            this.paths.pop();\n            this.bezierPath2D.pop();\n            if (this.paths.length === 0) {\n                this.remove();\n            } else {\n                if (!this.canvas) {\n                    this.#createCanvas();\n                    this.#createObserver();\n                }\n                this.#fitToContent();\n            }\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: true\n        });\n    }\n    #drawPoints() {\n        if (!this.#hasSomethingToDraw) {\n            return;\n        }\n        this.#hasSomethingToDraw = false;\n        const thickness = Math.ceil(this.thickness * this.parentScale);\n        const lastPoints = this.currentPath.slice(-3);\n        const x = lastPoints.map((xy)=>xy[0]);\n        const y = lastPoints.map((xy)=>xy[1]);\n        const xMin = Math.min(...x) - thickness;\n        const xMax = Math.max(...x) + thickness;\n        const yMin = Math.min(...y) - thickness;\n        const yMax = Math.max(...y) + thickness;\n        const { ctx } = this;\n        ctx.save();\n        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        for (const path of this.bezierPath2D){\n            ctx.stroke(path);\n        }\n        ctx.stroke(this.#currentPath2D);\n        ctx.restore();\n    }\n    #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {\n        const prevX = (x0 + x1) / 2;\n        const prevY = (y0 + y1) / 2;\n        const x3 = (x1 + x2) / 2;\n        const y3 = (y1 + y2) / 2;\n        path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);\n    }\n    #generateBezierPoints() {\n        const path = this.currentPath;\n        if (path.length <= 2) {\n            return [\n                [\n                    path[0],\n                    path[0],\n                    path.at(-1),\n                    path.at(-1)\n                ]\n            ];\n        }\n        const bezierPoints = [];\n        let i;\n        let [x0, y0] = path[0];\n        for(i = 1; i < path.length - 2; i++){\n            const [x1, y1] = path[i];\n            const [x2, y2] = path[i + 1];\n            const x3 = (x1 + x2) / 2;\n            const y3 = (y1 + y2) / 2;\n            const control1 = [\n                x0 + 2 * (x1 - x0) / 3,\n                y0 + 2 * (y1 - y0) / 3\n            ];\n            const control2 = [\n                x3 + 2 * (x1 - x3) / 3,\n                y3 + 2 * (y1 - y3) / 3\n            ];\n            bezierPoints.push([\n                [\n                    x0,\n                    y0\n                ],\n                control1,\n                control2,\n                [\n                    x3,\n                    y3\n                ]\n            ]);\n            [x0, y0] = [\n                x3,\n                y3\n            ];\n        }\n        const [x1, y1] = path[i];\n        const [x2, y2] = path[i + 1];\n        const control1 = [\n            x0 + 2 * (x1 - x0) / 3,\n            y0 + 2 * (y1 - y0) / 3\n        ];\n        const control2 = [\n            x2 + 2 * (x1 - x2) / 3,\n            y2 + 2 * (y1 - y2) / 3\n        ];\n        bezierPoints.push([\n            [\n                x0,\n                y0\n            ],\n            control1,\n            control2,\n            [\n                x2,\n                y2\n            ]\n        ]);\n        return bezierPoints;\n    }\n    #redraw() {\n        if (this.isEmpty()) {\n            this.#updateTransform();\n            return;\n        }\n        this.#setStroke();\n        const { canvas, ctx } = this;\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        this.#updateTransform();\n        for (const path of this.bezierPath2D){\n            ctx.stroke(path);\n        }\n    }\n    commit() {\n        if (this.#disableEditing) {\n            return;\n        }\n        super.commit();\n        this.isEditing = false;\n        this.disableEditMode();\n        this.setInForeground();\n        this.#disableEditing = true;\n        this.div.classList.add(\"disabled\");\n        this.#fitToContent(true);\n        this.select();\n        this.parent.addInkEditorIfNeeded(true);\n        this.moveInDOM();\n        this.div.focus({\n            preventScroll: true\n        });\n    }\n    focusin(event) {\n        if (!this._focusEventsAllowed) {\n            return;\n        }\n        super.focusin(event);\n        this.enableEditMode();\n    }\n    #addPointerdownListener() {\n        if (this.#pointerdownAC) {\n            return;\n        }\n        this.#pointerdownAC = new AbortController();\n        const signal = this._uiManager.combinedSignal(this.#pointerdownAC);\n        this.canvas.addEventListener(\"pointerdown\", this.canvasPointerdown.bind(this), {\n            signal\n        });\n    }\n    #removePointerdownListener() {\n        this.pointerdownAC?.abort();\n        this.pointerdownAC = null;\n    }\n    canvasPointerdown(event) {\n        if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n            return;\n        }\n        this.setInForeground();\n        event.preventDefault();\n        if (!this.div.contains(document.activeElement)) {\n            this.div.focus({\n                preventScroll: true\n            });\n        }\n        this.#startDrawing(event.offsetX, event.offsetY);\n    }\n    canvasPointermove(event) {\n        event.preventDefault();\n        this.#draw(event.offsetX, event.offsetY);\n    }\n    canvasPointerup(event) {\n        event.preventDefault();\n        this.#endDrawing(event);\n    }\n    canvasPointerleave(event) {\n        this.#endDrawing(event);\n    }\n    #endDrawing(event) {\n        this.#drawingAC?.abort();\n        this.#drawingAC = null;\n        this.#addPointerdownListener();\n        if (this.#canvasContextMenuTimeoutId) {\n            clearTimeout(this.#canvasContextMenuTimeoutId);\n        }\n        this.#canvasContextMenuTimeoutId = setTimeout(()=>{\n            this.#canvasContextMenuTimeoutId = null;\n            this.canvas.removeEventListener(\"contextmenu\", noContextMenu);\n        }, 10);\n        this.#stopDrawing(event.offsetX, event.offsetY);\n        this.addToAnnotationStorage();\n        this.setInBackground();\n    }\n    #createCanvas() {\n        this.canvas = document.createElement(\"canvas\");\n        this.canvas.width = this.canvas.height = 0;\n        this.canvas.className = \"inkEditorCanvas\";\n        this.canvas.setAttribute(\"data-l10n-id\", \"pdfjs-ink-canvas\");\n        this.div.append(this.canvas);\n        this.ctx = this.canvas.getContext(\"2d\");\n    }\n    #createObserver() {\n        this.#observer = new ResizeObserver((entries)=>{\n            const rect = entries[0].contentRect;\n            if (rect.width && rect.height) {\n                this.setDimensions(rect.width, rect.height);\n            }\n        });\n        this.#observer.observe(this.div);\n        this._uiManager._signal.addEventListener(\"abort\", ()=>{\n            this.#observer?.disconnect();\n            this.#observer = null;\n        }, {\n            once: true\n        });\n    }\n    get isResizable() {\n        return !this.isEmpty() && this.#disableEditing;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this.width) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.setAttribute(\"data-l10n-id\", \"pdfjs-ink\");\n        const [x, y, w, h] = this.#getInitialBBox();\n        this.setAt(x, y, 0, 0);\n        this.setDims(w, h);\n        this.#createCanvas();\n        if (this.width) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);\n            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n            this.#isCanvasInitialized = true;\n            this.#setCanvasDims();\n            this.setDims(this.width * parentWidth, this.height * parentHeight);\n            this.#redraw();\n            this.div.classList.add(\"disabled\");\n        } else {\n            this.div.classList.add(\"editing\");\n            this.enableEditMode();\n        }\n        this.#createObserver();\n        return this.div;\n    }\n    #setCanvasDims() {\n        if (!this.#isCanvasInitialized) {\n            return;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.canvas.width = Math.ceil(this.width * parentWidth);\n        this.canvas.height = Math.ceil(this.height * parentHeight);\n        this.#updateTransform();\n    }\n    setDimensions(width, height) {\n        const roundedWidth = Math.round(width);\n        const roundedHeight = Math.round(height);\n        if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n            return;\n        }\n        this.#realWidth = roundedWidth;\n        this.#realHeight = roundedHeight;\n        this.canvas.style.visibility = \"hidden\";\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.width = width / parentWidth;\n        this.height = height / parentHeight;\n        this.fixAndSetPosition();\n        if (this.#disableEditing) {\n            this.#setScaleFactor(width, height);\n        }\n        this.#setCanvasDims();\n        this.#redraw();\n        this.canvas.style.visibility = \"visible\";\n        this.fixDims();\n    }\n    #setScaleFactor(width, height) {\n        const padding = this.#getPadding();\n        const scaleFactorW = (width - padding) / this.#baseWidth;\n        const scaleFactorH = (height - padding) / this.#baseHeight;\n        this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n    }\n    #updateTransform() {\n        const padding = this.#getPadding() / 2;\n        this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n    }\n    static #buildPath2D(bezier) {\n        const path2D = new Path2D();\n        for(let i = 0, ii = bezier.length; i < ii; i++){\n            const [first, control1, control2, second] = bezier[i];\n            if (i === 0) {\n                path2D.moveTo(...first);\n            }\n            path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n        }\n        return path2D;\n    }\n    static #toPDFCoordinates(points, rect, rotation) {\n        const [blX, blY, trX, trY] = rect;\n        switch(rotation){\n            case 0:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    points[i] += blX;\n                    points[i + 1] = trY - points[i + 1];\n                }\n                break;\n            case 90:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    const x = points[i];\n                    points[i] = points[i + 1] + blX;\n                    points[i + 1] = x + blY;\n                }\n                break;\n            case 180:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    points[i] = trX - points[i];\n                    points[i + 1] += blY;\n                }\n                break;\n            case 270:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    const x = points[i];\n                    points[i] = trX - points[i + 1];\n                    points[i + 1] = trY - x;\n                }\n                break;\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n        return points;\n    }\n    static #fromPDFCoordinates(points, rect, rotation) {\n        const [blX, blY, trX, trY] = rect;\n        switch(rotation){\n            case 0:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    points[i] -= blX;\n                    points[i + 1] = trY - points[i + 1];\n                }\n                break;\n            case 90:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    const x = points[i];\n                    points[i] = points[i + 1] - blY;\n                    points[i + 1] = x - blX;\n                }\n                break;\n            case 180:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    points[i] = trX - points[i];\n                    points[i + 1] -= blY;\n                }\n                break;\n            case 270:\n                for(let i = 0, ii = points.length; i < ii; i += 2){\n                    const x = points[i];\n                    points[i] = trY - points[i + 1];\n                    points[i + 1] = trX - x;\n                }\n                break;\n            default:\n                throw new Error(\"Invalid rotation\");\n        }\n        return points;\n    }\n    #serializePaths(s, tx, ty, rect) {\n        const paths = [];\n        const padding = this.thickness / 2;\n        const shiftX = s * tx + padding;\n        const shiftY = s * ty + padding;\n        for (const bezier of this.paths){\n            const buffer = [];\n            const points = [];\n            for(let j = 0, jj = bezier.length; j < jj; j++){\n                const [first, control1, control2, second] = bezier[j];\n                if (first[0] === second[0] && first[1] === second[1] && jj === 1) {\n                    const p0 = s * first[0] + shiftX;\n                    const p1 = s * first[1] + shiftY;\n                    buffer.push(p0, p1);\n                    points.push(p0, p1);\n                    break;\n                }\n                const p10 = s * first[0] + shiftX;\n                const p11 = s * first[1] + shiftY;\n                const p20 = s * control1[0] + shiftX;\n                const p21 = s * control1[1] + shiftY;\n                const p30 = s * control2[0] + shiftX;\n                const p31 = s * control2[1] + shiftY;\n                const p40 = s * second[0] + shiftX;\n                const p41 = s * second[1] + shiftY;\n                if (j === 0) {\n                    buffer.push(p10, p11);\n                    points.push(p10, p11);\n                }\n                buffer.push(p20, p21, p30, p31, p40, p41);\n                points.push(p20, p21);\n                if (j === jj - 1) {\n                    points.push(p40, p41);\n                }\n            }\n            paths.push({\n                bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),\n                points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)\n            });\n        }\n        return paths;\n    }\n    #getBbox() {\n        let xMin = Infinity;\n        let xMax = -Infinity;\n        let yMin = Infinity;\n        let yMax = -Infinity;\n        for (const path of this.paths){\n            for (const [first, control1, control2, second] of path){\n                const bbox = Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n                xMin = Math.min(xMin, bbox[0]);\n                yMin = Math.min(yMin, bbox[1]);\n                xMax = Math.max(xMax, bbox[2]);\n                yMax = Math.max(yMax, bbox[3]);\n            }\n        }\n        return [\n            xMin,\n            yMin,\n            xMax,\n            yMax\n        ];\n    }\n    #getPadding() {\n        return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n    }\n    #fitToContent(firstTime = false) {\n        if (this.isEmpty()) {\n            return;\n        }\n        if (!this.#disableEditing) {\n            this.#redraw();\n            return;\n        }\n        const bbox = this.#getBbox();\n        const padding = this.#getPadding();\n        this.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n        this.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n        const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n        const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.width = width / parentWidth;\n        this.height = height / parentHeight;\n        this.setAspectRatio(width, height);\n        const prevTranslationX = this.translationX;\n        const prevTranslationY = this.translationY;\n        this.translationX = -bbox[0];\n        this.translationY = -bbox[1];\n        this.#setCanvasDims();\n        this.#redraw();\n        this.#realWidth = width;\n        this.#realHeight = height;\n        this.setDims(width, height);\n        const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n        this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n    }\n    static async deserialize(data, parent, uiManager) {\n        if (data instanceof InkAnnotationElement) {\n            return null;\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        editor.thickness = data.thickness;\n        editor.color = Util.makeHexColor(...data.color);\n        editor.opacity = data.opacity;\n        const [pageWidth, pageHeight] = editor.pageDimensions;\n        const width = editor.width * pageWidth;\n        const height = editor.height * pageHeight;\n        const scaleFactor = editor.parentScale;\n        const padding = data.thickness / 2;\n        editor.#disableEditing = true;\n        editor.#realWidth = Math.round(width);\n        editor.#realHeight = Math.round(height);\n        const { paths, rect, rotation } = data;\n        for (let { bezier } of paths){\n            bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);\n            const path = [];\n            editor.paths.push(path);\n            let p0 = scaleFactor * (bezier[0] - padding);\n            let p1 = scaleFactor * (bezier[1] - padding);\n            for(let i = 2, ii = bezier.length; i < ii; i += 6){\n                const p10 = scaleFactor * (bezier[i] - padding);\n                const p11 = scaleFactor * (bezier[i + 1] - padding);\n                const p20 = scaleFactor * (bezier[i + 2] - padding);\n                const p21 = scaleFactor * (bezier[i + 3] - padding);\n                const p30 = scaleFactor * (bezier[i + 4] - padding);\n                const p31 = scaleFactor * (bezier[i + 5] - padding);\n                path.push([\n                    [\n                        p0,\n                        p1\n                    ],\n                    [\n                        p10,\n                        p11\n                    ],\n                    [\n                        p20,\n                        p21\n                    ],\n                    [\n                        p30,\n                        p31\n                    ]\n                ]);\n                p0 = p30;\n                p1 = p31;\n            }\n            const path2D = this.#buildPath2D(path);\n            editor.bezierPath2D.push(path2D);\n        }\n        const bbox = editor.#getBbox();\n        editor.#baseWidth = Math.max(AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n        editor.#baseHeight = Math.max(AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n        editor.#setScaleFactor(width, height);\n        return editor;\n    }\n    serialize() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        const rect = this.getRect(0, 0);\n        const color = AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n        return {\n            annotationType: AnnotationEditorType.INK,\n            color,\n            thickness: this.thickness,\n            opacity: this.opacity,\n            paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),\n            pageIndex: this.pageIndex,\n            rect,\n            rotation: this.rotation,\n            structTreeParentId: this._structTreeParentId\n        };\n    }\n}\n; // ./src/display/editor/stamp.js\nclass StampEditor extends AnnotationEditor {\n    #bitmap;\n    #bitmapId;\n    #bitmapPromise;\n    #bitmapUrl;\n    #bitmapFile;\n    #bitmapFileName;\n    #canvas;\n    #observer;\n    #resizeTimeoutId;\n    #isSvg;\n    #hasBeenAddedInUndoStack;\n    static{\n        this._type = \"stamp\";\n    }\n    static{\n        this._editorType = AnnotationEditorType.STAMP;\n    }\n    constructor(params){\n        super({\n            ...params,\n            name: \"stampEditor\"\n        });\n        this.#bitmap = null;\n        this.#bitmapId = null;\n        this.#bitmapPromise = null;\n        this.#bitmapUrl = null;\n        this.#bitmapFile = null;\n        this.#bitmapFileName = \"\";\n        this.#canvas = null;\n        this.#observer = null;\n        this.#resizeTimeoutId = null;\n        this.#isSvg = false;\n        this.#hasBeenAddedInUndoStack = false;\n        this.#bitmapUrl = params.bitmapUrl;\n        this.#bitmapFile = params.bitmapFile;\n    }\n    static initialize(l10n, uiManager) {\n        AnnotationEditor.initialize(l10n, uiManager);\n    }\n    static get supportedTypes() {\n        const types = [\n            \"apng\",\n            \"avif\",\n            \"bmp\",\n            \"gif\",\n            \"jpeg\",\n            \"png\",\n            \"svg+xml\",\n            \"webp\",\n            \"x-icon\"\n        ];\n        return shadow(this, \"supportedTypes\", types.map((type)=>`image/${type}`));\n    }\n    static get supportedTypesStr() {\n        return shadow(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n    }\n    static isHandlingMimeForPasting(mime) {\n        return this.supportedTypes.includes(mime);\n    }\n    static paste(item, parent) {\n        parent.pasteEditor(AnnotationEditorType.STAMP, {\n            bitmapFile: item.getAsFile()\n        });\n    }\n    altTextFinish() {\n        if (this._uiManager.useNewAltTextFlow) {\n            this.div.hidden = false;\n        }\n        super.altTextFinish();\n    }\n    get telemetryFinalData() {\n        return {\n            type: \"stamp\",\n            hasAltText: !!this.altTextData?.altText\n        };\n    }\n    static computeTelemetryFinalData(data) {\n        const hasAltTextStats = data.get(\"hasAltText\");\n        return {\n            hasAltText: hasAltTextStats.get(true) ?? 0,\n            hasNoAltText: hasAltTextStats.get(false) ?? 0\n        };\n    }\n    #getBitmapFetched(data, fromId = false) {\n        if (!data) {\n            this.remove();\n            return;\n        }\n        this.#bitmap = data.bitmap;\n        if (!fromId) {\n            this.#bitmapId = data.id;\n            this.#isSvg = data.isSvg;\n        }\n        if (data.file) {\n            this.#bitmapFileName = data.file.name;\n        }\n        this.#createCanvas();\n    }\n    #getBitmapDone() {\n        this.#bitmapPromise = null;\n        this._uiManager.enableWaiting(false);\n        if (!this.#canvas) {\n            return;\n        }\n        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._editToolbar.hide();\n            this._uiManager.editAltText(this, true);\n            return;\n        }\n        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n            this._reportTelemetry({\n                action: \"pdfjs.image.image_added\",\n                data: {\n                    alt_text_modal: false,\n                    alt_text_type: \"empty\"\n                }\n            });\n            try {\n                this.mlGuessAltText();\n            } catch  {}\n        }\n        this.div.focus();\n    }\n    async mlGuessAltText(imageData = null, updateAltTextData = true) {\n        if (this.hasAltTextData()) {\n            return null;\n        }\n        const { mlManager } = this._uiManager;\n        if (!mlManager) {\n            throw new Error(\"No ML.\");\n        }\n        if (!await mlManager.isEnabledFor(\"altText\")) {\n            throw new Error(\"ML isn't enabled for alt text.\");\n        }\n        const { data, width, height } = imageData || this.copyCanvas(null, null, true).imageData;\n        const response = await mlManager.guess({\n            name: \"altText\",\n            request: {\n                data,\n                width,\n                height,\n                channels: data.length / (width * height)\n            }\n        });\n        if (!response) {\n            throw new Error(\"No response from the AI service.\");\n        }\n        if (response.error) {\n            throw new Error(\"Error from the AI service.\");\n        }\n        if (response.cancel) {\n            return null;\n        }\n        if (!response.output) {\n            throw new Error(\"No valid response from the AI service.\");\n        }\n        const altText = response.output;\n        await this.setGuessedAltText(altText);\n        if (updateAltTextData && !this.hasAltTextData()) {\n            this.altTextData = {\n                alt: altText,\n                decorative: false\n            };\n        }\n        return altText;\n    }\n    #getBitmap() {\n        if (this.#bitmapId) {\n            this._uiManager.enableWaiting(true);\n            this._uiManager.imageManager.getFromId(this.#bitmapId).then((data)=>this.#getBitmapFetched(data, true)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapUrl) {\n            const url = this.#bitmapUrl;\n            this.#bitmapUrl = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        if (this.#bitmapFile) {\n            const file = this.#bitmapFile;\n            this.#bitmapFile = null;\n            this._uiManager.enableWaiting(true);\n            this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data)=>this.#getBitmapFetched(data)).finally(()=>this.#getBitmapDone());\n            return;\n        }\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n        input.accept = StampEditor.supportedTypesStr;\n        const signal = this._uiManager._signal;\n        this.#bitmapPromise = new Promise((resolve)=>{\n            input.addEventListener(\"change\", async ()=>{\n                if (!input.files || input.files.length === 0) {\n                    this.remove();\n                } else {\n                    this._uiManager.enableWaiting(true);\n                    const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n                    this._reportTelemetry({\n                        action: \"pdfjs.image.image_selected\",\n                        data: {\n                            alt_text_modal: this._uiManager.useNewAltTextFlow\n                        }\n                    });\n                    this.#getBitmapFetched(data);\n                }\n                resolve();\n            }, {\n                signal\n            });\n            input.addEventListener(\"cancel\", ()=>{\n                this.remove();\n                resolve();\n            }, {\n                signal\n            });\n        }).finally(()=>this.#getBitmapDone());\n        input.click();\n    }\n    remove() {\n        if (this.#bitmapId) {\n            this.#bitmap = null;\n            this._uiManager.imageManager.deleteId(this.#bitmapId);\n            this.#canvas?.remove();\n            this.#canvas = null;\n            this.#observer?.disconnect();\n            this.#observer = null;\n            if (this.#resizeTimeoutId) {\n                clearTimeout(this.#resizeTimeoutId);\n                this.#resizeTimeoutId = null;\n            }\n        }\n        super.remove();\n    }\n    rebuild() {\n        if (!this.parent) {\n            if (this.#bitmapId) {\n                this.#getBitmap();\n            }\n            return;\n        }\n        super.rebuild();\n        if (this.div === null) {\n            return;\n        }\n        if (this.#bitmapId && this.#canvas === null) {\n            this.#getBitmap();\n        }\n        if (!this.isAttachedToDOM) {\n            this.parent.add(this);\n        }\n    }\n    onceAdded() {\n        this._isDraggable = true;\n        this.div.focus();\n    }\n    isEmpty() {\n        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId);\n    }\n    get isResizable() {\n        return true;\n    }\n    render() {\n        if (this.div) {\n            return this.div;\n        }\n        let baseX, baseY;\n        if (this.width) {\n            baseX = this.x;\n            baseY = this.y;\n        }\n        super.render();\n        this.div.hidden = true;\n        this.div.setAttribute(\"role\", \"figure\");\n        this.addAltTextButton();\n        if (this.#bitmap) {\n            this.#createCanvas();\n        } else {\n            this.#getBitmap();\n        }\n        if (this.width && !this.annotationElementId) {\n            const [parentWidth, parentHeight] = this.parentDimensions;\n            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n        }\n        return this.div;\n    }\n    #createCanvas() {\n        const { div } = this;\n        let { width, height } = this.#bitmap;\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const MAX_RATIO = 0.75;\n        if (this.width) {\n            width = this.width * pageWidth;\n            height = this.height * pageHeight;\n        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n            const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n            width *= factor;\n            height *= factor;\n        }\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n        this._uiManager.enableWaiting(false);\n        const canvas = this.#canvas = document.createElement(\"canvas\");\n        canvas.setAttribute(\"role\", \"img\");\n        this.addContainer(canvas);\n        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n            div.hidden = false;\n        }\n        this.#drawBitmap(width, height);\n        this.#createObserver();\n        if (!this.#hasBeenAddedInUndoStack) {\n            this.parent.addUndoableEditor(this);\n            this.#hasBeenAddedInUndoStack = true;\n        }\n        this._reportTelemetry({\n            action: \"inserted_image\"\n        });\n        if (this.#bitmapFileName) {\n            canvas.setAttribute(\"aria-label\", this.#bitmapFileName);\n        }\n    }\n    copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n        if (!maxDataDimension) {\n            maxDataDimension = 224;\n        }\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        const outputScale = new OutputScale();\n        let bitmap = this.#bitmap;\n        let width = bitmapWidth, height = bitmapHeight;\n        let canvas = null;\n        if (maxPreviewDimension) {\n            if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n                width = Math.floor(bitmapWidth * ratio);\n                height = Math.floor(bitmapHeight * ratio);\n            }\n            canvas = document.createElement(\"canvas\");\n            const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n            const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n            if (!this.#isSvg) {\n                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n            }\n            const ctx = canvas.getContext(\"2d\");\n            ctx.filter = this._uiManager.hcmFilter;\n            let white = \"white\", black = \"#cfcfd8\";\n            if (this._uiManager.hcmFilter !== \"none\") {\n                black = \"black\";\n            } else if (window.matchMedia?.(\"(prefers-color-scheme: dark)\").matches) {\n                white = \"#8f8f9d\";\n                black = \"#42414d\";\n            }\n            const boxDim = 15;\n            const boxDimWidth = boxDim * outputScale.sx;\n            const boxDimHeight = boxDim * outputScale.sy;\n            const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n            const patternCtx = pattern.getContext(\"2d\");\n            patternCtx.fillStyle = white;\n            patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n            patternCtx.fillStyle = black;\n            patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n            patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n            ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n            ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n        }\n        let imageData = null;\n        if (createImageData) {\n            let dataWidth, dataHeight;\n            if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n                dataWidth = bitmap.width;\n                dataHeight = bitmap.height;\n            } else {\n                bitmap = this.#bitmap;\n                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n                    const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n                    dataWidth = Math.floor(bitmapWidth * ratio);\n                    dataHeight = Math.floor(bitmapHeight * ratio);\n                    if (!this.#isSvg) {\n                        bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n                    }\n                }\n            }\n            const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n            const offscreenCtx = offscreen.getContext(\"2d\", {\n                willReadFrequently: true\n            });\n            offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n            imageData = {\n                width: dataWidth,\n                height: dataHeight,\n                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n            };\n        }\n        return {\n            canvas,\n            width,\n            height,\n            imageData\n        };\n    }\n    #setDimensions(width, height) {\n        const [parentWidth, parentHeight] = this.parentDimensions;\n        this.width = width / parentWidth;\n        this.height = height / parentHeight;\n        if (this._initialOptions?.isCentered) {\n            this.center();\n        } else {\n            this.fixAndSetPosition();\n        }\n        this._initialOptions = null;\n        if (this.#resizeTimeoutId !== null) {\n            clearTimeout(this.#resizeTimeoutId);\n        }\n        const TIME_TO_WAIT = 200;\n        this.#resizeTimeoutId = setTimeout(()=>{\n            this.#resizeTimeoutId = null;\n            this.#drawBitmap(width, height);\n        }, TIME_TO_WAIT);\n    }\n    #scaleBitmap(width, height) {\n        const { width: bitmapWidth, height: bitmapHeight } = this.#bitmap;\n        let newWidth = bitmapWidth;\n        let newHeight = bitmapHeight;\n        let bitmap = this.#bitmap;\n        while(newWidth > 2 * width || newHeight > 2 * height){\n            const prevWidth = newWidth;\n            const prevHeight = newHeight;\n            if (newWidth > 2 * width) {\n                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n            }\n            if (newHeight > 2 * height) {\n                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n            }\n            const offscreen = new OffscreenCanvas(newWidth, newHeight);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n            bitmap = offscreen.transferToImageBitmap();\n        }\n        return bitmap;\n    }\n    #drawBitmap(width, height) {\n        const outputScale = new OutputScale();\n        const scaledWidth = Math.ceil(width * outputScale.sx);\n        const scaledHeight = Math.ceil(height * outputScale.sy);\n        const canvas = this.#canvas;\n        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n            return;\n        }\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n        const ctx = canvas.getContext(\"2d\");\n        ctx.filter = this._uiManager.hcmFilter;\n        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    getImageForAltText() {\n        return this.#canvas;\n    }\n    #serializeBitmap(toUrl) {\n        if (toUrl) {\n            if (this.#isSvg) {\n                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n                if (url) {\n                    return url;\n                }\n            }\n            const canvas = document.createElement(\"canvas\");\n            ({ width: canvas.width, height: canvas.height } = this.#bitmap);\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0);\n            return canvas.toDataURL();\n        }\n        if (this.#isSvg) {\n            const [pageWidth, pageHeight] = this.pageDimensions;\n            const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n            const offscreen = new OffscreenCanvas(width, height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n            return offscreen.transferToImageBitmap();\n        }\n        return structuredClone(this.#bitmap);\n    }\n    #createObserver() {\n        if (!this._uiManager._signal) {\n            return;\n        }\n        this.#observer = new ResizeObserver((entries)=>{\n            const rect = entries[0].contentRect;\n            if (rect.width && rect.height) {\n                this.#setDimensions(rect.width, rect.height);\n            }\n        });\n        this.#observer.observe(this.div);\n        this._uiManager._signal.addEventListener(\"abort\", ()=>{\n            this.#observer?.disconnect();\n            this.#observer = null;\n        }, {\n            once: true\n        });\n    }\n    static async deserialize(data, parent, uiManager) {\n        let initialData = null;\n        if (data instanceof StampAnnotationElement) {\n            const { data: { rect, rotation, id, structParent, popupRef }, container, parent: { page: { pageNumber } } } = data;\n            const canvas = container.querySelector(\"canvas\");\n            const imageData = uiManager.imageManager.getFromCanvas(container.id, canvas);\n            canvas.remove();\n            const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n            initialData = data = {\n                annotationType: AnnotationEditorType.STAMP,\n                bitmapId: imageData.id,\n                bitmap: imageData.bitmap,\n                pageIndex: pageNumber - 1,\n                rect: rect.slice(0),\n                rotation,\n                id,\n                deleted: false,\n                accessibilityData: {\n                    decorative: false,\n                    altText\n                },\n                isSvg: false,\n                structParent,\n                popupRef\n            };\n        }\n        const editor = await super.deserialize(data, parent, uiManager);\n        const { rect, bitmap, bitmapUrl, bitmapId, isSvg, accessibilityData } = data;\n        if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n            editor.#bitmapId = bitmapId;\n            if (bitmap) {\n                editor.#bitmap = bitmap;\n            }\n        } else {\n            editor.#bitmapUrl = bitmapUrl;\n        }\n        editor.#isSvg = isSvg;\n        const [parentWidth, parentHeight] = editor.pageDimensions;\n        editor.width = (rect[2] - rect[0]) / parentWidth;\n        editor.height = (rect[3] - rect[1]) / parentHeight;\n        editor.annotationElementId = data.id || null;\n        if (accessibilityData) {\n            editor.altTextData = accessibilityData;\n        }\n        editor._initialData = initialData;\n        editor.#hasBeenAddedInUndoStack = !!initialData;\n        return editor;\n    }\n    serialize(isForCopying = false, context = null) {\n        if (this.isEmpty()) {\n            return null;\n        }\n        if (this.deleted) {\n            return this.serializeDeleted();\n        }\n        const serialized = {\n            annotationType: AnnotationEditorType.STAMP,\n            bitmapId: this.#bitmapId,\n            pageIndex: this.pageIndex,\n            rect: this.getRect(0, 0),\n            rotation: this.rotation,\n            isSvg: this.#isSvg,\n            structTreeParentId: this._structTreeParentId\n        };\n        if (isForCopying) {\n            serialized.bitmapUrl = this.#serializeBitmap(true);\n            serialized.accessibilityData = this.serializeAltText(true);\n            return serialized;\n        }\n        const { decorative, altText } = this.serializeAltText(false);\n        if (!decorative && altText) {\n            serialized.accessibilityData = {\n                type: \"Figure\",\n                alt: altText\n            };\n        }\n        if (this.annotationElementId) {\n            const changes = this.#hasElementChanged(serialized);\n            if (changes.isSame) {\n                return null;\n            }\n            if (changes.isSameAltText) {\n                delete serialized.accessibilityData;\n            } else {\n                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n            }\n        }\n        serialized.id = this.annotationElementId;\n        if (context === null) {\n            return serialized;\n        }\n        context.stamps ||= new Map();\n        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n        if (!context.stamps.has(this.#bitmapId)) {\n            context.stamps.set(this.#bitmapId, {\n                area,\n                serialized\n            });\n            serialized.bitmap = this.#serializeBitmap(false);\n        } else if (this.#isSvg) {\n            const prevData = context.stamps.get(this.#bitmapId);\n            if (area > prevData.area) {\n                prevData.area = area;\n                prevData.serialized.bitmap.close();\n                prevData.serialized.bitmap = this.#serializeBitmap(false);\n            }\n        }\n        return serialized;\n    }\n    #hasElementChanged(serialized) {\n        const { rect, pageIndex, accessibilityData: { altText } } = this._initialData;\n        const isSameRect = serialized.rect.every((x, i)=>Math.abs(x - rect[i]) < 1);\n        const isSamePageIndex = serialized.pageIndex === pageIndex;\n        const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n        return {\n            isSame: isSameRect && isSamePageIndex && isSameAltText,\n            isSameAltText\n        };\n    }\n    renderAnnotationElement(annotation) {\n        annotation.updateEdited({\n            rect: this.getRect(0, 0)\n        });\n        return null;\n    }\n}\n; // ./src/display/editor/annotation_editor_layer.js\nclass AnnotationEditorLayer {\n    #accessibilityManager;\n    #allowClick;\n    #annotationLayer;\n    #clickAC;\n    #editorFocusTimeoutId;\n    #editors;\n    #hadPointerDown;\n    #isCleaningUp;\n    #isDisabling;\n    #textLayer;\n    #textSelectionAC;\n    #uiManager;\n    static{\n        this._initialized = false;\n    }\n    static #editorTypes = new Map([\n        FreeTextEditor,\n        InkEditor,\n        StampEditor,\n        HighlightEditor\n    ].map((type)=>[\n            type._editorType,\n            type\n        ]));\n    constructor({ uiManager, pageIndex, div, structTreeLayer, accessibilityManager, annotationLayer, drawLayer, textLayer, viewport, l10n }){\n        this.#allowClick = false;\n        this.#annotationLayer = null;\n        this.#clickAC = null;\n        this.#editorFocusTimeoutId = null;\n        this.#editors = new Map();\n        this.#hadPointerDown = false;\n        this.#isCleaningUp = false;\n        this.#isDisabling = false;\n        this.#textLayer = null;\n        this.#textSelectionAC = null;\n        const editorTypes = [\n            ...AnnotationEditorLayer.#editorTypes.values()\n        ];\n        if (!AnnotationEditorLayer._initialized) {\n            AnnotationEditorLayer._initialized = true;\n            for (const editorType of editorTypes){\n                editorType.initialize(l10n, uiManager);\n            }\n        }\n        uiManager.registerEditorTypes(editorTypes);\n        this.#uiManager = uiManager;\n        this.pageIndex = pageIndex;\n        this.div = div;\n        this.#accessibilityManager = accessibilityManager;\n        this.#annotationLayer = annotationLayer;\n        this.viewport = viewport;\n        this.#textLayer = textLayer;\n        this.drawLayer = drawLayer;\n        this._structTree = structTreeLayer;\n        this.#uiManager.addLayer(this);\n    }\n    get isEmpty() {\n        return this.#editors.size === 0;\n    }\n    get isInvisible() {\n        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n    }\n    updateToolbar(mode) {\n        this.#uiManager.updateToolbar(mode);\n    }\n    updateMode(mode = this.#uiManager.getMode()) {\n        this.#cleanup();\n        switch(mode){\n            case AnnotationEditorType.NONE:\n                this.disableTextSelection();\n                this.togglePointerEvents(false);\n                this.toggleAnnotationLayerPointerEvents(true);\n                this.disableClick();\n                return;\n            case AnnotationEditorType.INK:\n                this.addInkEditorIfNeeded(false);\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.disableClick();\n                break;\n            case AnnotationEditorType.HIGHLIGHT:\n                this.enableTextSelection();\n                this.togglePointerEvents(false);\n                this.disableClick();\n                break;\n            default:\n                this.disableTextSelection();\n                this.togglePointerEvents(true);\n                this.enableClick();\n        }\n        this.toggleAnnotationLayerPointerEvents(false);\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n        }\n        this.div.hidden = false;\n    }\n    hasTextLayer(textLayer) {\n        return textLayer === this.#textLayer?.div;\n    }\n    addInkEditorIfNeeded(isCommitting) {\n        if (this.#uiManager.getMode() !== AnnotationEditorType.INK) {\n            return;\n        }\n        if (!isCommitting) {\n            for (const editor of this.#editors.values()){\n                if (editor.isEmpty()) {\n                    editor.setInBackground();\n                    return;\n                }\n            }\n        }\n        const editor = this.createAndAddNewEditor({\n            offsetX: 0,\n            offsetY: 0\n        }, false);\n        editor.setInBackground();\n    }\n    setEditingState(isEditing) {\n        this.#uiManager.setEditingState(isEditing);\n    }\n    addCommands(params) {\n        this.#uiManager.addCommands(params);\n    }\n    toggleDrawing(enabled = false) {\n        this.div.classList.toggle(\"drawing\", !enabled);\n    }\n    togglePointerEvents(enabled = false) {\n        this.div.classList.toggle(\"disabled\", !enabled);\n    }\n    toggleAnnotationLayerPointerEvents(enabled = false) {\n        this.#annotationLayer?.div.classList.toggle(\"disabled\", !enabled);\n    }\n    async enable() {\n        this.div.tabIndex = 0;\n        this.togglePointerEvents(true);\n        const annotationElementIds = new Set();\n        for (const editor of this.#editors.values()){\n            editor.enableEditing();\n            editor.show(true);\n            if (editor.annotationElementId) {\n                this.#uiManager.removeChangedExistingAnnotation(editor);\n                annotationElementIds.add(editor.annotationElementId);\n            }\n        }\n        if (!this.#annotationLayer) {\n            return;\n        }\n        const editables = this.#annotationLayer.getEditableAnnotations();\n        for (const editable of editables){\n            editable.hide();\n            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n                continue;\n            }\n            if (annotationElementIds.has(editable.data.id)) {\n                continue;\n            }\n            const editor = await this.deserialize(editable);\n            if (!editor) {\n                continue;\n            }\n            this.addOrRebuild(editor);\n            editor.enableEditing();\n        }\n    }\n    disable() {\n        this.#isDisabling = true;\n        this.div.tabIndex = -1;\n        this.togglePointerEvents(false);\n        const changedAnnotations = new Map();\n        const resetAnnotations = new Map();\n        for (const editor of this.#editors.values()){\n            editor.disableEditing();\n            if (!editor.annotationElementId) {\n                continue;\n            }\n            if (editor.serialize() !== null) {\n                changedAnnotations.set(editor.annotationElementId, editor);\n                continue;\n            } else {\n                resetAnnotations.set(editor.annotationElementId, editor);\n            }\n            this.getEditableAnnotation(editor.annotationElementId)?.show();\n            editor.remove();\n        }\n        if (this.#annotationLayer) {\n            const editables = this.#annotationLayer.getEditableAnnotations();\n            for (const editable of editables){\n                const { id } = editable.data;\n                if (this.#uiManager.isDeletedAnnotationElement(id)) {\n                    continue;\n                }\n                let editor = resetAnnotations.get(id);\n                if (editor) {\n                    editor.resetAnnotationElement(editable);\n                    editor.show(false);\n                    editable.show();\n                    continue;\n                }\n                editor = changedAnnotations.get(id);\n                if (editor) {\n                    this.#uiManager.addChangedExistingAnnotation(editor);\n                    if (editor.renderAnnotationElement(editable)) {\n                        editor.show(false);\n                    }\n                }\n                editable.show();\n            }\n        }\n        this.#cleanup();\n        if (this.isEmpty) {\n            this.div.hidden = true;\n        }\n        const { classList } = this.div;\n        for (const editorType of AnnotationEditorLayer.#editorTypes.values()){\n            classList.remove(`${editorType._type}Editing`);\n        }\n        this.disableTextSelection();\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.#isDisabling = false;\n    }\n    getEditableAnnotation(id) {\n        return this.#annotationLayer?.getEditableAnnotation(id) || null;\n    }\n    setActiveEditor(editor) {\n        const currentActive = this.#uiManager.getActive();\n        if (currentActive === editor) {\n            return;\n        }\n        this.#uiManager.setActiveEditor(editor);\n    }\n    enableTextSelection() {\n        this.div.tabIndex = -1;\n        if (this.#textLayer?.div && !this.#textSelectionAC) {\n            this.#textSelectionAC = new AbortController();\n            const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n            this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n                signal\n            });\n            this.#textLayer.div.classList.add(\"highlighting\");\n        }\n    }\n    disableTextSelection() {\n        this.div.tabIndex = 0;\n        if (this.#textLayer?.div && this.#textSelectionAC) {\n            this.#textSelectionAC.abort();\n            this.#textSelectionAC = null;\n            this.#textLayer.div.classList.remove(\"highlighting\");\n        }\n    }\n    #textLayerPointerDown(event) {\n        this.#uiManager.unselectAll();\n        const { target } = event;\n        if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n            const { isMac } = util_FeatureTest.platform;\n            if (event.button !== 0 || event.ctrlKey && isMac) {\n                return;\n            }\n            this.#uiManager.showAllEditors(\"highlight\", true, true);\n            this.#textLayer.div.classList.add(\"free\");\n            this.toggleDrawing();\n            HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n                target: this.#textLayer.div,\n                x: event.x,\n                y: event.y\n            });\n            this.#textLayer.div.addEventListener(\"pointerup\", ()=>{\n                this.#textLayer.div.classList.remove(\"free\");\n                this.toggleDrawing(true);\n            }, {\n                once: true,\n                signal: this.#uiManager._signal\n            });\n            event.preventDefault();\n        }\n    }\n    enableClick() {\n        if (this.#clickAC) {\n            return;\n        }\n        this.#clickAC = new AbortController();\n        const signal = this.#uiManager.combinedSignal(this.#clickAC);\n        this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n            signal\n        });\n        this.div.addEventListener(\"pointerup\", this.pointerup.bind(this), {\n            signal\n        });\n    }\n    disableClick() {\n        this.#clickAC?.abort();\n        this.#clickAC = null;\n    }\n    attach(editor) {\n        this.#editors.set(editor.id, editor);\n        const { annotationElementId } = editor;\n        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n            this.#uiManager.removeDeletedAnnotationElement(editor);\n        }\n    }\n    detach(editor) {\n        this.#editors.delete(editor.id);\n        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n        if (!this.#isDisabling && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor);\n        }\n    }\n    remove(editor) {\n        this.detach(editor);\n        this.#uiManager.removeEditor(editor);\n        editor.div.remove();\n        editor.isAttachedToDOM = false;\n        if (!this.#isCleaningUp) {\n            this.addInkEditorIfNeeded(false);\n        }\n    }\n    changeParent(editor) {\n        if (editor.parent === this) {\n            return;\n        }\n        if (editor.parent && editor.annotationElementId) {\n            this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n            AnnotationEditor.deleteAnnotationElement(editor);\n            editor.annotationElementId = null;\n        }\n        this.attach(editor);\n        editor.parent?.detach(editor);\n        editor.setParent(this);\n        if (editor.div && editor.isAttachedToDOM) {\n            editor.div.remove();\n            this.div.append(editor.div);\n        }\n    }\n    add(editor) {\n        if (editor.parent === this && editor.isAttachedToDOM) {\n            return;\n        }\n        this.changeParent(editor);\n        this.#uiManager.addEditor(editor);\n        this.attach(editor);\n        if (!editor.isAttachedToDOM) {\n            const div = editor.render();\n            this.div.append(div);\n            editor.isAttachedToDOM = true;\n        }\n        editor.fixAndSetPosition();\n        editor.onceAdded();\n        this.#uiManager.addToAnnotationStorage(editor);\n        editor._reportTelemetry(editor.telemetryInitialData);\n    }\n    moveEditorInDOM(editor) {\n        if (!editor.isAttachedToDOM) {\n            return;\n        }\n        const { activeElement } = document;\n        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n            editor._focusEventsAllowed = false;\n            this.#editorFocusTimeoutId = setTimeout(()=>{\n                this.#editorFocusTimeoutId = null;\n                if (!editor.div.contains(document.activeElement)) {\n                    editor.div.addEventListener(\"focusin\", ()=>{\n                        editor._focusEventsAllowed = true;\n                    }, {\n                        once: true,\n                        signal: this.#uiManager._signal\n                    });\n                    activeElement.focus();\n                } else {\n                    editor._focusEventsAllowed = true;\n                }\n            }, 0);\n        }\n        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n    }\n    addOrRebuild(editor) {\n        if (editor.needsToBeRebuilt()) {\n            editor.parent ||= this;\n            editor.rebuild();\n            editor.show();\n        } else {\n            this.add(editor);\n        }\n    }\n    addUndoableEditor(editor) {\n        const cmd = ()=>editor._uiManager.rebuild(editor);\n        const undo = ()=>{\n            editor.remove();\n        };\n        this.addCommands({\n            cmd,\n            undo,\n            mustExec: false\n        });\n    }\n    getNextId() {\n        return this.#uiManager.getId();\n    }\n    get #currentEditorType() {\n        return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n    }\n    combinedSignal(ac) {\n        return this.#uiManager.combinedSignal(ac);\n    }\n    #createNewEditor(params) {\n        const editorType = this.#currentEditorType;\n        return editorType ? new editorType.prototype.constructor(params) : null;\n    }\n    canCreateNewEmptyEditor() {\n        return this.#currentEditorType?.canCreateNewEmptyEditor();\n    }\n    pasteEditor(mode, params) {\n        this.#uiManager.updateToolbar(mode);\n        this.#uiManager.updateMode(mode);\n        const { offsetX, offsetY } = this.#getCenterPoint();\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: offsetX,\n            y: offsetY,\n            uiManager: this.#uiManager,\n            isCentered: true,\n            ...params\n        });\n        if (editor) {\n            this.add(editor);\n        }\n    }\n    async deserialize(data) {\n        return await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;\n    }\n    createAndAddNewEditor(event, isCentered, data = {}) {\n        const id = this.getNextId();\n        const editor = this.#createNewEditor({\n            parent: this,\n            id,\n            x: event.offsetX,\n            y: event.offsetY,\n            uiManager: this.#uiManager,\n            isCentered,\n            ...data\n        });\n        if (editor) {\n            this.add(editor);\n        }\n        return editor;\n    }\n    #getCenterPoint() {\n        const { x, y, width, height } = this.div.getBoundingClientRect();\n        const tlX = Math.max(0, x);\n        const tlY = Math.max(0, y);\n        const brX = Math.min(window.innerWidth, x + width);\n        const brY = Math.min(window.innerHeight, y + height);\n        const centerX = (tlX + brX) / 2 - x;\n        const centerY = (tlY + brY) / 2 - y;\n        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [\n            centerX,\n            centerY\n        ] : [\n            centerY,\n            centerX\n        ];\n        return {\n            offsetX,\n            offsetY\n        };\n    }\n    addNewEditor() {\n        this.createAndAddNewEditor(this.#getCenterPoint(), true);\n    }\n    setSelected(editor) {\n        this.#uiManager.setSelected(editor);\n    }\n    toggleSelected(editor) {\n        this.#uiManager.toggleSelected(editor);\n    }\n    unselect(editor) {\n        this.#uiManager.unselect(editor);\n    }\n    pointerup(event) {\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        if (!this.#hadPointerDown) {\n            return;\n        }\n        this.#hadPointerDown = false;\n        if (!this.#allowClick) {\n            this.#allowClick = true;\n            return;\n        }\n        if (this.#uiManager.getMode() === AnnotationEditorType.STAMP) {\n            this.#uiManager.unselectAll();\n            return;\n        }\n        this.createAndAddNewEditor(event, false);\n    }\n    pointerdown(event) {\n        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n            this.enableTextSelection();\n        }\n        if (this.#hadPointerDown) {\n            this.#hadPointerDown = false;\n            return;\n        }\n        const { isMac } = util_FeatureTest.platform;\n        if (event.button !== 0 || event.ctrlKey && isMac) {\n            return;\n        }\n        if (event.target !== this.div) {\n            return;\n        }\n        this.#hadPointerDown = true;\n        const editor = this.#uiManager.getActive();\n        this.#allowClick = !editor || editor.isEmpty();\n    }\n    findNewParent(editor, x, y) {\n        const layer = this.#uiManager.findParent(x, y);\n        if (layer === null || layer === this) {\n            return false;\n        }\n        layer.changeParent(editor);\n        return true;\n    }\n    destroy() {\n        if (this.#uiManager.getActive()?.parent === this) {\n            this.#uiManager.commitOrRemove();\n            this.#uiManager.setActiveEditor(null);\n        }\n        if (this.#editorFocusTimeoutId) {\n            clearTimeout(this.#editorFocusTimeoutId);\n            this.#editorFocusTimeoutId = null;\n        }\n        for (const editor of this.#editors.values()){\n            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n            editor.setParent(null);\n            editor.isAttachedToDOM = false;\n            editor.div.remove();\n        }\n        this.div = null;\n        this.#editors.clear();\n        this.#uiManager.removeLayer(this);\n    }\n    #cleanup() {\n        this.#isCleaningUp = true;\n        for (const editor of this.#editors.values()){\n            if (editor.isEmpty()) {\n                editor.remove();\n            }\n        }\n        this.#isCleaningUp = false;\n    }\n    render({ viewport }) {\n        this.viewport = viewport;\n        setLayerDimensions(this.div, viewport);\n        for (const editor of this.#uiManager.getEditors(this.pageIndex)){\n            this.add(editor);\n            editor.rebuild();\n        }\n        this.updateMode();\n    }\n    update({ viewport }) {\n        this.#uiManager.commitOrRemove();\n        this.#cleanup();\n        const oldRotation = this.viewport.rotation;\n        const rotation = viewport.rotation;\n        this.viewport = viewport;\n        setLayerDimensions(this.div, {\n            rotation\n        });\n        if (oldRotation !== rotation) {\n            for (const editor of this.#editors.values()){\n                editor.rotate(rotation);\n            }\n        }\n        this.addInkEditorIfNeeded(false);\n    }\n    get pageDimensions() {\n        const { pageWidth, pageHeight } = this.viewport.rawDims;\n        return [\n            pageWidth,\n            pageHeight\n        ];\n    }\n    get scale() {\n        return this.#uiManager.viewParameters.realScale;\n    }\n}\n; // ./src/display/draw_layer.js\nclass DrawLayer {\n    #parent;\n    #id;\n    #mapping;\n    #toUpdate;\n    constructor({ pageIndex }){\n        this.#parent = null;\n        this.#id = 0;\n        this.#mapping = new Map();\n        this.#toUpdate = new Map();\n        this.pageIndex = pageIndex;\n    }\n    setParent(parent) {\n        if (!this.#parent) {\n            this.#parent = parent;\n            return;\n        }\n        if (this.#parent !== parent) {\n            if (this.#mapping.size > 0) {\n                for (const root of this.#mapping.values()){\n                    root.remove();\n                    parent.append(root);\n                }\n            }\n            this.#parent = parent;\n        }\n    }\n    static get _svgFactory() {\n        return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n    }\n    static #setBox(element, { x = 0, y = 0, width = 1, height = 1 } = {}) {\n        const { style } = element;\n        style.top = `${100 * y}%`;\n        style.left = `${100 * x}%`;\n        style.width = `${100 * width}%`;\n        style.height = `${100 * height}%`;\n    }\n    #createSVG(box) {\n        const svg = DrawLayer._svgFactory.create(1, 1, true);\n        this.#parent.append(svg);\n        svg.setAttribute(\"aria-hidden\", true);\n        DrawLayer.#setBox(svg, box);\n        return svg;\n    }\n    #createClipPath(defs, pathId) {\n        const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n        defs.append(clipPath);\n        const clipPathId = `clip_${pathId}`;\n        clipPath.setAttribute(\"id\", clipPathId);\n        clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n        const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n        clipPath.append(clipPathUse);\n        clipPathUse.setAttribute(\"href\", `#${pathId}`);\n        clipPathUse.classList.add(\"clip\");\n        return clipPathId;\n    }\n    draw(outlines, color, opacity, isPathUpdatable = false) {\n        const id = this.#id++;\n        const root = this.#createSVG(outlines.box);\n        root.classList.add(...outlines.classNamesForDrawing);\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"d\", outlines.toSVGPath());\n        if (isPathUpdatable) {\n            this.#toUpdate.set(id, path);\n        }\n        const clipPathId = this.#createClipPath(defs, pathId);\n        const use = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use);\n        root.setAttribute(\"fill\", color);\n        root.setAttribute(\"fill-opacity\", opacity);\n        use.setAttribute(\"href\", `#${pathId}`);\n        this.#mapping.set(id, root);\n        return {\n            id,\n            clipPathId: `url(#${clipPathId})`\n        };\n    }\n    drawOutline(outlines) {\n        const id = this.#id++;\n        const root = this.#createSVG(outlines.box);\n        root.classList.add(...outlines.classNamesForOutlining);\n        const defs = DrawLayer._svgFactory.createElement(\"defs\");\n        root.append(defs);\n        const path = DrawLayer._svgFactory.createElement(\"path\");\n        defs.append(path);\n        const pathId = `path_p${this.pageIndex}_${id}`;\n        path.setAttribute(\"id\", pathId);\n        path.setAttribute(\"d\", outlines.toSVGPath());\n        path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n        let maskId;\n        if (outlines.mustRemoveSelfIntersections) {\n            const mask = DrawLayer._svgFactory.createElement(\"mask\");\n            defs.append(mask);\n            maskId = `mask_p${this.pageIndex}_${id}`;\n            mask.setAttribute(\"id\", maskId);\n            mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n            const rect = DrawLayer._svgFactory.createElement(\"rect\");\n            mask.append(rect);\n            rect.setAttribute(\"width\", \"1\");\n            rect.setAttribute(\"height\", \"1\");\n            rect.setAttribute(\"fill\", \"white\");\n            const use = DrawLayer._svgFactory.createElement(\"use\");\n            mask.append(use);\n            use.setAttribute(\"href\", `#${pathId}`);\n            use.setAttribute(\"stroke\", \"none\");\n            use.setAttribute(\"fill\", \"black\");\n            use.setAttribute(\"fill-rule\", \"nonzero\");\n            use.classList.add(\"mask\");\n        }\n        const use1 = DrawLayer._svgFactory.createElement(\"use\");\n        root.append(use1);\n        use1.setAttribute(\"href\", `#${pathId}`);\n        if (maskId) {\n            use1.setAttribute(\"mask\", `url(#${maskId})`);\n        }\n        const use2 = use1.cloneNode();\n        root.append(use2);\n        use1.classList.add(\"mainOutline\");\n        use2.classList.add(\"secondaryOutline\");\n        this.#mapping.set(id, root);\n        return id;\n    }\n    finalizeLine(id, line) {\n        const path = this.#toUpdate.get(id);\n        this.#toUpdate.delete(id);\n        this.updateBox(id, line.box);\n        path.setAttribute(\"d\", line.toSVGPath());\n    }\n    updateLine(id, line) {\n        const root = this.#mapping.get(id);\n        const defs = root.firstChild;\n        const path = defs.firstChild;\n        path.setAttribute(\"d\", line.toSVGPath());\n    }\n    updatePath(id, line) {\n        this.#toUpdate.get(id).setAttribute(\"d\", line.toSVGPath());\n    }\n    updateBox(id, box) {\n        DrawLayer.#setBox(this.#mapping.get(id), box);\n    }\n    show(id, visible) {\n        this.#mapping.get(id).classList.toggle(\"hidden\", !visible);\n    }\n    rotate(id, angle) {\n        this.#mapping.get(id).setAttribute(\"data-main-rotation\", angle);\n    }\n    changeColor(id, color) {\n        this.#mapping.get(id).setAttribute(\"fill\", color);\n    }\n    changeOpacity(id, opacity) {\n        this.#mapping.get(id).setAttribute(\"fill-opacity\", opacity);\n    }\n    addClass(id, className) {\n        this.#mapping.get(id).classList.add(className);\n    }\n    removeClass(id, className) {\n        this.#mapping.get(id).classList.remove(className);\n    }\n    getSVGRoot(id) {\n        return this.#mapping.get(id);\n    }\n    remove(id) {\n        this.#toUpdate.delete(id);\n        if (this.#parent === null) {\n            return;\n        }\n        this.#mapping.get(id).remove();\n        this.#mapping.delete(id);\n    }\n    destroy() {\n        this.#parent = null;\n        for (const root of this.#mapping.values()){\n            root.remove();\n        }\n        this.#mapping.clear();\n        this.#toUpdate.clear();\n    }\n}\n; // ./src/pdf.js\nconst pdfjsVersion = \"4.8.69\";\nconst pdfjsBuild = \"3634dab10\";\nvar __webpack_exports__AbortException = __nested_webpack_exports__.AbortException;\nvar __webpack_exports__AnnotationEditorLayer = __nested_webpack_exports__.AnnotationEditorLayer;\nvar __webpack_exports__AnnotationEditorParamsType = __nested_webpack_exports__.AnnotationEditorParamsType;\nvar __webpack_exports__AnnotationEditorType = __nested_webpack_exports__.AnnotationEditorType;\nvar __webpack_exports__AnnotationEditorUIManager = __nested_webpack_exports__.AnnotationEditorUIManager;\nvar __webpack_exports__AnnotationLayer = __nested_webpack_exports__.AnnotationLayer;\nvar __webpack_exports__AnnotationMode = __nested_webpack_exports__.AnnotationMode;\nvar __webpack_exports__ColorPicker = __nested_webpack_exports__.ColorPicker;\nvar __webpack_exports__DOMSVGFactory = __nested_webpack_exports__.DOMSVGFactory;\nvar __webpack_exports__DrawLayer = __nested_webpack_exports__.DrawLayer;\nvar __webpack_exports__FeatureTest = __nested_webpack_exports__.FeatureTest;\nvar __webpack_exports__GlobalWorkerOptions = __nested_webpack_exports__.GlobalWorkerOptions;\nvar __webpack_exports__ImageKind = __nested_webpack_exports__.ImageKind;\nvar __webpack_exports__InvalidPDFException = __nested_webpack_exports__.InvalidPDFException;\nvar __webpack_exports__MissingPDFException = __nested_webpack_exports__.MissingPDFException;\nvar __webpack_exports__OPS = __nested_webpack_exports__.OPS;\nvar __webpack_exports__OutputScale = __nested_webpack_exports__.OutputScale;\nvar __webpack_exports__PDFDataRangeTransport = __nested_webpack_exports__.PDFDataRangeTransport;\nvar __webpack_exports__PDFDateString = __nested_webpack_exports__.PDFDateString;\nvar __webpack_exports__PDFWorker = __nested_webpack_exports__.PDFWorker;\nvar __webpack_exports__PasswordResponses = __nested_webpack_exports__.PasswordResponses;\nvar __webpack_exports__PermissionFlag = __nested_webpack_exports__.PermissionFlag;\nvar __webpack_exports__PixelsPerInch = __nested_webpack_exports__.PixelsPerInch;\nvar __webpack_exports__RenderingCancelledException = __nested_webpack_exports__.RenderingCancelledException;\nvar __webpack_exports__TextLayer = __nested_webpack_exports__.TextLayer;\nvar __webpack_exports__UnexpectedResponseException = __nested_webpack_exports__.UnexpectedResponseException;\nvar __webpack_exports__Util = __nested_webpack_exports__.Util;\nvar __webpack_exports__VerbosityLevel = __nested_webpack_exports__.VerbosityLevel;\nvar __webpack_exports__XfaLayer = __nested_webpack_exports__.XfaLayer;\nvar __webpack_exports__build = __nested_webpack_exports__.build;\nvar __webpack_exports__createValidAbsoluteUrl = __nested_webpack_exports__.createValidAbsoluteUrl;\nvar __webpack_exports__fetchData = __nested_webpack_exports__.fetchData;\nvar __webpack_exports__getDocument = __nested_webpack_exports__.getDocument;\nvar __webpack_exports__getFilenameFromUrl = __nested_webpack_exports__.getFilenameFromUrl;\nvar __webpack_exports__getPdfFilenameFromUrl = __nested_webpack_exports__.getPdfFilenameFromUrl;\nvar __webpack_exports__getXfaPageViewport = __nested_webpack_exports__.getXfaPageViewport;\nvar __webpack_exports__isDataScheme = __nested_webpack_exports__.isDataScheme;\nvar __webpack_exports__isPdfFile = __nested_webpack_exports__.isPdfFile;\nvar __webpack_exports__noContextMenu = __nested_webpack_exports__.noContextMenu;\nvar __webpack_exports__normalizeUnicode = __nested_webpack_exports__.normalizeUnicode;\nvar __webpack_exports__setLayerDimensions = __nested_webpack_exports__.setLayerDimensions;\nvar __webpack_exports__shadow = __nested_webpack_exports__.shadow;\nvar __webpack_exports__version = __nested_webpack_exports__.version;\n //# sourceMappingURL=pdf.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2J1aWxkL3BkZi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW9CQyxHQUVELE1BQU0sR0FBRyxvQkFBb0I7QUFDN0IsTUFBTSxHQUFHLElBQUlBLDhCQUFtQkEsR0FBRyxDQUFDO0FBQ3BDLE1BQU0sR0FDTix3RUFBd0UsR0FDeEUsTUFBTSxHQUFHLDJDQUEyQyxHQUNwRCxNQUFNLEdBQUk7SUFDVixNQUFNLEdBQUksOENBQThDO0lBQ3hELE1BQU0sR0FBSUEsOEJBQW1CQSxDQUFDQyxDQUFDLEdBQUcsQ0FBQ0MsU0FBU0M7UUFDNUMsTUFBTSxHQUFLLElBQUksSUFBSUMsT0FBT0QsV0FBWTtZQUN0QyxNQUFNLEdBQU0sSUFBR0gsOEJBQW1CQSxDQUFDSyxDQUFDLENBQUNGLFlBQVlDLFFBQVEsQ0FBQ0osOEJBQW1CQSxDQUFDSyxDQUFDLENBQUNILFNBQVNFLE1BQU07Z0JBQy9GLE1BQU0sR0FBT0UsT0FBT0MsY0FBYyxDQUFDTCxTQUFTRSxLQUFLO29CQUFFSSxZQUFZO29CQUFNQyxLQUFLTixVQUFVLENBQUNDLElBQUk7Z0JBQUM7WUFDMUYsTUFBTSxHQUFNO1FBQ1osTUFBTSxHQUFLO0lBQ1gsTUFBTSxHQUFJO0FBQ1YsTUFBTSxHQUFHO0FBQ1QsTUFBTSxHQUNOLE1BQU0sR0FBRyw0Q0FBNEMsR0FDckQsTUFBTSxHQUFJO0lBQ1YsTUFBTSxHQUFJSiw4QkFBbUJBLENBQUNLLENBQUMsR0FBRyxDQUFDSyxLQUFLQyxPQUFVTCxPQUFPTSxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixLQUFLQztBQUM1RixNQUFNLEdBQUc7QUFDVCxNQUFNLEdBQ04sd0VBQXdFLEdBQ3hFLElBQUlJLDBCQUFtQkEsR0FBR0MsV0FBV0MsUUFBUSxHQUFH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R0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUU7WUFBRUQsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUU7WUFBRUEsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUUsR0FBR0MsRUFBRSxDQUFDLEVBQUUsR0FBR0QsRUFBRSxDQUFDLEVBQUU7U0FBQztJQUNuTjtJQUNBLE9BQU9FLGVBQWVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQzFCLE1BQU1DLEtBQUtGLENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1FBQzNDLE1BQU1FLEtBQUtILENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1FBQzNDLE9BQU87WUFBQ0M7WUFBSUM7U0FBRztJQUNqQjtJQUNBLE9BQU9DLHNCQUFzQkosQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDakMsTUFBTTNaLElBQUky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WUFBWTtBQUN0RSxJQUFJbzhHLCtCQUErQjcrRywwQkFBbUJBLENBQUMwQyxTQUFTO0FBQ2hFLElBQUlvOEcsbUNBQW1DOStHLDBCQUFtQkEsQ0FBQzJDLGFBQWE7QUFDeEUsSUFBSW84RyxzQ0FBc0MvK0csMEJBQW1CQSxDQUFDNEMsZ0JBQWdCO0FBQzlFLElBQUlvOEcsd0NBQXdDaC9HLDBCQUFtQkEsQ0FBQzZDLGtCQUFrQjtBQUNsRixJQUFJbzhHLDRCQUE0QmovRywwQkFBbUJBLENBQUM4QyxNQUFNO0FBQzFELElBQUlvOEcsNkJBQTZCbC9HLDBCQUFtQkEsQ0FBQytDLE9BQU87QUFDeXRFLENBRXJ4RSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJlZXItZ3VpZGFuY2UvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGRmL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2J1aWxkL3BkZi5tanM/YzcwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICpcbiAqIENvcHlyaWdodCAyMDI0IE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqL1xuXG4vKioqKioqLyAvLyBUaGUgcmVxdWlyZSBzY29wZVxuLyoqKioqKi8gdmFyIF9fd2VicGFja19yZXF1aXJlX18gPSB7fTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IGdsb2JhbFRoaXMucGRmanNMaWIgPSB7fTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgQWJvcnRFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBYm9ydEV4Y2VwdGlvbiksXG4gIEFubm90YXRpb25FZGl0b3JMYXllcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFubm90YXRpb25FZGl0b3JMYXllciksXG4gIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUpLFxuICBBbm5vdGF0aW9uRWRpdG9yVHlwZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFubm90YXRpb25FZGl0b3JUeXBlKSxcbiAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIpLFxuICBBbm5vdGF0aW9uTGF5ZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbm5vdGF0aW9uTGF5ZXIpLFxuICBBbm5vdGF0aW9uTW9kZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFubm90YXRpb25Nb2RlKSxcbiAgQ29sb3JQaWNrZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xvclBpY2tlciksXG4gIERPTVNWR0ZhY3Rvcnk6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBET01TVkdGYWN0b3J5KSxcbiAgRHJhd0xheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRHJhd0xheWVyKSxcbiAgRmVhdHVyZVRlc3Q6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB1dGlsX0ZlYXR1cmVUZXN0KSxcbiAgR2xvYmFsV29ya2VyT3B0aW9uczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdsb2JhbFdvcmtlck9wdGlvbnMpLFxuICBJbWFnZUtpbmQ6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB1dGlsX0ltYWdlS2luZCksXG4gIEludmFsaWRQREZFeGNlcHRpb246ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJbnZhbGlkUERGRXhjZXB0aW9uKSxcbiAgTWlzc2luZ1BERkV4Y2VwdGlvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1pc3NpbmdQREZFeGNlcHRpb24pLFxuICBPUFM6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPUFMpLFxuICBPdXRwdXRTY2FsZTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE91dHB1dFNjYWxlKSxcbiAgUERGRGF0YVJhbmdlVHJhbnNwb3J0OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUERGRGF0YVJhbmdlVHJhbnNwb3J0KSxcbiAgUERGRGF0ZVN0cmluZzogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBERkRhdGVTdHJpbmcpLFxuICBQREZXb3JrZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQREZXb3JrZXIpLFxuICBQYXNzd29yZFJlc3BvbnNlczogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBhc3N3b3JkUmVzcG9uc2VzKSxcbiAgUGVybWlzc2lvbkZsYWc6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQZXJtaXNzaW9uRmxhZyksXG4gIFBpeGVsc1BlckluY2g6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQaXhlbHNQZXJJbmNoKSxcbiAgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSxcbiAgVGV4dExheWVyOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVGV4dExheWVyKSxcbiAgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKSxcbiAgVXRpbDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFV0aWwpLFxuICBWZXJib3NpdHlMZXZlbDogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFZlcmJvc2l0eUxldmVsKSxcbiAgWGZhTGF5ZXI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBYZmFMYXllciksXG4gIGJ1aWxkOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gYnVpbGQpLFxuICBjcmVhdGVWYWxpZEFic29sdXRlVXJsOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCksXG4gIGZldGNoRGF0YTogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGZldGNoRGF0YSksXG4gIGdldERvY3VtZW50OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gZ2V0RG9jdW1lbnQpLFxuICBnZXRGaWxlbmFtZUZyb21Vcmw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBnZXRGaWxlbmFtZUZyb21VcmwpLFxuICBnZXRQZGZGaWxlbmFtZUZyb21Vcmw6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBnZXRQZGZGaWxlbmFtZUZyb21VcmwpLFxuICBnZXRYZmFQYWdlVmlld3BvcnQ6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBnZXRYZmFQYWdlVmlld3BvcnQpLFxuICBpc0RhdGFTY2hlbWU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBpc0RhdGFTY2hlbWUpLFxuICBpc1BkZkZpbGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBpc1BkZkZpbGUpLFxuICBub0NvbnRleHRNZW51OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gbm9Db250ZXh0TWVudSksXG4gIG5vcm1hbGl6ZVVuaWNvZGU6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBub3JtYWxpemVVbmljb2RlKSxcbiAgc2V0TGF5ZXJEaW1lbnNpb25zOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gc2V0TGF5ZXJEaW1lbnNpb25zKSxcbiAgc2hhZG93OiAoKSA9PiAoLyogcmVleHBvcnQgKi8gc2hhZG93KSxcbiAgdmVyc2lvbjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHZlcnNpb24pXG59KTtcblxuOy8vIC4vc3JjL3NoYXJlZC91dGlsLmpzXG5jb25zdCBpc05vZGVKUyA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuY29uc3QgSURFTlRJVFlfTUFUUklYID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmNvbnN0IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gMTBlNjtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmNvbnN0IExJTkVfREVTQ0VOVF9GQUNUT1IgPSAwLjM1O1xuY29uc3QgQkFTRUxJTkVfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUiAvIExJTkVfRkFDVE9SO1xuY29uc3QgUmVuZGVyaW5nSW50ZW50RmxhZyA9IHtcbiAgQU5ZOiAweDAxLFxuICBESVNQTEFZOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgU0FWRTogMHgwOCxcbiAgQU5OT1RBVElPTlNfRk9STVM6IDB4MTAsXG4gIEFOTk9UQVRJT05TX1NUT1JBR0U6IDB4MjAsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDB4NDAsXG4gIElTX0VESVRJTkc6IDB4ODAsXG4gIE9QTElTVDogMHgxMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclR5cGUgPSB7XG4gIERJU0FCTEU6IC0xLFxuICBOT05FOiAwLFxuICBGUkVFVEVYVDogMyxcbiAgSElHSExJR0hUOiA5LFxuICBTVEFNUDogMTMsXG4gIElOSzogMTVcbn07XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgUkVTSVpFOiAxLFxuICBDUkVBVEU6IDIsXG4gIEZSRUVURVhUX1NJWkU6IDExLFxuICBGUkVFVEVYVF9DT0xPUjogMTIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDEzLFxuICBJTktfQ09MT1I6IDIxLFxuICBJTktfVEhJQ0tORVNTOiAyMixcbiAgSU5LX09QQUNJVFk6IDIzLFxuICBISUdITElHSFRfQ09MT1I6IDMxLFxuICBISUdITElHSFRfREVGQVVMVF9DT0xPUjogMzIsXG4gIEhJR0hMSUdIVF9USElDS05FU1M6IDMzLFxuICBISUdITElHSFRfRlJFRTogMzQsXG4gIEhJR0hMSUdIVF9TSE9XX0FMTDogMzVcbn07XG5jb25zdCBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmNvbnN0IFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXG4gIFNUUk9LRV9BRERfVE9fUEFUSDogNSxcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXG4gIEFERF9UT19QQVRIOiA3LFxuICBGSUxMX1NUUk9LRV9NQVNLOiAzLFxuICBBRERfVE9fUEFUSF9GTEFHOiA0XG59O1xuY29uc3QgdXRpbF9JbWFnZUtpbmQgPSB7XG4gIEdSQVlTQ0FMRV8xQlBQOiAxLFxuICBSR0JfMjRCUFA6IDIsXG4gIFJHQkFfMzJCUFA6IDNcbn07XG5jb25zdCBBbm5vdGF0aW9uVHlwZSA9IHtcbiAgVEVYVDogMSxcbiAgTElOSzogMixcbiAgRlJFRVRFWFQ6IDMsXG4gIExJTkU6IDQsXG4gIFNRVUFSRTogNSxcbiAgQ0lSQ0xFOiA2LFxuICBQT0xZR09OOiA3LFxuICBQT0xZTElORTogOCxcbiAgSElHSExJR0hUOiA5LFxuICBVTkRFUkxJTkU6IDEwLFxuICBTUVVJR0dMWTogMTEsXG4gIFNUUklLRU9VVDogMTIsXG4gIFNUQU1QOiAxMyxcbiAgQ0FSRVQ6IDE0LFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIEZJTEVBVFRBQ0hNRU5UOiAxNyxcbiAgU09VTkQ6IDE4LFxuICBNT1ZJRTogMTksXG4gIFdJREdFVDogMjAsXG4gIFNDUkVFTjogMjEsXG4gIFBSSU5URVJNQVJLOiAyMixcbiAgVFJBUE5FVDogMjMsXG4gIFdBVEVSTUFSSzogMjQsXG4gIFRIUkVFRDogMjUsXG4gIFJFREFDVDogMjZcbn07XG5jb25zdCBBbm5vdGF0aW9uUmVwbHlUeXBlID0ge1xuICBHUk9VUDogXCJHcm91cFwiLFxuICBSRVBMWTogXCJSXCJcbn07XG5jb25zdCBBbm5vdGF0aW9uRmxhZyA9IHtcbiAgSU5WSVNJQkxFOiAweDAxLFxuICBISURERU46IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBOT1pPT006IDB4MDgsXG4gIE5PUk9UQVRFOiAweDEwLFxuICBOT1ZJRVc6IDB4MjAsXG4gIFJFQURPTkxZOiAweDQwLFxuICBMT0NLRUQ6IDB4ODAsXG4gIFRPR0dMRU5PVklFVzogMHgxMDAsXG4gIExPQ0tFRENPTlRFTlRTOiAweDIwMFxufTtcbmNvbnN0IEFubm90YXRpb25GaWVsZEZsYWcgPSB7XG4gIFJFQURPTkxZOiAweDAwMDAwMDEsXG4gIFJFUVVJUkVEOiAweDAwMDAwMDIsXG4gIE5PRVhQT1JUOiAweDAwMDAwMDQsXG4gIE1VTFRJTElORTogMHgwMDAxMDAwLFxuICBQQVNTV09SRDogMHgwMDAyMDAwLFxuICBOT1RPR0dMRVRPT0ZGOiAweDAwMDQwMDAsXG4gIFJBRElPOiAweDAwMDgwMDAsXG4gIFBVU0hCVVRUT046IDB4MDAxMDAwMCxcbiAgQ09NQk86IDB4MDAyMDAwMCxcbiAgRURJVDogMHgwMDQwMDAwLFxuICBTT1JUOiAweDAwODAwMDAsXG4gIEZJTEVTRUxFQ1Q6IDB4MDEwMDAwMCxcbiAgTVVMVElTRUxFQ1Q6IDB4MDIwMDAwMCxcbiAgRE9OT1RTUEVMTENIRUNLOiAweDA0MDAwMDAsXG4gIERPTk9UU0NST0xMOiAweDA4MDAwMDAsXG4gIENPTUI6IDB4MTAwMDAwMCxcbiAgUklDSFRFWFQ6IDB4MjAwMDAwMCxcbiAgUkFESU9TSU5VTklTT046IDB4MjAwMDAwMCxcbiAgQ09NTUlUT05TRUxDSEFOR0U6IDB4NDAwMDAwMFxufTtcbmNvbnN0IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSB7XG4gIFNPTElEOiAxLFxuICBEQVNIRUQ6IDIsXG4gIEJFVkVMRUQ6IDMsXG4gIElOU0VUOiA0LFxuICBVTkRFUkxJTkU6IDVcbn07XG5jb25zdCBBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlID0ge1xuICBFOiBcIk1vdXNlIEVudGVyXCIsXG4gIFg6IFwiTW91c2UgRXhpdFwiLFxuICBEOiBcIk1vdXNlIERvd25cIixcbiAgVTogXCJNb3VzZSBVcFwiLFxuICBGbzogXCJGb2N1c1wiLFxuICBCbDogXCJCbHVyXCIsXG4gIFBPOiBcIlBhZ2VPcGVuXCIsXG4gIFBDOiBcIlBhZ2VDbG9zZVwiLFxuICBQVjogXCJQYWdlVmlzaWJsZVwiLFxuICBQSTogXCJQYWdlSW52aXNpYmxlXCIsXG4gIEs6IFwiS2V5c3Ryb2tlXCIsXG4gIEY6IFwiRm9ybWF0XCIsXG4gIFY6IFwiVmFsaWRhdGVcIixcbiAgQzogXCJDYWxjdWxhdGVcIlxufTtcbmNvbnN0IERvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0ge1xuICBXQzogXCJXaWxsQ2xvc2VcIixcbiAgV1M6IFwiV2lsbFNhdmVcIixcbiAgRFM6IFwiRGlkU2F2ZVwiLFxuICBXUDogXCJXaWxsUHJpbnRcIixcbiAgRFA6IFwiRGlkUHJpbnRcIlxufTtcbmNvbnN0IFBhZ2VBY3Rpb25FdmVudFR5cGUgPSB7XG4gIE86IFwiUGFnZU9wZW5cIixcbiAgQzogXCJQYWdlQ2xvc2VcIlxufTtcbmNvbnN0IFZlcmJvc2l0eUxldmVsID0ge1xuICBFUlJPUlM6IDAsXG4gIFdBUk5JTkdTOiAxLFxuICBJTkZPUzogNVxufTtcbmNvbnN0IE9QUyA9IHtcbiAgZGVwZW5kZW5jeTogMSxcbiAgc2V0TGluZVdpZHRoOiAyLFxuICBzZXRMaW5lQ2FwOiAzLFxuICBzZXRMaW5lSm9pbjogNCxcbiAgc2V0TWl0ZXJMaW1pdDogNSxcbiAgc2V0RGFzaDogNixcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxuICBzZXRGbGF0bmVzczogOCxcbiAgc2V0R1N0YXRlOiA5LFxuICBzYXZlOiAxMCxcbiAgcmVzdG9yZTogMTEsXG4gIHRyYW5zZm9ybTogMTIsXG4gIG1vdmVUbzogMTMsXG4gIGxpbmVUbzogMTQsXG4gIGN1cnZlVG86IDE1LFxuICBjdXJ2ZVRvMjogMTYsXG4gIGN1cnZlVG8zOiAxNyxcbiAgY2xvc2VQYXRoOiAxOCxcbiAgcmVjdGFuZ2xlOiAxOSxcbiAgc3Ryb2tlOiAyMCxcbiAgY2xvc2VTdHJva2U6IDIxLFxuICBmaWxsOiAyMixcbiAgZW9GaWxsOiAyMyxcbiAgZmlsbFN0cm9rZTogMjQsXG4gIGVvRmlsbFN0cm9rZTogMjUsXG4gIGNsb3NlRmlsbFN0cm9rZTogMjYsXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcbiAgZW5kUGF0aDogMjgsXG4gIGNsaXA6IDI5LFxuICBlb0NsaXA6IDMwLFxuICBiZWdpblRleHQ6IDMxLFxuICBlbmRUZXh0OiAzMixcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxuICBzZXRXb3JkU3BhY2luZzogMzQsXG4gIHNldEhTY2FsZTogMzUsXG4gIHNldExlYWRpbmc6IDM2LFxuICBzZXRGb250OiAzNyxcbiAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IDM4LFxuICBzZXRUZXh0UmlzZTogMzksXG4gIG1vdmVUZXh0OiA0MCxcbiAgc2V0TGVhZGluZ01vdmVUZXh0OiA0MSxcbiAgc2V0VGV4dE1hdHJpeDogNDIsXG4gIG5leHRMaW5lOiA0MyxcbiAgc2hvd1RleHQ6IDQ0LFxuICBzaG93U3BhY2VkVGV4dDogNDUsXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxuICBuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDogNDcsXG4gIHNldENoYXJXaWR0aDogNDgsXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXG4gIHNldFN0cm9rZUNvbG9yU3BhY2U6IDUwLFxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcbiAgc2V0U3Ryb2tlQ29sb3JOOiA1MyxcbiAgc2V0RmlsbENvbG9yOiA1NCxcbiAgc2V0RmlsbENvbG9yTjogNTUsXG4gIHNldFN0cm9rZUdyYXk6IDU2LFxuICBzZXRGaWxsR3JheTogNTcsXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcbiAgc2V0RmlsbFJHQkNvbG9yOiA1OSxcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXG4gIHNoYWRpbmdGaWxsOiA2MixcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcbiAgZW5kSW5saW5lSW1hZ2U6IDY1LFxuICBwYWludFhPYmplY3Q6IDY2LFxuICBtYXJrUG9pbnQ6IDY3LFxuICBtYXJrUG9pbnRQcm9wczogNjgsXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcbiAgZW5kTWFya2VkQ29udGVudDogNzEsXG4gIGJlZ2luQ29tcGF0OiA3MixcbiAgZW5kQ29tcGF0OiA3MyxcbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiA3NCxcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXG4gIGJlZ2luR3JvdXA6IDc2LFxuICBlbmRHcm91cDogNzcsXG4gIGJlZ2luQW5ub3RhdGlvbjogODAsXG4gIGVuZEFubm90YXRpb246IDgxLFxuICBwYWludEltYWdlTWFza1hPYmplY3Q6IDgzLFxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cDogODQsXG4gIHBhaW50SW1hZ2VYT2JqZWN0OiA4NSxcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6IDg2LFxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwOiA4NyxcbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQ6IDg4LFxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQ6IDg5LFxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6IDkwLFxuICBjb25zdHJ1Y3RQYXRoOiA5MSxcbiAgc2V0U3Ryb2tlVHJhbnNwYXJlbnQ6IDkyLFxuICBzZXRGaWxsVHJhbnNwYXJlbnQ6IDkzXG59O1xuY29uc3QgUGFzc3dvcmRSZXNwb25zZXMgPSB7XG4gIE5FRURfUEFTU1dPUkQ6IDEsXG4gIElOQ09SUkVDVF9QQVNTV09SRDogMlxufTtcbmxldCB2ZXJib3NpdHkgPSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUztcbmZ1bmN0aW9uIHNldFZlcmJvc2l0eUxldmVsKGxldmVsKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGxldmVsKSkge1xuICAgIHZlcmJvc2l0eSA9IGxldmVsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWZXJib3NpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIHZlcmJvc2l0eTtcbn1cbmZ1bmN0aW9uIGluZm8obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuSU5GT1MpIHtcbiAgICBjb25zb2xlLmxvZyhgSW5mbzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1MpIHtcbiAgICBjb25zb2xlLmxvZyhgV2FybmluZzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdW5yZWFjaGFibGUobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzVmFsaWRQcm90b2NvbCh1cmwpIHtcbiAgc3dpdGNoICh1cmw/LnByb3RvY29sKSB7XG4gICAgY2FzZSBcImh0dHA6XCI6XG4gICAgY2FzZSBcImh0dHBzOlwiOlxuICAgIGNhc2UgXCJmdHA6XCI6XG4gICAgY2FzZSBcIm1haWx0bzpcIjpcbiAgICBjYXNlIFwidGVsOlwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKG9wdGlvbnMuYWRkRGVmYXVsdFByb3RvY29sICYmIHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgICAgICBjb25zdCBkb3RzID0gdXJsLm1hdGNoKC9cXC4vZyk7XG4gICAgICAgIGlmIChkb3RzPy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIHVybCA9IGBodHRwOi8vJHt1cmx9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJ5Q29udmVydEVuY29kaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gc3RyaW5nVG9VVEY4U3RyaW5nKHVybCk7XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWJzb2x1dGVVcmwgPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIGlmIChfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlVXJsO1xuICAgIH1cbiAgfSBjYXRjaCB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlLCBub25TZXJpYWxpemFibGUgPSBmYWxzZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgZW51bWVyYWJsZTogIW5vblNlcmlhbGl6YWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgfVxuICBCYXNlRXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuICBCYXNlRXhjZXB0aW9uLmNvbnN0cnVjdG9yID0gQmFzZUV4Y2VwdGlvbjtcbiAgcmV0dXJuIEJhc2VFeGNlcHRpb247XG59KCk7XG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2csIFwiUGFzc3dvcmRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxuY2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZGV0YWlscykge1xuICAgIHN1cGVyKG1zZywgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIik7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxufVxuY2xhc3MgSW52YWxpZFBERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuY2xhc3MgTWlzc2luZ1BERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiKTtcbiAgfVxufVxuY2xhc3MgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgc3RhdHVzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxufVxuY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkZvcm1hdEVycm9yXCIpO1xuICB9XG59XG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiQWJvcnRFeGNlcHRpb25cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyAhPT0gXCJvYmplY3RcIiB8fCBieXRlcz8ubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIGJ5dGVzVG9TdHJpbmdcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuICBjb25zdCBNQVhfQVJHVU1FTlRfQ09VTlQgPSA4MTkyO1xuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICBjb25zdCBjaHVua0VuZCA9IE1hdGgubWluKGkgKyBNQVhfQVJHVU1FTlRfQ09VTlQsIGxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zdWJhcnJheShpLCBjaHVua0VuZCk7XG4gICAgc3RyQnVmLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjaHVuaykpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBzdHJpbmdUb0J5dGVzXCIpO1xuICB9XG4gIGNvbnN0IGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMHhmZiwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cbmZ1bmN0aW9uIG9iamVjdFNpemUob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIG9iamVjdEZyb21NYXAobWFwKSB7XG4gIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIGlzTGl0dGxlRW5kaWFuKCkge1xuICBjb25zdCBidWZmZXI4ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGJ1ZmZlcjhbMF0gPSAxO1xuICBjb25zdCB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyB1dGlsX0ZlYXR1cmVUZXN0IHtcbiAgc3RhdGljIGdldCBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNMaXR0bGVFbmRpYW5cIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRXZhbFN1cHBvcnRlZFwiLCBpc0V2YWxTdXBwb3J0ZWQoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRcIiwgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBwbGF0Zm9ybSgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgbmF2aWdhdG9yPy5wbGF0Zm9ybSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgICAgaXNNYWM6IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmNsdWRlcyhcIk1hY1wiKSxcbiAgICAgICAgaXNXaW5kb3dzOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICAgIGlzRmlyZWZveDogdHlwZW9mIG5hdmlnYXRvcj8udXNlckFnZW50ID09PSBcInN0cmluZ1wiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJGaXJlZm94XCIpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgIGlzTWFjOiBmYWxzZSxcbiAgICAgIGlzV2luZG93czogZmFsc2UsXG4gICAgICBpc0ZpcmVmb3g6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0NTU1JvdW5kU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0NTU1JvdW5kU3VwcG9ydGVkXCIsIGdsb2JhbFRoaXMuQ1NTPy5zdXBwb3J0cz8uKFwid2lkdGg6IHJvdW5kKDEuNXB4LCAxcHgpXCIpKTtcbiAgfVxufVxuY29uc3QgaGV4TnVtYmVycyA9IEFycmF5LmZyb20oQXJyYXkoMjU2KS5rZXlzKCksIG4gPT4gbi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUhleENvbG9yKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gYCMke2hleE51bWJlcnNbcl19JHtoZXhOdW1iZXJzW2ddfSR7aGV4TnVtYmVyc1tiXX1gO1xuICB9XG4gIHN0YXRpYyBzY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIGxldCB0ZW1wO1xuICAgIGlmICh0cmFuc2Zvcm1bMF0pIHtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMF0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgaWYgKHRyYW5zZm9ybVszXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVszXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMV07XG4gICAgICBtaW5NYXhbMV0gPSB0ZW1wO1xuICAgICAgdGVtcCA9IG1pbk1heFsyXTtcbiAgICAgIG1pbk1heFsyXSA9IG1pbk1heFszXTtcbiAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICBpZiAodHJhbnNmb3JtWzFdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMl0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMF07XG4gICAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzJdO1xuICAgIH1cbiAgICBtaW5NYXhbMF0gKz0gdHJhbnNmb3JtWzRdO1xuICAgIG1pbk1heFsxXSArPSB0cmFuc2Zvcm1bNV07XG4gICAgbWluTWF4WzJdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbM10gKz0gdHJhbnNmb3JtWzVdO1xuICB9XG4gIHN0YXRpYyB0cmFuc2Zvcm0obTEsIG0yKSB7XG4gICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgIGNvbnN0IHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIGNvbnN0IHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgY29uc3QgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG4gIHN0YXRpYyBnZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChyLCBtKSB7XG4gICAgY29uc3QgcDEgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHIsIG0pO1xuICAgIGNvbnN0IHAyID0gdGhpcy5hcHBseVRyYW5zZm9ybShyLnNsaWNlKDIsIDQpLCBtKTtcbiAgICBjb25zdCBwMyA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMF0sIHJbM11dLCBtKTtcbiAgICBjb25zdCBwNCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0oW3JbMl0sIHJbMV1dLCBtKTtcbiAgICByZXR1cm4gW01hdGgubWluKHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSwgTWF0aC5taW4ocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pLCBNYXRoLm1heChwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWF4KHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKV07XG4gIH1cbiAgc3RhdGljIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCwgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH1cbiAgc3RhdGljIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcbiAgICBjb25zdCB0cmFuc3Bvc2UgPSBbbVswXSwgbVsyXSwgbVsxXSwgbVszXV07XG4gICAgY29uc3QgYSA9IG1bMF0gKiB0cmFuc3Bvc2VbMF0gKyBtWzFdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XG4gICAgY29uc3QgZCA9IG1bMl0gKiB0cmFuc3Bvc2VbMV0gKyBtWzNdICogdHJhbnNwb3NlWzNdO1xuICAgIGNvbnN0IGZpcnN0ID0gKGEgKyBkKSAvIDI7XG4gICAgY29uc3Qgc2Vjb25kID0gTWF0aC5zcXJ0KChhICsgZCkgKiogMiAtIDQgKiAoYSAqIGQgLSBjICogYikpIC8gMjtcbiAgICBjb25zdCBzeCA9IGZpcnN0ICsgc2Vjb25kIHx8IDE7XG4gICAgY29uc3Qgc3kgPSBmaXJzdCAtIHNlY29uZCB8fCAxO1xuICAgIHJldHVybiBbTWF0aC5zcXJ0KHN4KSwgTWF0aC5zcXJ0KHN5KV07XG4gIH1cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuICAgIGlmIChyZWN0WzBdID4gcmVjdFsyXSkge1xuICAgICAgclswXSA9IHJlY3RbMl07XG4gICAgICByWzJdID0gcmVjdFswXTtcbiAgICB9XG4gICAgaWYgKHJlY3RbMV0gPiByZWN0WzNdKSB7XG4gICAgICByWzFdID0gcmVjdFszXTtcbiAgICAgIHJbM10gPSByZWN0WzFdO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBzdGF0aWMgaW50ZXJzZWN0KHJlY3QxLCByZWN0Mikge1xuICAgIGNvbnN0IHhMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1pbihyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBjb25zdCB4SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWF4KHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGlmICh4TG93ID4geEhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB5TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5taW4ocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgY29uc3QgeUhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1heChyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBpZiAoeUxvdyA+IHlIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgdCwgbWluTWF4KSB7XG4gICAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbXQgPSAxIC0gdDtcbiAgICBjb25zdCB0dCA9IHQgKiB0O1xuICAgIGNvbnN0IHR0dCA9IHR0ICogdDtcbiAgICBjb25zdCB4ID0gbXQgKiAobXQgKiAobXQgKiB4MCArIDMgKiB0ICogeDEpICsgMyAqIHR0ICogeDIpICsgdHR0ICogeDM7XG4gICAgY29uc3QgeSA9IG10ICogKG10ICogKG10ICogeTAgKyAzICogdCAqIHkxKSArIDMgKiB0dCAqIHkyKSArIHR0dCAqIHkzO1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeCk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5KTtcbiAgICBtaW5NYXhbMl0gPSBNYXRoLm1heChtaW5NYXhbMl0sIHgpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeSk7XG4gIH1cbiAgc3RhdGljICNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIGEsIGIsIGMsIG1pbk1heCkge1xuICAgIGlmIChNYXRoLmFicyhhKSA8IDFlLTEyKSB7XG4gICAgICBpZiAoTWF0aC5hYnMoYikgPj0gMWUtMTIpIHtcbiAgICAgICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgLWMgLyBiLCBtaW5NYXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkZWx0YSA9IGIgKiogMiAtIDQgKiBjICogYTtcbiAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNxcnREZWx0YSA9IE1hdGguc3FydChkZWx0YSk7XG4gICAgY29uc3QgYTIgPSAyICogYTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bU9uQ3VydmUoeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAoLWIgKyBzcXJ0RGVsdGEpIC8gYTIsIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iIC0gc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICB9XG4gIHN0YXRpYyBiZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGlmIChtaW5NYXgpIHtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeDAsIHgzKTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeTAsIHkzKTtcbiAgICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeDAsIHgzKTtcbiAgICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeTAsIHkzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluTWF4ID0gW01hdGgubWluKHgwLCB4MyksIE1hdGgubWluKHkwLCB5MyksIE1hdGgubWF4KHgwLCB4MyksIE1hdGgubWF4KHkwLCB5MyldO1xuICAgIH1cbiAgICB0aGlzLiNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIDMgKiAoLXgwICsgMyAqICh4MSAtIHgyKSArIHgzKSwgNiAqICh4MCAtIDIgKiB4MSArIHgyKSwgMyAqICh4MSAtIHgwKSwgbWluTWF4KTtcbiAgICB0aGlzLiNnZXRFeHRyZW11bSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIDMgKiAoLXkwICsgMyAqICh5MSAtIHkyKSArIHkzKSwgNiAqICh5MCAtIDIgKiB5MSArIHkyKSwgMyAqICh5MSAtIHkwKSwgbWluTWF4KTtcbiAgICByZXR1cm4gbWluTWF4O1xuICB9XG59XG5jb25zdCBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJkOCwgMHgyYzcsIDB4MmM2LCAweDJkOSwgMHgyZGQsIDB4MmRiLCAweDJkYSwgMHgyZGMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNhLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFlLCAweDIwMWMsIDB4MjAxZCwgMHgyMDE4LCAweDIwMTksIDB4MjAxYSwgMHgyMTIyLCAweGZiMDEsIDB4ZmIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdkLCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN2UsIDAsIDB4MjBhY10pKTtcbmZ1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKHN0cikge1xuICBpZiAoc3RyWzBdID49IFwiXFx4RUZcIikge1xuICAgIGxldCBlbmNvZGluZztcbiAgICBpZiAoc3RyWzBdID09PSBcIlxceEZFXCIgJiYgc3RyWzFdID09PSBcIlxceEZGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZiZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmxlXCI7XG4gICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhFRlwiICYmIHN0clsxXSA9PT0gXCJcXHhCQlwiICYmIHN0clsyXSA9PT0gXCJcXHhCRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLThcIjtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXMoc3RyKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIGlmICghZGVjb2RlZC5pbmNsdWRlcyhcIlxceDFiXCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY29kZWQucmVwbGFjZUFsbCgvXFx4MWJbXlxceDFiXSooPzpcXHgxYnwkKS9nLCBcIlwiKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHdhcm4oYHN0cmluZ1RvUERGU3RyaW5nOiBcIiR7ZXh9XCIuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNoYXJDb2RlID09PSAweDFiKSB7XG4gICAgICB3aGlsZSAoKytpIDwgaWkgJiYgc3RyLmNoYXJDb2RlQXQoaSkgIT09IDB4MWIpIHt9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW2NoYXJDb2RlXTtcbiAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9TdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGFycjEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZShkYXRlID0gbmV3IERhdGUoKSkge1xuICBjb25zdCBidWZmZXIgPSBbZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCksIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpXTtcbiAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xufVxubGV0IE5vcm1hbGl6ZVJlZ2V4ID0gbnVsbDtcbmxldCBOb3JtYWxpemF0aW9uTWFwID0gbnVsbDtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaWNvZGUoc3RyKSB7XG4gIGlmICghTm9ybWFsaXplUmVnZXgpIHtcbiAgICBOb3JtYWxpemVSZWdleCA9IC8oW1xcdTAwYTBcXHUwMGI1XFx1MDM3ZVxcdTBlYjNcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjEyNlxcdWZiMDAtXFx1ZmIwNFxcdWZiMDZcXHVmYjIwLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYmExXFx1ZmJhNC1cXHVmYmE5XFx1ZmJhZS1cXHVmYmIxXFx1ZmJkMy1cXHVmYmRjXFx1ZmJkZS1cXHVmYmU3XFx1ZmJlYS1cXHVmYmY4XFx1ZmJmYy1cXHVmYmZkXFx1ZmMwMC1cXHVmYzVkXFx1ZmM2NC1cXHVmY2YxXFx1ZmNmNS1cXHVmZDNkXFx1ZmQ4OFxcdWZkZjRcXHVmZGZhLVxcdWZkZmJcXHVmZTcxXFx1ZmU3N1xcdWZlNzlcXHVmZTdiXFx1ZmU3ZF0rKXwoXFx1ZmIwNSspL2d1O1xuICAgIE5vcm1hbGl6YXRpb25NYXAgPSBuZXcgTWFwKFtbXCLvrIVcIiwgXCLFv3RcIl1dKTtcbiAgfVxuICByZXR1cm4gc3RyLnJlcGxhY2VBbGwoTm9ybWFsaXplUmVnZXgsIChfLCBwMSwgcDIpID0+IHAxID8gcDEubm9ybWFsaXplKFwiTkZLQ1wiKSA6IE5vcm1hbGl6YXRpb25NYXAuZ2V0KHAyKSk7XG59XG5mdW5jdGlvbiBnZXRVdWlkKCkge1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3J5cHRvPy5yYW5kb21VVUlEID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgfVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBjcnlwdG8/LmdldFJhbmRvbVZhbHVlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWYpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgYnVmW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU1KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVzVG9TdHJpbmcoYnVmKTtcbn1cbmNvbnN0IEFubm90YXRpb25QcmVmaXggPSBcInBkZmpzX2ludGVybmFsX2lkX1wiO1xuY29uc3QgRm9udFJlbmRlck9wcyA9IHtcbiAgQkVaSUVSX0NVUlZFX1RPOiAwLFxuICBNT1ZFX1RPOiAxLFxuICBMSU5FX1RPOiAyLFxuICBRVUFEUkFUSUNfQ1VSVkVfVE86IDMsXG4gIFJFU1RPUkU6IDQsXG4gIFNBVkU6IDUsXG4gIFNDQUxFOiA2LFxuICBUUkFOU0ZPUk06IDcsXG4gIFRSQU5TTEFURTogOFxufTtcbmZ1bmN0aW9uIHRvSGV4VXRpbChhcnIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvSGV4KSB7XG4gICAgcmV0dXJuIGFyci50b0hleCgpO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKGFyciwgbnVtID0+IGhleE51bWJlcnNbbnVtXSkuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0VXRpbChhcnIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkucHJvdG90eXBlLnRvQmFzZTY0KSB7XG4gICAgcmV0dXJuIGFyci50b0Jhc2U2NCgpO1xuICB9XG4gIHJldHVybiBidG9hKGJ5dGVzVG9TdHJpbmcoYXJyKSk7XG59XG5mdW5jdGlvbiBmcm9tQmFzZTY0VXRpbChzdHIpIHtcbiAgaWYgKFVpbnQ4QXJyYXkuZnJvbUJhc2U2NCkge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb21CYXNlNjQoc3RyKTtcbiAgfVxuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhhdG9iKHN0cikpO1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9kaXNwbGF5X3V0aWxzLmpzXG5cbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIHR5cGUgPSBcInRleHRcIikge1xuICBpZiAoaXNWYWxpZEZldGNoVXJsKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBQYWdlVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdmlld0JveCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbixcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgIGNvbnN0IGNlbnRlclggPSAodmlld0JveFsyXSArIHZpZXdCb3hbMF0pIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKHZpZXdCb3hbM10gKyB2aWV3Qm94WzFdKSAvIDI7XG4gICAgbGV0IHJvdGF0ZUEsIHJvdGF0ZUIsIHJvdGF0ZUMsIHJvdGF0ZUQ7XG4gICAgcm90YXRpb24gJT0gMzYwO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uICs9IDM2MDtcbiAgICB9XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJvdGF0ZUEgPSAtMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAtMTtcbiAgICAgICAgcm90YXRlQyA9IC0xO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJvdGF0ZUEgPSAxO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG4gICAgaWYgKGRvbnRGbGlwKSB7XG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7XG4gICAgICByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuICAgIGxldCBvZmZzZXRDYW52YXNYLCBvZmZzZXRDYW52YXNZO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybSA9IFtyb3RhdGVBICogc2NhbGUsIHJvdGF0ZUIgKiBzY2FsZSwgcm90YXRlQyAqIHNjYWxlLCByb3RhdGVEICogc2NhbGUsIG9mZnNldENhbnZhc1ggLSByb3RhdGVBICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlQyAqIHNjYWxlICogY2VudGVyWSwgb2Zmc2V0Q2FudmFzWSAtIHJvdGF0ZUIgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVEICogc2NhbGUgKiBjZW50ZXJZXTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZ2V0IHJhd0RpbXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdmlld0JveFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJyYXdEaW1zXCIsIHtcbiAgICAgIHBhZ2VXaWR0aDogdmlld0JveFsyXSAtIHZpZXdCb3hbMF0sXG4gICAgICBwYWdlSGVpZ2h0OiB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSxcbiAgICAgIHBhZ2VYOiB2aWV3Qm94WzBdLFxuICAgICAgcGFnZVk6IHZpZXdCb3hbMV1cbiAgICB9KTtcbiAgfVxuICBjbG9uZSh7XG4gICAgc2NhbGUgPSB0aGlzLnNjYWxlLFxuICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgIG9mZnNldFkgPSB0aGlzLm9mZnNldFksXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIFV0aWwuYXBwbHlUcmFuc2Zvcm0oW3gsIHldLCB0aGlzLnRyYW5zZm9ybSk7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFsyXSwgcmVjdFszXV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gIH1cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxufVxuY2xhc3MgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZXh0cmFEZWxheSA9IDApIHtcbiAgICBzdXBlcihtc2csIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZXh0cmFEZWxheSA9IGV4dHJhRGVsYXk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChpIDwgaWkgJiYgdXJsW2ldLnRyaW0oKSA9PT0gXCJcIikge1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gdXJsLnN1YnN0cmluZyhpLCBpICsgNSkudG9Mb3dlckNhc2UoKSA9PT0gXCJkYXRhOlwiO1xufVxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwpIHtcbiAgW3VybF0gPSB1cmwuc3BsaXQoL1sjP10vLCAxKTtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xufVxuZnVuY3Rpb24gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKHVybCwgZGVmYXVsdEZpbGVuYW1lID0gXCJkb2N1bWVudC5wZGZcIikge1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgd2FybignZ2V0UGRmRmlsZW5hbWVGcm9tVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGNvbnN0IHJlVVJJID0gL14oPzooPzpbXjpdKzopP1xcL1xcL1teL10rKT8oW14/I10qKShcXD9bXiNdKik/KCMuKik/JC87XG4gIGNvbnN0IHJlRmlsZW5hbWUgPSAvW14vPyM9XStcXC5wZGZcXGIoPyEuKlxcLnBkZlxcYikvaTtcbiAgY29uc3Qgc3BsaXRVUkkgPSByZVVSSS5leGVjKHVybCk7XG4gIGxldCBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsxXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzJdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbM10pO1xuICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUpIHtcbiAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHN1Z2dlc3RlZEZpbGVuYW1lWzBdO1xuICAgIGlmIChzdWdnZXN0ZWRGaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKGRlY29kZVVSSUNvbXBvbmVudChzdWdnZXN0ZWRGaWxlbmFtZSkpWzBdO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3VnZ2VzdGVkRmlsZW5hbWUgfHwgZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgd2FybihgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICB3YXJuKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7XG4gICAgICBwcm90b2NvbFxuICAgIH0gPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIHJldHVybiBwcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgI3JlZ2V4O1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNyZWdleCB8fD0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHRoaXMuI3JlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgbGV0IG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgIG1vbnRoID0gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiA/IG1vbnRoIC0gMSA6IDA7XG4gICAgbGV0IGRheSA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKTtcbiAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgIGxldCBob3VyID0gcGFyc2VJbnQobWF0Y2hlc1s0XSwgMTApO1xuICAgIGhvdXIgPSBob3VyID49IDAgJiYgaG91ciA8PSAyMyA/IGhvdXIgOiAwO1xuICAgIGxldCBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgbWludXRlID0gbWludXRlID49IDAgJiYgbWludXRlIDw9IDU5ID8gbWludXRlIDogMDtcbiAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hlc1s2XSwgMTApO1xuICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgY29uc3QgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICBsZXQgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG1hdGNoZXNbOF0sIDEwKTtcbiAgICBvZmZzZXRIb3VyID0gb2Zmc2V0SG91ciA+PSAwICYmIG9mZnNldEhvdXIgPD0gMjMgPyBvZmZzZXRIb3VyIDogMDtcbiAgICBsZXQgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgb2Zmc2V0TWludXRlID0gb2Zmc2V0TWludXRlID49IDAgJiYgb2Zmc2V0TWludXRlIDw9IDU5ID8gb2Zmc2V0TWludXRlIDogMDtcbiAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgaG91ciArPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlICs9IG9mZnNldE1pbnV0ZTtcbiAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgIGhvdXIgLT0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSAtPSBvZmZzZXRNaW51dGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRYZmFQYWdlVmlld3BvcnQoeGZhUGFnZSwge1xuICBzY2FsZSA9IDEsXG4gIHJvdGF0aW9uID0gMFxufSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSB4ZmFQYWdlLmF0dHJpYnV0ZXMuc3R5bGU7XG4gIGNvbnN0IHZpZXdCb3ggPSBbMCwgMCwgcGFyc2VJbnQod2lkdGgpLCBwYXJzZUludChoZWlnaHQpXTtcbiAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgIHZpZXdCb3gsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb25cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSR0IoY29sb3IpIHtcbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgY29uc3QgY29sb3JSR0IgPSBwYXJzZUludChjb2xvci5zbGljZSgxKSwgMTYpO1xuICAgIHJldHVybiBbKGNvbG9yUkdCICYgMHhmZjAwMDApID4+IDE2LCAoY29sb3JSR0IgJiAweDAwZmYwMCkgPj4gOCwgY29sb3JSR0IgJiAweDAwMDBmZl07XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2IoXCIpKSB7XG4gICAgcmV0dXJuIGNvbG9yLnNsaWNlKDQsIC0xKS5zcGxpdChcIixcIikubWFwKHggPT4gcGFyc2VJbnQoeCkpO1xuICB9XG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSkuc2xpY2UoMCwgMyk7XG4gIH1cbiAgd2FybihgTm90IGEgdmFsaWQgY29sb3IgZm9ybWF0OiBcIiR7Y29sb3J9XCJgKTtcbiAgcmV0dXJuIFswLCAwLCAwXTtcbn1cbmZ1bmN0aW9uIGdldENvbG9yVmFsdWVzKGNvbG9ycykge1xuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIHNwYW4uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNwYW4pO1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgY29sb3JzLmtleXMoKSkge1xuICAgIHNwYW4uc3R5bGUuY29sb3IgPSBuYW1lO1xuICAgIGNvbnN0IGNvbXB1dGVkQ29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5jb2xvcjtcbiAgICBjb2xvcnMuc2V0KG5hbWUsIGdldFJHQihjb21wdXRlZENvbG9yKSk7XG4gIH1cbiAgc3Bhbi5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIHNldExheWVyRGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0LCBtdXN0RmxpcCA9IGZhbHNlLCBtdXN0Um90YXRlID0gdHJ1ZSkge1xuICBpZiAodmlld3BvcnQgaW5zdGFuY2VvZiBQYWdlVmlld3BvcnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGNvbnN0IHVzZVJvdW5kID0gdXRpbF9GZWF0dXJlVGVzdC5pc0NTU1JvdW5kU3VwcG9ydGVkO1xuICAgIGNvbnN0IHcgPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZVdpZHRofXB4YCxcbiAgICAgIGggPSBgdmFyKC0tc2NhbGUtZmFjdG9yKSAqICR7cGFnZUhlaWdodH1weGA7XG4gICAgY29uc3Qgd2lkdGhTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke3d9LCB2YXIoLS1zY2FsZS1yb3VuZC14LCAxcHgpKWAgOiBgY2FsYygke3d9KWAsXG4gICAgICBoZWlnaHRTdHIgPSB1c2VSb3VuZCA/IGByb3VuZChkb3duLCAke2h9LCB2YXIoLS1zY2FsZS1yb3VuZC15LCAxcHgpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICB0aGlzLnN4ID0gcGl4ZWxSYXRpbztcbiAgICB0aGlzLnN5ID0gcGl4ZWxSYXRpbztcbiAgfVxuICBnZXQgc2NhbGVkKCkge1xuICAgIHJldHVybiB0aGlzLnN4ICE9PSAxIHx8IHRoaXMuc3kgIT09IDE7XG4gIH1cbiAgZ2V0IHN5bW1ldHJpYygpIHtcbiAgICByZXR1cm4gdGhpcy5zeCA9PT0gdGhpcy5zeTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbGJhci5qc1xuXG5jbGFzcyBFZGl0b3JUb29sYmFyIHtcbiAgI3Rvb2xiYXIgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZWRpdG9yO1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgc3RhdGljICNsMTBuUmVtb3ZlID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmUgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1mcmVldGV4dC1idXR0b25cIixcbiAgICAgIGhpZ2hsaWdodDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWhpZ2hsaWdodC1idXR0b25cIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWluay1idXR0b25cIixcbiAgICAgIHN0YW1wOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc3RhbXAtYnV0dG9uXCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiZWRpdFRvb2xiYXJcIiwgXCJoaWRkZW5cIik7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIEVkaXRvclRvb2xiYXIuI3BvaW50ZXJEb3duLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLiNlZGl0b3IudG9vbGJhclBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGVkaXRUb29sYmFyO1xuICAgICAgY29uc3QgeCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLmRpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IDEgLSBwb3NpdGlvblswXSA6IHBvc2l0aW9uWzBdO1xuICAgICAgc3R5bGUuaW5zZXRJbmxpbmVFbmQgPSBgJHsxMDAgKiB4fSVgO1xuICAgICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiBwb3NpdGlvblsxXX0lICsgdmFyKC0tZWRpdG9yLXRvb2xiYXItdmVydC1vZmZzZXQpKWA7XG4gICAgfVxuICAgIHRoaXMuI2FkZERlbGV0ZUJ1dHRvbigpO1xuICAgIHJldHVybiBlZGl0VG9vbGJhcjtcbiAgfVxuICBnZXQgZGl2KCkge1xuICAgIHJldHVybiB0aGlzLiN0b29sYmFyO1xuICB9XG4gIHN0YXRpYyAjcG9pbnRlckRvd24oZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI2ZvY3VzSW4oZSkge1xuICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI2ZvY3VzT3V0KGUpIHtcbiAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI2FkZExpc3RlbmVyc1RvRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2ZvY3VzSW4uYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2ZvY3VzT3V0LmJpbmQodGhpcyksIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlcj8uaGlkZURyb3Bkb3duKCk7XG4gIH1cbiAgc2hvdygpIHtcbiAgICB0aGlzLiN0b29sYmFyLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jYWx0VGV4dD8uc2hvd24oKTtcbiAgfVxuICAjYWRkRGVsZXRlQnV0dG9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVkaXRvclR5cGUsXG4gICAgICBfdWlNYW5hZ2VyXG4gICAgfSA9IHRoaXMuI2VkaXRvcjtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImRlbGV0ZVwiO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IDA7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBFZGl0b3JUb29sYmFyLiNsMTBuUmVtb3ZlW2VkaXRvclR5cGVdKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGUgPT4ge1xuICAgICAgX3VpTWFuYWdlci5kZWxldGUoKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWw6IF91aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbik7XG4gIH1cbiAgZ2V0ICNkaXZpZGVyKCkge1xuICAgIGNvbnN0IGRpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdmlkZXIuY2xhc3NOYW1lID0gXCJkaXZpZGVyXCI7XG4gICAgcmV0dXJuIGRpdmlkZXI7XG4gIH1cbiAgYXN5bmMgYWRkQWx0VGV4dChhbHRUZXh0KSB7XG4gICAgY29uc3QgYnV0dG9uID0gYXdhaXQgYWx0VGV4dC5yZW5kZXIoKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLnByZXBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgfVxuICBhZGRDb2xvclBpY2tlcihjb2xvclBpY2tlcikge1xuICAgIHRoaXMuI2NvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gICAgY29uc3QgYnV0dG9uID0gY29sb3JQaWNrZXIucmVuZGVyQnV0dG9uKCk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5wcmVwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNjb2xvclBpY2tlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodFRvb2xiYXIge1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgY29uc3RydWN0b3IodWlNYW5hZ2VyKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICB9XG4gICNyZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc05hbWUgPSBcImVkaXRUb29sYmFyXCI7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBidXR0b25zID0gdGhpcy4jYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgYnV0dG9ucy5jbGFzc05hbWUgPSBcImJ1dHRvbnNcIjtcbiAgICBlZGl0VG9vbGJhci5hcHBlbmQoYnV0dG9ucyk7XG4gICAgdGhpcy4jYWRkSGlnaGxpZ2h0QnV0dG9uKCk7XG4gICAgcmV0dXJuIGVkaXRUb29sYmFyO1xuICB9XG4gICNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKSB7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgbGFzdFggPSAwO1xuICAgIGZvciAoY29uc3QgYm94IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgaWYgKHkgPCBsYXN0WSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBib3gueCArIChpc0xUUiA/IGJveC53aWR0aCA6IDApO1xuICAgICAgaWYgKHkgPiBsYXN0WSkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgaWYgKHggPiBsYXN0WCkge1xuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4IDwgbGFzdFgpIHtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2lzTFRSID8gMSAtIGxhc3RYIDogbGFzdFgsIGxhc3RZXTtcbiAgfVxuICBzaG93KHBhcmVudCwgYm94ZXMsIGlzTFRSKSB7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jZ2V0TGFzdFBvaW50KGJveGVzLCBpc0xUUik7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jdG9vbGJhciB8fD0gdGhpcy4jcmVuZGVyKCk7XG4gICAgcGFyZW50LmFwcGVuZCh0aGlzLiN0b29sYmFyKTtcbiAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiB5fSUgKyB2YXIoLS1lZGl0b3ItdG9vbGJhci12ZXJ0LW9mZnNldCkpYDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gIH1cbiAgI2FkZEhpZ2hsaWdodEJ1dHRvbigpIHtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImhpZ2hsaWdodEJ1dHRvblwiO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IDA7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBgcGRmanMtaGlnaGxpZ2h0LWZsb2F0aW5nLWJ1dHRvbjFgKTtcbiAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgYnV0dG9uLmFwcGVuZChzcGFuKTtcbiAgICBzcGFuLmNsYXNzTmFtZSA9IFwidmlzdWFsbHlIaWRkZW5cIjtcbiAgICBzcGFuLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24tbGFiZWxcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRTZWxlY3Rpb24oXCJmbG9hdGluZ19idXR0b25cIik7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbHMuanNcblxuXG5cbmZ1bmN0aW9uIGJpbmRFdmVudHMob2JqLCBlbGVtZW50LCBuYW1lcykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb2JqW25hbWVdLmJpbmQob2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9wYWNpdHlUb0hleChvcGFjaXR5KSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMSwgMjU1ICogb3BhY2l0eSkpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiBgJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fSR7dGhpcy4jaWQrK31gO1xuICB9XG59XG5jbGFzcyBJbWFnZU1hbmFnZXIge1xuICAjYmFzZUlkID0gZ2V0VXVpZCgpO1xuICAjaWQgPSAwO1xuICAjY2FjaGUgPSBudWxsO1xuICBzdGF0aWMgZ2V0IF9pc1NWR0ZpdHRpbmdDYW52YXMoKSB7XG4gICAgY29uc3Qgc3ZnID0gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PVVURi04LDxzdmcgdmlld0JveD1cIjAgMCAxIDFcIiB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiBzdHlsZT1cImZpbGw6cmVkO1wiLz48L3N2Zz5gO1xuICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMyk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLnNyYyA9IHN2ZztcbiAgICBjb25zdCBwcm9taXNlID0gaW1hZ2UuZGVjb2RlKCkudGhlbigoKSA9PiB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCAxLCAxLCAwLCAwLCAxLCAzKTtcbiAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhLmJ1ZmZlcilbMF0gPT09IDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSB8fD0ge1xuICAgICAgICBiaXRtYXA6IG51bGwsXG4gICAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgICByZWZDb3VudGVyOiAwLFxuICAgICAgICBpc1N2ZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodHlwZW9mIHJhd0RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS51cmwgPSByYXdEYXRhO1xuICAgICAgICBpbWFnZSA9IGF3YWl0IGZldGNoRGF0YShyYXdEYXRhLCBcImJsb2JcIik7XG4gICAgICB9IGVsc2UgaWYgKHJhd0RhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGltYWdlID0gZGF0YS5maWxlID0gcmF3RGF0YTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaW1hZ2UgPSByYXdEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIGNvbnN0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPSBJbWFnZU1hbmFnZXIuX2lzU1ZHRml0dGluZ0NhbnZhcztcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYml0bWFwID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5pc1N2ZyA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRhdGEuc3ZnVXJsID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gKGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UpID8gYCR7dXJsfSNzdmdWaWV3KHByZXNlcnZlQXNwZWN0UmF0aW8obm9uZSkpYCA6IHVybDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZmlsZVJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTtcbiAgICAgICAgYXdhaXQgaW1hZ2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgICB9XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgPSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH0gPSBmaWxlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoYCR7bGFzdE1vZGlmaWVkfV8ke25hbWV9XyR7c2l6ZX1fJHt0eXBlfWAsIGZpbGUpO1xuICB9XG4gIGFzeW5jIGdldEZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dldCh1cmwsIHVybCk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUJsb2IoaWQsIGJsb2JQcm9taXNlKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IGJsb2JQcm9taXNlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoaWQsIGJsb2IpO1xuICB9XG4gIGFzeW5jIGdldEZyb21JZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEuYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGcm9tRmlsZShkYXRhLmZpbGUpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5ibG9iUHJvbWlzZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9iUHJvbWlzZVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBkZWxldGUgZGF0YS5ibG9iUHJvbWlzZTtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21CbG9iKGRhdGEuaWQsIGJsb2JQcm9taXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnJvbVVybChkYXRhLnVybCk7XG4gIH1cbiAgZ2V0RnJvbUNhbnZhcyhpZCwgY2FudmFzKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKGRhdGE/LmJpdG1hcCkge1xuICAgICAgZGF0YS5yZWZDb3VudGVyICs9IDE7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDApO1xuICAgIGRhdGEgPSB7XG4gICAgICBiaXRtYXA6IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKSxcbiAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgcmVmQ291bnRlcjogMSxcbiAgICAgIGlzU3ZnOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy4jY2FjaGUuc2V0KGlkLCBkYXRhKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoZGF0YS5pZCwgZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0U3ZnVXJsKGlkKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhPy5pc1N2Zykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnN2Z1VybDtcbiAgfVxuICBkZWxldGVJZChpZCkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuI2NhY2hlLmdldChpZCk7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEucmVmQ291bnRlciAtPSAxO1xuICAgIGlmIChkYXRhLnJlZkNvdW50ZXIgIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYml0bWFwXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKCFkYXRhLnVybCAmJiAhZGF0YS5maWxlKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcImJpdG1hcHJlbmRlcmVyXCIpO1xuICAgICAgY3R4LnRyYW5zZmVyRnJvbUltYWdlQml0bWFwKGJpdG1hcCk7XG4gICAgICBkYXRhLmJsb2JQcm9taXNlID0gY2FudmFzLmNvbnZlcnRUb0Jsb2IoKTtcbiAgICB9XG4gICAgYml0bWFwLmNsb3NlPy4oKTtcbiAgICBkYXRhLmJpdG1hcCA9IG51bGw7XG4gIH1cbiAgaXNWYWxpZElkKGlkKSB7XG4gICAgcmV0dXJuIGlkLnN0YXJ0c1dpdGgoYGltYWdlXyR7dGhpcy4jYmFzZUlkfV9gKTtcbiAgfVxufVxuY2xhc3MgQ29tbWFuZE1hbmFnZXIge1xuICAjY29tbWFuZHMgPSBbXTtcbiAgI2xvY2tlZCA9IGZhbHNlO1xuICAjbWF4U2l6ZTtcbiAgI3Bvc2l0aW9uID0gLTE7XG4gIGNvbnN0cnVjdG9yKG1heFNpemUgPSAxMjgpIHtcbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuICBhZGQoe1xuICAgIGNtZCxcbiAgICB1bmRvLFxuICAgIHBvc3QsXG4gICAgbXVzdEV4ZWMsXG4gICAgdHlwZSA9IE5hTixcbiAgICBvdmVyd3JpdGVJZlNhbWVUeXBlID0gZmFsc2UsXG4gICAga2VlcFVuZG8gPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKG11c3RFeGVjKSB7XG4gICAgICBjbWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzYXZlID0ge1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIHBvc3QsXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy4jcG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG92ZXJ3cml0ZUlmU2FtZVR5cGUgJiYgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChrZWVwVW5kbykge1xuICAgICAgICBzYXZlLnVuZG8gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbztcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLiNwb3NpdGlvbiArIDE7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBuZXh0O1xuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHVuZG8sXG4gICAgICBwb3N0XG4gICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICB1bmRvKCk7XG4gICAgcG9zdD8uKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuICByZWRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uICs9IDE7XG4gICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbWQsXG4gICAgICAgIHBvc3RcbiAgICAgIH0gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl07XG4gICAgICBjbWQoKTtcbiAgICAgIHBvc3Q/LigpO1xuICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhhc1NvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gIT09IC0xO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWFuZHMgPSBudWxsO1xuICB9XG59XG5jbGFzcyBLZXlib2FyZE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFja3MpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYWxsS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGZvciAoY29uc3QgW2tleXMsIGNhbGxiYWNrLCBvcHRpb25zID0ge31dIG9mIGNhbGxiYWNrcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBpc01hY0tleSA9IGtleS5zdGFydHNXaXRoKFwibWFjK1wiKTtcbiAgICAgICAgaWYgKGlzTWFjICYmIGlzTWFjS2V5KSB7XG4gICAgICAgICAgdGhpcy5jYWxsYmFja3Muc2V0KGtleS5zbGljZSg0KSwge1xuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWFjICYmICFpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNzZXJpYWxpemUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiYWx0XCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuY3RybEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImN0cmxcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5tZXRhS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwibWV0YVwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwic2hpZnRcIik7XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyLnB1c2goZXZlbnQua2V5KTtcbiAgICBjb25zdCBzdHIgPSB0aGlzLmJ1ZmZlci5qb2luKFwiK1wiKTtcbiAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPSAwO1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgZXhlYyhzZWxmLCBldmVudCkge1xuICAgIGlmICghdGhpcy5hbGxLZXlzLmhhcyhldmVudC5rZXkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSB0aGlzLmNhbGxiYWNrcy5nZXQodGhpcy4jc2VyaWFsaXplKGV2ZW50KSk7XG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBidWJibGVzID0gZmFsc2UsXG4gICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgY2hlY2tlciA9IG51bGxcbiAgICAgIH1cbiAgICB9ID0gaW5mbztcbiAgICBpZiAoY2hlY2tlciAmJiAhY2hlY2tlcihzZWxmLCBldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2suYmluZChzZWxmLCAuLi5hcmdzLCBldmVudCkoKTtcbiAgICBpZiAoIWJ1YmJsZXMpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIENvbG9yTWFuYWdlciB7XG4gIHN0YXRpYyBfY29sb3JzTWFwcGluZyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgWzAsIDAsIDBdXSwgW1wiQ2FudmFzXCIsIFsyNTUsIDI1NSwgMjU1XV1dKTtcbiAgZ2V0IF9jb2xvcnMoKSB7XG4gICAgY29uc3QgY29sb3JzID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBudWxsXSwgW1wiQ2FudmFzXCIsIG51bGxdXSk7XG4gICAgZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG4gIGNvbnZlcnQoY29sb3IpIHtcbiAgICBjb25zdCByZ2IgPSBnZXRSR0IoY29sb3IpO1xuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEoXCIoZm9yY2VkLWNvbG9yczogYWN0aXZlKVwiKS5tYXRjaGVzKSB7XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBSR0JdIG9mIHRoaXMuX2NvbG9ycykge1xuICAgICAgaWYgKFJHQi5ldmVyeSgoeCwgaSkgPT4geCA9PT0gcmdiW2ldKSkge1xuICAgICAgICByZXR1cm4gQ29sb3JNYW5hZ2VyLl9jb2xvcnNNYXBwaW5nLmdldChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJnYjtcbiAgfVxuICBnZXRIZXhDb2RlKG5hbWUpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9jb2xvcnMuZ2V0KG5hbWUpO1xuICAgIGlmICghcmdiKSB7XG4gICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIFV0aWwubWFrZUhleENvbG9yKC4uLnJnYik7XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNhbGxMYXllcnMgPSBuZXcgTWFwKCk7XG4gICNhbHRUZXh0TWFuYWdlciA9IG51bGw7XG4gICNhbm5vdGF0aW9uU3RvcmFnZSA9IG51bGw7XG4gICNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyA9IG51bGw7XG4gICNjb21tYW5kTWFuYWdlciA9IG5ldyBDb21tYW5kTWFuYWdlcigpO1xuICAjY29weVBhc3RlQUMgPSBudWxsO1xuICAjY3VycmVudFBhZ2VJbmRleCA9IDA7XG4gICNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAjZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2VkaXRvcnNUb1Jlc2NhbGUgPSBuZXcgU2V0KCk7XG4gICNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGZhbHNlO1xuICAjZW5hYmxlVXBkYXRlZEFkZEltYWdlID0gZmFsc2U7XG4gICNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZmFsc2U7XG4gICNmaWx0ZXJGYWN0b3J5ID0gbnVsbDtcbiAgI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gICNoaWdobGlnaHRDb2xvcnMgPSBudWxsO1xuICAjaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSBmYWxzZTtcbiAgI2hpZ2hsaWdodFRvb2xiYXIgPSBudWxsO1xuICAjaWRNYW5hZ2VyID0gbmV3IElkTWFuYWdlcigpO1xuICAjaXNFbmFibGVkID0gZmFsc2U7XG4gICNpc1dhaXRpbmcgPSBmYWxzZTtcbiAgI2tleWJvYXJkTWFuYWdlckFDID0gbnVsbDtcbiAgI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IG51bGw7XG4gICNtbE1hbmFnZXIgPSBudWxsO1xuICAjbW9kZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICNzZWxlY3RlZEVkaXRvcnMgPSBuZXcgU2V0KCk7XG4gICNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgI3BhZ2VDb2xvcnMgPSBudWxsO1xuICAjc2hvd0FsbFN0YXRlcyA9IG51bGw7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gIH07XG4gICN0cmFuc2xhdGlvbiA9IFswLCAwXTtcbiAgI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICN2aWV3ZXIgPSBudWxsO1xuICAjdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICBzdGF0aWMgVFJBTlNMQVRFX1NNQUxMID0gMTtcbiAgc3RhdGljIFRSQU5TTEFURV9CSUcgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lICE9PSBcIkJVVFRPTlwiICYmIHNlbGYuaGFzU29tZXRoaW5nVG9Db250cm9sKCk7XG4gICAgY29uc3QgdGV4dElucHV0Q2hlY2tlciA9IChfc2VsZiwge1xuICAgICAgdGFyZ2V0OiBlbFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSA9IGVsO1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gXCJ0ZXh0XCIgJiYgdHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgc21hbGwgPSB0aGlzLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSB0aGlzLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrYVwiLCBcIm1hYyttZXRhK2FcIl0sIHByb3RvLnNlbGVjdEFsbCwge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt6XCIsIFwibWFjK21ldGErelwiXSwgcHJvdG8udW5kbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt5XCIsIFwiY3RybCtzaGlmdCt6XCIsIFwibWFjK21ldGErc2hpZnQrelwiLCBcImN0cmwrc2hpZnQrWlwiLCBcIm1hYyttZXRhK3NoaWZ0K1pcIl0sIHByb3RvLnJlZG8sIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkJhY2tzcGFjZVwiLCBcImFsdCtCYWNrc3BhY2VcIiwgXCJjdHJsK0JhY2tzcGFjZVwiLCBcInNoaWZ0K0JhY2tzcGFjZVwiLCBcIm1hYytCYWNrc3BhY2VcIiwgXCJtYWMrYWx0K0JhY2tzcGFjZVwiLCBcIm1hYytjdHJsK0JhY2tzcGFjZVwiLCBcIkRlbGV0ZVwiLCBcImN0cmwrRGVsZXRlXCIsIFwic2hpZnQrRGVsZXRlXCIsIFwibWFjK0RlbGV0ZVwiXSwgcHJvdG8uZGVsZXRlLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJFbnRlclwiLCBcIm1hYytFbnRlclwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhlbCkgJiYgIXNlbGYuaXNFbnRlckhhbmRsZWRcbiAgICB9XSwgW1tcIiBcIiwgXCJtYWMrIFwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8udW5zZWxlY3RBbGxdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHZpZXdlciwgYWx0VGV4dE1hbmFnZXIsIGV2ZW50QnVzLCBwZGZEb2N1bWVudCwgcGFnZUNvbG9ycywgaGlnaGxpZ2h0Q29sb3JzLCBlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiwgZW5hYmxlVXBkYXRlZEFkZEltYWdlLCBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlLCBtbE1hbmFnZXIpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWwgPSB0aGlzLiNhYm9ydENvbnRyb2xsZXIuc2lnbmFsO1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN2aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXIgPSBhbHRUZXh0TWFuYWdlcjtcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIGV2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMub25QYWdlQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2NhbGVjaGFuZ2luZ1wiLCB0aGlzLm9uU2NhbGVDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMub25Sb3RhdGlvbkNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInNldHByZWZlcmVuY2VcIiwgdGhpcy5vblNldFByZWZlcmVuY2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcnBhcmFtc1wiLCBldnQgPT4gdGhpcy51cGRhdGVQYXJhbXMoZXZ0LnR5cGUsIGV2dC52YWx1ZSksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCk7XG4gICAgdGhpcy4jYWRkRHJhZ0FuZERyb3BMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSA9IHBkZkRvY3VtZW50LmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuI2ZpbHRlckZhY3RvcnkgPSBwZGZEb2N1bWVudC5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuI3BhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMuI2hpZ2hsaWdodENvbG9ycyA9IGhpZ2hsaWdodENvbG9ycyB8fCBudWxsO1xuICAgIHRoaXMuI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uID0gZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b247XG4gICAgdGhpcy4jZW5hYmxlVXBkYXRlZEFkZEltYWdlID0gZW5hYmxlVXBkYXRlZEFkZEltYWdlO1xuICAgIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgPSBlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlO1xuICAgIHRoaXMuI21sTWFuYWdlciA9IG1sTWFuYWdlciB8fCBudWxsO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMgPSB7XG4gICAgICByZWFsU2NhbGU6IFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyxcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eT8ucmVzb2x2ZSgpO1xuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLiNhYm9ydENvbnRyb2xsZXI/LmFib3J0KCk7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLl9zaWduYWwgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuI2FsbExheWVycy5jbGVhcigpO1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmNsZWFyKCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXI/LmRlc3Ryb3koKTtcbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhciA9IG51bGw7XG4gICAgaWYgKHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICB9XG4gIGNvbWJpbmVkU2lnbmFsKGFjKSB7XG4gICAgcmV0dXJuIEFib3J0U2lnbmFsLmFueShbdGhpcy5fc2lnbmFsLCBhYy5zaWduYWxdKTtcbiAgfVxuICBnZXQgbWxNYW5hZ2VyKCkge1xuICAgIHJldHVybiB0aGlzLiNtbE1hbmFnZXI7XG4gIH1cbiAgZ2V0IHVzZU5ld0FsdFRleHRGbG93KCkge1xuICAgIHJldHVybiB0aGlzLiNlbmFibGVVcGRhdGVkQWRkSW1hZ2U7XG4gIH1cbiAgZ2V0IHVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2U7XG4gIH1cbiAgZ2V0IGhjbUZpbHRlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGNtRmlsdGVyXCIsIHRoaXMuI3BhZ2VDb2xvcnMgPyB0aGlzLiNmaWx0ZXJGYWN0b3J5LmFkZEhDTUZpbHRlcih0aGlzLiNwYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMuI3BhZ2VDb2xvcnMuYmFja2dyb3VuZCkgOiBcIm5vbmVcIik7XG4gIH1cbiAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiZGlyZWN0aW9uXCIsIGdldENvbXB1dGVkU3R5bGUodGhpcy4jY29udGFpbmVyKS5kaXJlY3Rpb24pO1xuICB9XG4gIGdldCBoaWdobGlnaHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yc1wiLCB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKHRoaXMuI2hpZ2hsaWdodENvbG9ycy5zcGxpdChcIixcIikubWFwKHBhaXIgPT4gcGFpci5zcGxpdChcIj1cIikubWFwKHggPT4geC50cmltKCkpKSkgOiBudWxsKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JOYW1lcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaGlnaGxpZ2h0Q29sb3JOYW1lc1wiLCB0aGlzLmhpZ2hsaWdodENvbG9ycyA/IG5ldyBNYXAoQXJyYXkuZnJvbSh0aGlzLmhpZ2hsaWdodENvbG9ycywgZSA9PiBlLnJldmVyc2UoKSkpIDogbnVsbCk7XG4gIH1cbiAgc2V0TWFpbkhpZ2hsaWdodENvbG9yUGlja2VyKGNvbG9yUGlja2VyKSB7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gY29sb3JQaWNrZXI7XG4gIH1cbiAgZWRpdEFsdFRleHQoZWRpdG9yLCBmaXJzdFRpbWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyPy5lZGl0QWx0VGV4dCh0aGlzLCBlZGl0b3IsIGZpcnN0VGltZSk7XG4gIH1cbiAgc3dpdGNoVG9Nb2RlKG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMub24oXCJhbm5vdGF0aW9uZWRpdG9ybW9kZWNoYW5nZWRcIiwgY2FsbGJhY2ssIHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2hvd2Fubm90YXRpb25lZGl0b3J1aVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJlZmVyZW5jZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic2V0cHJlZmVyZW5jZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBuYW1lLFxuICAgICAgdmFsdWVcbiAgICB9KTtcbiAgfVxuICBvblNldFByZWZlcmVuY2Uoe1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcImVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2VcIjpcbiAgICAgICAgdGhpcy4jZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb25QYWdlQ2hhbmdpbmcoe1xuICAgIHBhZ2VOdW1iZXJcbiAgfSkge1xuICAgIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMTtcbiAgfVxuICBmb2N1c01haW5Db250YWluZXIoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cbiAgZmluZFBhcmVudCh4LCB5KSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbGF5ZXJYLFxuICAgICAgICB5OiBsYXllclksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBsYXllci5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeCA+PSBsYXllclggJiYgeCA8PSBsYXllclggKyB3aWR0aCAmJiB5ID49IGxheWVyWSAmJiB5IDw9IGxheWVyWSArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRpc2FibGVVc2VyU2VsZWN0KHZhbHVlID0gZmFsc2UpIHtcbiAgICB0aGlzLiN2aWV3ZXIuY2xhc3NMaXN0LnRvZ2dsZShcIm5vVXNlclNlbGVjdFwiLCB2YWx1ZSk7XG4gIH1cbiAgYWRkU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmFkZChlZGl0b3IpO1xuICB9XG4gIHJlbW92ZVNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5kZWxldGUoZWRpdG9yKTtcbiAgfVxuICBvblNjYWxlQ2hhbmdpbmcoe1xuICAgIHNjYWxlXG4gIH0pIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGUgPSBzY2FsZSAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUztcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlKSB7XG4gICAgICBlZGl0b3Iub25TY2FsZUNoYW5naW5nKCk7XG4gICAgfVxuICB9XG4gIG9uUm90YXRpb25DaGFuZ2luZyh7XG4gICAgcGFnZXNSb3RhdGlvblxuICB9KSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucm90YXRpb24gPSBwYWdlc1JvdGF0aW9uO1xuICB9XG4gICNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHtcbiAgICBhbmNob3JOb2RlXG4gIH0pIHtcbiAgICByZXR1cm4gYW5jaG9yTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBhbmNob3JOb2RlLnBhcmVudEVsZW1lbnQgOiBhbmNob3JOb2RlO1xuICB9XG4gICNnZXRMYXllckZvclRleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50TGF5ZXJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoY3VycmVudExheWVyLmhhc1RleHRMYXllcih0ZXh0TGF5ZXIpKSB7XG4gICAgICByZXR1cm4gY3VycmVudExheWVyO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGxheWVyLmhhc1RleHRMYXllcih0ZXh0TGF5ZXIpKSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24gPSBcIlwiKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldFxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKTtcbiAgICBpZiAoIWJveGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKTtcbiAgICBjb25zdCBpc05vbmVNb2RlID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGxheWVyPy5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBtZXRob2RPZkNyZWF0aW9uLFxuICAgICAgICBib3hlcyxcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgIGZvY3VzT2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgdGhpcy5zd2l0Y2hUb01vZGUoQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgI2Rpc3BsYXlIaWdobGlnaHRUb29sYmFyKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyIHx8PSBuZXcgSGlnaGxpZ2h0VG9vbGJhcih0aGlzKTtcbiAgICB0aGlzLiNoaWdobGlnaHRUb29sYmFyLnNob3codGV4dExheWVyLCBib3hlcywgdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICAjc2VsZWN0aW9uQ2hhbmdlKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGVcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGlmIChhbmNob3JOb2RlID09PSB0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBpZiAoIXRleHRMYXllcikge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jaGlnaGxpZ2h0VG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFRvb2xiYXI/LmhpZGUoKTtcbiAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gYW5jaG9yTm9kZTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZFRleHQ6IHRydWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUICYmIHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCkge1xuICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXAgPSB0aGlzLmlzU2hpZnRLZXlEb3duO1xuICAgIGlmICghdGhpcy5pc1NoaWZ0S2V5RG93bikge1xuICAgICAgY29uc3QgYWN0aXZlTGF5ZXIgPSB0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgPyB0aGlzLiNnZXRMYXllckZvclRleHRMYXllcih0ZXh0TGF5ZXIpIDogbnVsbDtcbiAgICAgIGFjdGl2ZUxheWVyPy50b2dnbGVEcmF3aW5nKCk7XG4gICAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwoYWMpO1xuICAgICAgY29uc3QgcG9pbnRlcnVwID0gZSA9PiB7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwicG9pbnRlcnVwXCIgJiYgZS5idXR0b24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwicG9pbnRlcnVwXCIpIHtcbiAgICAgICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjb25TZWxlY3RFbmQobWV0aG9kT2ZDcmVhdGlvbiA9IFwiXCIpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuI2VuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uKSB7XG4gICAgICB0aGlzLiNkaXNwbGF5SGlnaGxpZ2h0VG9vbGJhcigpO1xuICAgIH1cbiAgfVxuICAjYWRkU2VsZWN0aW9uTGlzdGVuZXIoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLiNzZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgfVxuICAjYWRkRm9jdXNNYW5hZ2VyKCkge1xuICAgIGlmICh0aGlzLiNmb2N1c01hbmFnZXJBQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzTWFuYWdlckFDKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZm9jdXMuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuYmx1ci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlRm9jdXNNYW5hZ2VyKCkge1xuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2ZvY3VzTWFuYWdlckFDID0gbnVsbDtcbiAgfVxuICBibHVyKCkge1xuICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy4jaGlnaGxpZ2h0V2hlblNoaWZ0VXApIHtcbiAgICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBbZWRpdG9yLCBhY3RpdmVFbGVtZW50XTtcbiAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvY3VzKCkge1xuICAgIGlmICghdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2xhc3RFZGl0b3IsIGxhc3RBY3RpdmVFbGVtZW50XSA9IHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50O1xuICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICBsYXN0RWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWUsXG4gICAgICBzaWduYWw6IHRoaXMuX3NpZ25hbFxuICAgIH0pO1xuICAgIGxhc3RBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gIH1cbiAgI2FkZEtleWJvYXJkTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIHRoaXMua2V5dXAuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpIHtcbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNrZXlib2FyZE1hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICBpZiAodGhpcy4jY29weVBhc3RlQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNjb3B5UGFzdGVBQyk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy5jb3B5LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgdGhpcy5jdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMucGFzdGUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLiNjb3B5UGFzdGVBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjb3B5UGFzdGVBQyA9IG51bGw7XG4gIH1cbiAgI2FkZERyYWdBbmREcm9wTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3NpZ25hbDtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJhZ292ZXJcIiwgdGhpcy5kcmFnT3Zlci5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZHJvcFwiLCB0aGlzLmRyb3AuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgYWRkRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLiNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgfVxuICByZW1vdmVFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIGRyYWdPdmVyKGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSBvZiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcodHlwZSkpIHtcbiAgICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IFwiY29weVwiO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyb3AoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXZlbnQuZGF0YVRyYW5zZmVyLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb3B5KGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3JzID0gW107XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gZWRpdG9yLnNlcmlhbGl6ZSh0cnVlKTtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChzZXJpYWxpemVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LmNsaXBib2FyZERhdGEuc2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIsIEpTT04uc3RyaW5naWZ5KGVkaXRvcnMpKTtcbiAgfVxuICBjdXQoZXZlbnQpIHtcbiAgICB0aGlzLmNvcHkoZXZlbnQpO1xuICAgIHRoaXMuZGVsZXRlKCk7XG4gIH1cbiAgYXN5bmMgcGFzdGUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsaXBib2FyZERhdGFcbiAgICB9ID0gZXZlbnQ7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNsaXBib2FyZERhdGEuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGF0YSA9IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcImFwcGxpY2F0aW9uL3BkZmpzXCIpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHdhcm4oYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudExheWVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3JzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVkaXRvciA9IGF3YWl0IGxheWVyLmRlc2VyaWFsaXplKGVkaXRvcik7XG4gICAgICAgIGlmICghZGVzZXJpYWxpemVkRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld0VkaXRvcnMucHVzaChkZXNlcmlhbGl6ZWRFZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3NlbGVjdEVkaXRvcnMobmV3RWRpdG9ycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQsXG4gICAgICAgIHVuZG8sXG4gICAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgIH1cbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzU2hpZnRLZXlEb3duICYmIGV2ZW50LmtleSA9PT0gXCJTaGlmdFwiKSB7XG4gICAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUgJiYgIXRoaXMuaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG4gIGtleXVwKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaXNTaGlmdEtleURvd24gJiYgZXZlbnQua2V5ID09PSBcIlNoaWZ0XCIpIHtcbiAgICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCkge1xuICAgICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLiNvblNlbGVjdEVuZChcIm1haW5fdG9vbGJhclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25FZGl0aW5nQWN0aW9uKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ1bmRvXCI6XG4gICAgICBjYXNlIFwicmVkb1wiOlxuICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgY2FzZSBcInNlbGVjdEFsbFwiOlxuICAgICAgICB0aGlzW25hbWVdKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhpZ2hsaWdodFNlbGVjdGlvblwiOlxuICAgICAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbihcImNvbnRleHRfbWVudVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy4jcHJldmlvdXNTdGF0ZXNba2V5XSAhPT0gdmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUICYmIGRldGFpbHMuaGFzU2VsZWN0ZWRFZGl0b3IgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdHJ1ZV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlVUkoZGV0YWlscykge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnBhcmFtc2NoYW5nZWRcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNhZGRGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIGlmICh0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3JUeXBlcyA9IHR5cGVzO1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmlkO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQodGhpcy4jY3VycmVudFBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0TGF5ZXIocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgfVxuICBnZXQgY3VycmVudFBhZ2VJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFBhZ2VJbmRleDtcbiAgfVxuICBhZGRMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5zZXQobGF5ZXIucGFnZUluZGV4LCBsYXllcik7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuZGVsZXRlKGxheWVyLnBhZ2VJbmRleCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTW9kZShtb2RlLCBlZGl0SWQgPSBudWxsLCBpc0Zyb21LZXlib2FyZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5KSB7XG4gICAgICBhd2FpdCB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgaWYgKCF0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jbW9kZSA9IG1vZGU7XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICAgIHRoaXMuI2Rpc2FibGVBbGwoKTtcbiAgICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgYXdhaXQgdGhpcy4jZW5hYmxlQWxsKCk7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIH1cbiAgICBpZiAoIWVkaXRJZCkge1xuICAgICAgaWYgKGlzRnJvbUtleWJvYXJkKSB7XG4gICAgICAgIHRoaXMuYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gZWRpdElkKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLmVudGVySW5FZGl0TW9kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudExheWVyLmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkpIHtcbiAgICAgIHRoaXMuY3VycmVudExheWVyLmFkZE5ld0VkaXRvcigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUb29sYmFyKG1vZGUpIHtcbiAgICBpZiAobW9kZSA9PT0gdGhpcy4jbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5DUkVBVEU6XG4gICAgICAgIHRoaXMuY3VycmVudExheWVyLmFkZE5ld0VkaXRvcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SOlxuICAgICAgICB0aGlzLiNtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXI/LnVwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTDpcbiAgICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgICAgICAgICAgYWN0aW9uOiBcInRvZ2dsZV92aXNpYmlsaXR5XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAodGhpcy4jc2hvd0FsbFN0YXRlcyB8fD0gbmV3IE1hcCgpKS5zZXQodHlwZSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNob3dBbGxFZGl0b3JzKFwiaGlnaGxpZ2h0XCIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc2hvd0FsbEVkaXRvcnModHlwZSwgdmlzaWJsZSwgdXBkYXRlQnV0dG9uID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmVkaXRvclR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgZWRpdG9yLnNob3codmlzaWJsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy4jc2hvd0FsbFN0YXRlcz8uZ2V0KEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9TSE9XX0FMTCkgPz8gdHJ1ZTtcbiAgICBpZiAoc3RhdGUgIT09IHZpc2libGUpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwsIHZpc2libGVdXSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcobXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNpc1dhaXRpbmcgPT09IG11c3RXYWl0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2lzV2FpdGluZyA9IG11c3RXYWl0O1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBpZiAobXVzdFdhaXQpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZUNsaWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXllci5lbmFibGVDbGljaygpO1xuICAgICAgfVxuICAgICAgbGF5ZXIuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJ3YWl0aW5nXCIsIG11c3RXYWl0KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2VuYWJsZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBwcm9taXNlcy5wdXNoKGxheWVyLmVuYWJsZSgpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLmVuYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgdGhpcy4jaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5kaXNhYmxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEVkaXRvcnMocGFnZUluZGV4KSB7XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IucGFnZUluZGV4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKGVkaXRvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3JzO1xuICB9XG4gIGdldEVkaXRvcihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxFZGl0b3JzLmdldChpZCk7XG4gIH1cbiAgYWRkRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgfVxuICByZW1vdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5mb2N1c01haW5Db250YWluZXIoKTtcbiAgICAgICAgdGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkID0gbnVsbDtcbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICB0aGlzLiNhbGxFZGl0b3JzLmRlbGV0ZShlZGl0b3IuaWQpO1xuICAgIHRoaXMudW5zZWxlY3QoZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlPy5yZW1vdmUoZWRpdG9yLmlkKTtcbiAgICB9XG4gIH1cbiAgYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB0aGlzLmFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgfVxuICByZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIHRoaXMucmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgIGVkaXRvci5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KGVkaXRvci5wYWdlSW5kZXgpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0ICNsYXN0U2VsZWN0ZWRFZGl0b3IoKSB7XG4gICAgbGV0IGVkID0gbnVsbDtcbiAgICBmb3IgKGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge31cbiAgICByZXR1cm4gZWQ7XG4gIH1cbiAgdXBkYXRlVUkoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2xhc3RTZWxlY3RlZEVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpKSB7XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgZm9yIChjb25zdCBlZCBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZCAhPT0gZWRpdG9yKSB7XG4gICAgICAgIGVkLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKTtcbiAgfVxuICBnZXQgZmlyc3RTZWxlY3RlZEVkaXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgfVxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSA9PT0gMSAmJiB0aGlzLmZpcnN0U2VsZWN0ZWRFZGl0b3IuaXNFbnRlckhhbmRsZWQ7XG4gIH1cbiAgdW5kbygpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci51bmRvKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdHJ1ZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIucmVkbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5hZGQocGFyYW1zKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgI2lzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5pc0VtcHR5KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWxldGUoKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9Db250cm9sKCkge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgfHwgdGhpcy5oYXNTZWxlY3Rpb247XG4gIH1cbiAgI3NlbGVjdEVkaXRvcnMoZWRpdG9ycykge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBzZWxlY3RBbGwoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdEVkaXRvcnModGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSk7XG4gIH1cbiAgdW5zZWxlY3RBbGwoKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvcikge1xuICAgICAgdGhpcy4jYWN0aXZlRWRpdG9yLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIG5vQ29tbWl0ID0gZmFsc2UpIHtcbiAgICBpZiAoIW5vQ29tbWl0KSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25bMF0gKz0geDtcbiAgICB0aGlzLiN0cmFuc2xhdGlvblsxXSArPSB5O1xuICAgIGNvbnN0IFt0b3RhbFgsIHRvdGFsWV0gPSB0aGlzLiN0cmFuc2xhdGlvbjtcbiAgICBjb25zdCBlZGl0b3JzID0gWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgVElNRV9UT19XQUlUID0gMTAwMDtcbiAgICBpZiAodGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiN0cmFuc2xhdGlvblswXSA9IHRoaXMuI3RyYW5zbGF0aW9uWzFdID0gMDtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKHRvdGFsWCwgdG90YWxZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRlSW5QYWdlKC10b3RhbFgsIC10b3RhbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoeCwgeSk7XG4gICAgfVxuICB9XG4gIHNldFVwRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5zZXQoZWRpdG9yLCB7XG4gICAgICAgIHNhdmVkWDogZWRpdG9yLngsXG4gICAgICAgIHNhdmVkWTogZWRpdG9yLnksXG4gICAgICAgIHNhdmVkUGFnZUluZGV4OiBlZGl0b3IucGFnZUluZGV4LFxuICAgICAgICBuZXdYOiAwLFxuICAgICAgICBuZXdZOiAwLFxuICAgICAgICBuZXdQYWdlSW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgY29uc3QgbWFwID0gdGhpcy4jZHJhZ2dpbmdFZGl0b3JzO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICAgbGV0IG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFt7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0sIHZhbHVlXSBvZiBtYXApIHtcbiAgICAgIHZhbHVlLm5ld1ggPSB4O1xuICAgICAgdmFsdWUubmV3WSA9IHk7XG4gICAgICB2YWx1ZS5uZXdQYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICBtdXN0QmVBZGRlZEluVW5kb1N0YWNrIHx8PSB4ICE9PSB2YWx1ZS5zYXZlZFggfHwgeSAhPT0gdmFsdWUuc2F2ZWRZIHx8IHBhZ2VJbmRleCAhPT0gdmFsdWUuc2F2ZWRQYWdlSW5kZXg7XG4gICAgfVxuICAgIGlmICghbXVzdEJlQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb3ZlID0gKGVkaXRvciwgeCwgeSwgcGFnZUluZGV4KSA9PiB7XG4gICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBlZGl0b3IuX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgICAgICBlZGl0b3IueCA9IHg7XG4gICAgICAgICAgZWRpdG9yLnkgPSB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBuZXdYLFxuICAgICAgICAgIG5ld1ksXG4gICAgICAgICAgbmV3UGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBuZXdYLCBuZXdZLCBuZXdQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBzYXZlZFgsXG4gICAgICAgICAgc2F2ZWRZLFxuICAgICAgICAgIHNhdmVkUGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5rZXlzKCkpIHtcbiAgICAgIGVkaXRvci5kcmFnKHR4LCB0eSk7XG4gICAgfVxuICB9XG4gIHJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0TGF5ZXIoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICAgICAgcGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5wYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGdldCBpc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlKCk/LnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkgfHwgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgPT09IDEgJiYgdGhpcy5maXJzdFNlbGVjdGVkRWRpdG9yLnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCk7XG4gIH1cbiAgaXNBY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yO1xuICB9XG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gIH1cbiAgZ2V0IGltYWdlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaW1hZ2VNYW5hZ2VyXCIsIG5ldyBJbWFnZU1hbmFnZXIoKSk7XG4gIH1cbiAgZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKSB7XG4gICAgaWYgKCF0ZXh0TGF5ZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzZWxlY3Rpb24ucmFuZ2VDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmICghdGV4dExheWVyLmNvbnRhaW5zKHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeDogbGF5ZXJYLFxuICAgICAgeTogbGF5ZXJZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gdGV4dExheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCByb3RhdG9yO1xuICAgIHN3aXRjaCAodGV4dExheWVyLmdldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiKSkge1xuICAgICAgY2FzZSBcIjkwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgeTogMSAtICh4ICsgdyAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB3aWR0aDogaCAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHcgLyBwYXJlbnRXaWR0aFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiMTgwXCI6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAxIC0gKHggKyB3IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3IC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoIC8gcGFyZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIyNzBcIjpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6IDEgLSAoeSArIGggLSBsYXllclkpIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIHk6ICh4IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJvdGF0b3IgPSAoeCwgeSwgdywgaCkgPT4gKHtcbiAgICAgICAgICB4OiAoeCAtIGxheWVyWCkgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICB5OiAoeSAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHcgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGggLyBwYXJlbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBib3hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTtcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSBvZiByYW5nZS5nZXRDbGllbnRSZWN0cygpKSB7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBib3hlcy5wdXNoKHJvdGF0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm94ZXMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJveGVzO1xuICB9XG4gIGFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWQsXG4gICAgaWRcbiAgfSkge1xuICAgICh0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyB8fD0gbmV3IE1hcCgpKS5zZXQoYW5ub3RhdGlvbkVsZW1lbnRJZCwgaWQpO1xuICB9XG4gIHJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oe1xuICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgfSkge1xuICAgIHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zPy5kZWxldGUoYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGVkaXRvcklkID0gdGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnM/LmdldChhbm5vdGF0aW9uLmRhdGEuaWQpO1xuICAgIGlmICghZWRpdG9ySWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUoZWRpdG9ySWQpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FICYmICFlZGl0b3IuaGFzQmVlbk1vZGlmaWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvYWx0X3RleHQuanNcblxuY2xhc3MgQWx0VGV4dCB7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2FsdFRleHREZWNvcmF0aXZlID0gZmFsc2U7XG4gICNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAjYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjYmFkZ2UgPSBudWxsO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI2d1ZXNzZWRUZXh0ID0gbnVsbDtcbiAgI3RleHRXaXRoRGlzY2xhaW1lciA9IG51bGw7XG4gICN1c2VOZXdBbHRUZXh0RmxvdyA9IGZhbHNlO1xuICBzdGF0aWMgI2wxMG5OZXdCdXR0b24gPSBudWxsO1xuICBzdGF0aWMgX2wxMG4gPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgPSBlZGl0b3IuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdztcbiAgICBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGFkZGVkOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uXCIsXG4gICAgICBcImFkZGVkLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1hZGRlZC1idXR0b24tbGFiZWxcIixcbiAgICAgIG1pc3Npbmc6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvblwiLFxuICAgICAgXCJtaXNzaW5nLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvbi1sYWJlbFwiLFxuICAgICAgcmV2aWV3OiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtdG8tcmV2aWV3LWJ1dHRvblwiLFxuICAgICAgXCJyZXZpZXctbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b24tbGFiZWxcIlxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBBbHRUZXh0Ll9sMTBuID8/PSBsMTBuO1xuICB9XG4gIGFzeW5jIHJlbmRlcigpIHtcbiAgICBjb25zdCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYWx0VGV4dC5jbGFzc05hbWUgPSBcImFsdFRleHRcIjtcbiAgICBhbHRUZXh0LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBhbHRUZXh0LmFwcGVuZChsYWJlbCk7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBhbHRUZXh0LmNsYXNzTGlzdC5hZGQoXCJuZXdcIik7XG4gICAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uLm1pc3NpbmcpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bXCJtaXNzaW5nLWxhYmVsXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uXCIpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvbi1sYWJlbFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgb25DbGljayA9IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLiNlZGl0b3IpO1xuICAgICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuYWx0X3RleHQuaW1hZ2Vfc3RhdHVzX2xhYmVsX2NsaWNrZWRcIixcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBsYWJlbDogdGhpcy4jbGFiZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYWx0VGV4dCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gdHJ1ZTtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy4jc2V0U3RhdGUoKTtcbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICBnZXQgI2xhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICYmIFwiYWRkZWRcIiB8fCB0aGlzLiNhbHRUZXh0ID09PSBudWxsICYmIHRoaXMuZ3Vlc3NlZFRleHQgJiYgXCJyZXZpZXdcIiB8fCBcIm1pc3NpbmdcIjtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkXG4gICAgfSk7XG4gICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCA9PT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZTtcbiAgfVxuICBoYXNEYXRhKCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgIT09IG51bGwgfHwgISF0aGlzLiNndWVzc2VkVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xuICB9XG4gIGdldCBndWVzc2VkVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZFRleHQoZ3Vlc3NlZFRleHQpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgIHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lciA9IGF3YWl0IEFsdFRleHQuX2wxMG4uZ2V0KFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1nZW5lcmF0ZWQtYWx0LXRleHQtd2l0aC1kaXNjbGFpbWVyXCIsIHtcbiAgICAgIGdlbmVyYXRlZEFsdFRleHQ6IGd1ZXNzZWRUZXh0XG4gICAgfSk7XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGVBbHRUZXh0QmFkZ2UodmlzaWJpbGl0eSA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiN1c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLiNhbHRUZXh0KSB7XG4gICAgICB0aGlzLiNiYWRnZT8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jYmFkZ2UpIHtcbiAgICAgIGNvbnN0IGJhZGdlID0gdGhpcy4jYmFkZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYmFkZ2UuY2xhc3NOYW1lID0gXCJub0FsdFRleHRCYWRnZVwiO1xuICAgICAgdGhpcy4jZWRpdG9yLmRpdi5hcHBlbmQoYmFkZ2UpO1xuICAgIH1cbiAgICB0aGlzLiNiYWRnZS5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmlsaXR5KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nKSB7XG4gICAgbGV0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIGlmICghaXNGb3JDb3B5aW5nICYmIHRoaXMuI2d1ZXNzZWRUZXh0ID09PSBhbHRUZXh0KSB7XG4gICAgICBhbHRUZXh0ID0gdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlLFxuICAgICAgZ3Vlc3NlZFRleHQ6IHRoaXMuI2d1ZXNzZWRUZXh0LFxuICAgICAgdGV4dFdpdGhEaXNjbGFpbWVyOiB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXJcbiAgICB9O1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0OiB0aGlzLiNhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmVcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHtcbiAgICBhbHRUZXh0LFxuICAgIGRlY29yYXRpdmUsXG4gICAgZ3Vlc3NlZFRleHQsXG4gICAgdGV4dFdpdGhEaXNjbGFpbWVyLFxuICAgIGNhbmNlbCA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoZ3Vlc3NlZFRleHQpIHtcbiAgICAgIHRoaXMuI2d1ZXNzZWRUZXh0ID0gZ3Vlc3NlZFRleHQ7XG4gICAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSB0ZXh0V2l0aERpc2NsYWltZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0ID09PSBhbHRUZXh0ICYmIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID09PSBkZWNvcmF0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgICAgIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID0gZGVjb3JhdGl2ZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGUoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCAmJiB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5kaXNhYmxlZCA9ICFlbmFibGVkO1xuICB9XG4gIHNob3duKCkge1xuICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5hbHRfdGV4dC5pbWFnZV9zdGF0dXNfbGFiZWxfZGlzcGxheWVkXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLiNsYWJlbFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2JhZGdlID0gbnVsbDtcbiAgfVxuICBhc3luYyAjc2V0U3RhdGUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYWx0VGV4dEJ1dHRvbjtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwiZG9uZVwiLCAhIXRoaXMuI2FsdFRleHQpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW3RoaXMuI2xhYmVsXSk7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWw/LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW2Ake3RoaXMuI2xhYmVsfS1sYWJlbGBdKTtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRvbmVcIik7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkb25lXCIpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1lZGl0LWJ1dHRvblwiKTtcbiAgICB9XG4gICAgbGV0IHRvb2x0aXAgPSB0aGlzLiNhbHRUZXh0VG9vbHRpcDtcbiAgICBpZiAoIXRvb2x0aXApIHtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdG9vbHRpcC5jbGFzc05hbWUgPSBcInRvb2x0aXBcIjtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2x0aXBcIik7XG4gICAgICB0b29sdGlwLmlkID0gYGFsdC10ZXh0LXRvb2x0aXAtJHt0aGlzLiNlZGl0b3IuaWR9YDtcbiAgICAgIGNvbnN0IERFTEFZX1RPX1NIT1dfVE9PTFRJUCA9IDEwMDtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbiAgICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgICBhY3Rpb246IFwiYWx0X3RleHRfdG9vbHRpcFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIERFTEFZX1RPX1NIT1dfVE9PTFRJUCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZGVjb3JhdGl2ZS10b29sdGlwXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b29sdGlwLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiKTtcbiAgICAgIHRvb2x0aXAudGV4dENvbnRlbnQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIH1cbiAgICBpZiAoIXRvb2x0aXAucGFyZW50Tm9kZSkge1xuICAgICAgYnV0dG9uLmFwcGVuZCh0b29sdGlwKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuI2VkaXRvci5nZXRJbWFnZUZvckFsdFRleHQoKTtcbiAgICBlbGVtZW50Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRlc2NyaWJlZGJ5XCIsIHRvb2x0aXAuaWQpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9lZGl0b3IuanNcblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgI2FsbFJlc2l6ZXJEaXZzID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjZGlzYWJsZWQgPSBmYWxzZTtcbiAgI2tlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAjcmVzaXplcnNEaXYgPSBudWxsO1xuICAjc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgI2ZvY3VzQUMgPSBudWxsO1xuICAjZm9jdXNlZFJlc2l6ZXJOYW1lID0gXCJcIjtcbiAgI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICNpbml0aWFsUG9zaXRpb24gPSBudWxsO1xuICAjaXNFZGl0aW5nID0gZmFsc2U7XG4gICNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAjbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICNwcmV2RHJhZ1ggPSAwO1xuICAjcHJldkRyYWdZID0gMDtcbiAgI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgX2VkaXRUb29sYmFyID0gbnVsbDtcbiAgX2luaXRpYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgX2luaXRpYWxEYXRhID0gbnVsbDtcbiAgX2lzVmlzaWJsZSA9IHRydWU7XG4gIF91aU1hbmFnZXIgPSBudWxsO1xuICBfZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgc3RhdGljIF9sMTBuID0gbnVsbDtcbiAgc3RhdGljIF9sMTBuUmVzaXplciA9IG51bGw7XG4gICNpc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAjekluZGV4ID0gQW5ub3RhdGlvbkVkaXRvci5fekluZGV4Kys7XG4gIHN0YXRpYyBfYm9yZGVyTGluZVdpZHRoID0gLTE7XG4gIHN0YXRpYyBfY29sb3JNYW5hZ2VyID0gbmV3IENvbG9yTWFuYWdlcigpO1xuICBzdGF0aWMgX3pJbmRleCA9IDE7XG4gIHN0YXRpYyBfdGVsZW1ldHJ5VGltZW91dCA9IDEwMDA7XG4gIHN0YXRpYyBnZXQgX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcmVzaXplID0gQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3Jlc2l6ZVdpdGhLZXlib2FyZDtcbiAgICBjb25zdCBzbWFsbCA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcIkFycm93TGVmdFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1zbWFsbCwgMF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dMZWZ0XCIsIFwibWFjK3NoaWZ0K0Fycm93TGVmdFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbLWJpZywgMF1cbiAgICB9XSwgW1tcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93UmlnaHRcIiwgXCJtYWMrc2hpZnQrQXJyb3dSaWdodFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbYmlnLCAwXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCAtc21hbGxdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93VXBcIiwgXCJtYWMrc2hpZnQrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLWJpZ11cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIHNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0Rvd25cIiwgXCJtYWMrc2hpZnQrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBiaWddXG4gICAgfV0sIFtbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBBbm5vdGF0aW9uRWRpdG9yLnByb3RvdHlwZS5fc3RvcFJlc2l6aW5nV2l0aEtleWJvYXJkXV0pKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICB0aGlzLmlkID0gcGFyYW1ldGVycy5pZDtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFyYW1ldGVycy5wYXJlbnQucGFnZUluZGV4O1xuICAgIHRoaXMubmFtZSA9IHBhcmFtZXRlcnMubmFtZTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy5fdWlNYW5hZ2VyID0gcGFyYW1ldGVycy51aU1hbmFnZXI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gZmFsc2U7XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMuaXNDZW50ZXJlZCA9IHBhcmFtZXRlcnMuaXNDZW50ZXJlZDtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcmF3RGltczoge1xuICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgIHBhZ2VYLFxuICAgICAgICBwYWdlWVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5wYWdlUm90YXRpb24gPSAoMzYwICsgcm90YXRpb24gLSB0aGlzLl91aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucm90YXRpb24pICUgMzYwO1xuICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLnBhZ2VUcmFuc2xhdGlvbiA9IFtwYWdlWCwgcGFnZVldO1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnggPSBwYXJhbWV0ZXJzLnggLyB3aWR0aDtcbiAgICB0aGlzLnkgPSBwYXJhbWV0ZXJzLnkgLyBoZWlnaHQ7XG4gICAgdGhpcy5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICB0aGlzLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgZWRpdG9yVHlwZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yLl90eXBlO1xuICB9XG4gIHN0YXRpYyBnZXQgX2RlZmF1bHRMaW5lQ29sb3IoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9kZWZhdWx0TGluZUNvbG9yXCIsIHRoaXMuX2NvbG9yTWFuYWdlci5nZXRIZXhDb2RlKFwiQ2FudmFzVGV4dFwiKSk7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIGNvbnN0IGZha2VFZGl0b3IgPSBuZXcgRmFrZUVkaXRvcih7XG4gICAgICBpZDogZWRpdG9yLnBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHBhcmVudDogZWRpdG9yLnBhcmVudCxcbiAgICAgIHVpTWFuYWdlcjogZWRpdG9yLl91aU1hbmFnZXJcbiAgICB9KTtcbiAgICBmYWtlRWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICBmYWtlRWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICAgIGZha2VFZGl0b3IuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGZha2VFZGl0b3IpO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIF91aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuID8/PSBsMTBuO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIHRvcExlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLWxlZnRcIixcbiAgICAgIHRvcE1pZGRsZTogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtbWlkZGxlXCIsXG4gICAgICB0b3BSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtcmlnaHRcIixcbiAgICAgIG1pZGRsZVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLW1pZGRsZS1yaWdodFwiLFxuICAgICAgYm90dG9tUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLXJpZ2h0XCIsXG4gICAgICBib3R0b21NaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLW1pZGRsZVwiLFxuICAgICAgYm90dG9tTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tbGVmdFwiLFxuICAgICAgbWlkZGxlTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtbGVmdFwiXG4gICAgfSk7XG4gICAgaWYgKEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1vdXRsaW5lLXdpZHRoXCIpKSB8fCAwO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKF90eXBlLCBfdmFsdWUpIHt9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgX2lzRHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0RyYWdnYWJsZTtcbiAgfVxuICBzZXQgX2lzRHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNEcmFnZ2FibGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnRvZ2dsZShcImRyYWdnYWJsZVwiLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNlbnRlcigpIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB0aGlzLnggLT0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55IC09IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55IC09IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyO1xuICB9XG4gIHNldEluQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSAwO1xuICB9XG4gIHNldEluRm9yZWdyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSB0aGlzLiN6SW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZUluZGV4ID0gcGFyZW50LnBhZ2VJbmRleDtcbiAgICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBwYXJlbnQucGFnZURpbWVuc2lvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQ2xpY2tlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICh0YXJnZXQ/LmNsb3Nlc3QoYCMke3RoaXMuaWR9YCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMucGFyZW50Py5pc011bHRpcGxlU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgc2V0QXQoeCwgeSwgdHgsIHR5KSB7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIFt0eCwgdHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih0eCwgdHkpO1xuICAgIHRoaXMueCA9ICh4ICsgdHgpIC8gd2lkdGg7XG4gICAgdGhpcy55ID0gKHkgKyB0eSkgLyBoZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gICN0cmFuc2xhdGUoW3dpZHRoLCBoZWlnaHRdLCB4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KTtcbiAgICB0aGlzLnggKz0geCAvIHdpZHRoO1xuICAgIHRoaXMueSArPSB5IC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHgsIHkpO1xuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7XG4gICAgdGhpcy4jaW5pdGlhbFBvc2l0aW9uIHx8PSBbdGhpcy54LCB0aGlzLnldO1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhZ2VEaW1lbnNpb25zLCB4LCB5KTtcbiAgICB0aGlzLmRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICBkcmFnKHR4LCB0eSkge1xuICAgIHRoaXMuI2luaXRpYWxQb3NpdGlvbiB8fD0gW3RoaXMueCwgdGhpcy55XTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmZpbmROZXdQYXJlbnQodGhpcywgeCwgeSkpIHtcbiAgICAgICAgdGhpcy54IC09IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgICAgdGhpcy55IC09IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLmdldEJhc2VUcmFuc2xhdGlvbigpO1xuICAgIHggKz0gYng7XG4gICAgeSArPSBieTtcbiAgICB0aGlzLmRpdi5zdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5kaXYuc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgZ2V0IF9oYXNCZWVuTW92ZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jaW5pdGlhbFBvc2l0aW9uICYmICh0aGlzLiNpbml0aWFsUG9zaXRpb25bMF0gIT09IHRoaXMueCB8fCB0aGlzLiNpbml0aWFsUG9zaXRpb25bMV0gIT09IHRoaXMueSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB7XG4gICAgICBfYm9yZGVyTGluZVdpZHRoXG4gICAgfSA9IEFubm90YXRpb25FZGl0b3I7XG4gICAgY29uc3QgeCA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCB5ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudEhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbLXgsIHldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCwgeV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4LCAteV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgfVxuICB9XG4gIGdldCBfbXVzdEZpeFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbikge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHdpZHRoICo9IHBhZ2VXaWR0aDtcbiAgICBoZWlnaHQgKj0gcGFnZUhlaWdodDtcbiAgICB4ICo9IHBhZ2VXaWR0aDtcbiAgICB5ICo9IHBhZ2VIZWlnaHQ7XG4gICAgaWYgKHRoaXMuX211c3RGaXhQb3NpdGlvbikge1xuICAgICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIHdpZHRoLCB4KSk7XG4gICAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSBoZWlnaHQsIHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZVdpZHRoIC0gaGVpZ2h0LCB4KSk7XG4gICAgICAgICAgeSA9IE1hdGgubWluKHBhZ2VIZWlnaHQsIE1hdGgubWF4KHdpZHRoLCB5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgIHggPSBNYXRoLm1pbihwYWdlV2lkdGgsIE1hdGgubWF4KHdpZHRoLCB4KSk7XG4gICAgICAgICAgeSA9IE1hdGgubWluKHBhZ2VIZWlnaHQsIE1hdGgubWF4KGhlaWdodCwgeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heChoZWlnaHQsIHgpKTtcbiAgICAgICAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4ocGFnZUhlaWdodCAtIHdpZHRoLCB5KSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMueCA9IHggLz0gcGFnZVdpZHRoO1xuICAgIHRoaXMueSA9IHkgLz0gcGFnZUhlaWdodDtcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICB9XG4gIHN0YXRpYyAjcm90YXRlUG9pbnQoeCwgeSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsteSwgeF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gIHBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgMzYwIC0gdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgI2dldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDFdO1xuICAgIH1cbiAgfVxuICBnZXQgcGFyZW50U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbiAgZ2V0IHBhcmVudFJvdGF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uICsgdGhpcy5wYWdlUm90YXRpb24pICUgMzYwO1xuICB9XG4gIGdldCBwYXJlbnREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtwYWdlV2lkdGggKiBwYXJlbnRTY2FsZSwgcGFnZUhlaWdodCAqIHBhcmVudFNjYWxlXTtcbiAgfVxuICBzZXREaW1zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSBgJHsoMTAwICogd2lkdGggLyBwYXJlbnRXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbykge1xuICAgICAgdGhpcy5kaXYuc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIGhlaWdodCAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gIH1cbiAgZml4RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB3aWR0aFBlcmNlbnQgPSB3aWR0aC5lbmRzV2l0aChcIiVcIik7XG4gICAgY29uc3QgaGVpZ2h0UGVyY2VudCA9ICF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgaGVpZ2h0LmVuZHNXaXRoKFwiJVwiKTtcbiAgICBpZiAod2lkdGhQZXJjZW50ICYmIGhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICghd2lkdGhQZXJjZW50KSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KHdpZHRoKSAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiAhaGVpZ2h0UGVyY2VudCkge1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgI2NyZWF0ZVJlc2l6ZXJzKCkge1xuICAgIGlmICh0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJzXCIpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID8gW1widG9wTGVmdFwiLCBcInRvcFJpZ2h0XCIsIFwiYm90dG9tUmlnaHRcIiwgXCJib3R0b21MZWZ0XCJdIDogW1widG9wTGVmdFwiLCBcInRvcE1pZGRsZVwiLCBcInRvcFJpZ2h0XCIsIFwibWlkZGxlUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbU1pZGRsZVwiLCBcImJvdHRvbUxlZnRcIiwgXCJtaWRkbGVMZWZ0XCJdO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc2VzKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKGRpdik7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJcIiwgbmFtZSk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIiwgbmFtZSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVyZG93bi5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLmRpdi5wcmVwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2KTtcbiAgfVxuICAjcmVzaXplclBvaW50ZXJkb3duKG5hbWUsIGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUoZmFsc2UpO1xuICAgIGNvbnN0IHNhdmVkRHJhZ2dhYmxlID0gdGhpcy5faXNEcmFnZ2FibGU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy4jcmVzaXplclBvaW50ZXJtb3ZlLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBzYXZlZERyYWdnYWJsZTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soc2F2ZWRYLCBzYXZlZFksIHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNhZGRSZXNpemVUb1VuZG9TdGFjayhzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpIHtcbiAgICBjb25zdCBuZXdYID0gdGhpcy54O1xuICAgIGNvbnN0IG5ld1kgPSB0aGlzLnk7XG4gICAgY29uc3QgbmV3V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgIGlmIChuZXdYID09PSBzYXZlZFggJiYgbmV3WSA9PT0gc2F2ZWRZICYmIG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgdGhpcy54ID0gbmV3WDtcbiAgICAgICAgdGhpcy55ID0gbmV3WTtcbiAgICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICB0aGlzLnNldERpbXMocGFyZW50V2lkdGggKiBuZXdXaWR0aCwgcGFyZW50SGVpZ2h0ICogbmV3SGVpZ2h0KTtcbiAgICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy53aWR0aCA9IHNhdmVkV2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc2F2ZWRIZWlnaHQ7XG4gICAgICAgIHRoaXMueCA9IHNhdmVkWDtcbiAgICAgICAgdGhpcy55ID0gc2F2ZWRZO1xuICAgICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIHNhdmVkV2lkdGgsIHBhcmVudEhlaWdodCAqIHNhdmVkSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZCA9IHggPT4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IHJvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IHJvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WSk7XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGgubWF4KG1pbldpZHRoLCBNYXRoLm1pbigxLCBNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpKSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoLm1heChtaW5IZWlnaHQsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkpKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHJvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHJvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LmZpbmlzaCgpO1xuICB9XG4gIGFzeW5jIGFkZEVkaXRUb29sYmFyKCkge1xuICAgIGlmICh0aGlzLl9lZGl0VG9vbGJhciB8fCB0aGlzLiNpc0luRWRpdE1vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lZGl0VG9vbGJhcjtcbiAgICB9XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBuZXcgRWRpdG9yVG9vbGJhcih0aGlzKTtcbiAgICB0aGlzLmRpdi5hcHBlbmQodGhpcy5fZWRpdFRvb2xiYXIucmVuZGVyKCkpO1xuICAgIGlmICh0aGlzLiNhbHRUZXh0KSB7XG4gICAgICBhd2FpdCB0aGlzLl9lZGl0VG9vbGJhci5hZGRBbHRUZXh0KHRoaXMuI2FsdFRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gIH1cbiAgcmVtb3ZlRWRpdFRvb2xiYXIoKSB7XG4gICAgaWYgKCF0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhci5yZW1vdmUoKTtcbiAgICB0aGlzLl9lZGl0VG9vbGJhciA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dD8uZGVzdHJveSgpO1xuICB9XG4gIGFkZENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICBjb25zdCBlZGl0VG9vbGJhckRpdiA9IHRoaXMuX2VkaXRUb29sYmFyPy5kaXY7XG4gICAgaWYgKGVkaXRUb29sYmFyRGl2KSB7XG4gICAgICBlZGl0VG9vbGJhckRpdi5iZWZvcmUoY29udGFpbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGNvbnRhaW5lcik7XG4gICAgfVxuICB9XG4gIGdldENsaWVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGFzeW5jIGFkZEFsdFRleHRCdXR0b24oKSB7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgQWx0VGV4dC5pbml0aWFsaXplKEFubm90YXRpb25FZGl0b3IuX2wxMG4pO1xuICAgIHRoaXMuI2FsdFRleHQgPSBuZXcgQWx0VGV4dCh0aGlzKTtcbiAgICBpZiAodGhpcy4jYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgdGhpcy4jYWNjZXNzaWJpbGl0eURhdGEgPSBudWxsO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmFkZEVkaXRUb29sYmFyKCk7XG4gIH1cbiAgZ2V0IGFsdFRleHREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5kYXRhO1xuICB9XG4gIHNldCBhbHRUZXh0RGF0YShkYXRhKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IGd1ZXNzZWRBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0Py5ndWVzc2VkVGV4dDtcbiAgfVxuICBhc3luYyBzZXRHdWVzc2VkQWx0VGV4dCh0ZXh0KSB7XG4gICAgYXdhaXQgdGhpcy4jYWx0VGV4dD8uc2V0R3Vlc3NlZFRleHQodGV4dCk7XG4gIH1cbiAgc2VyaWFsaXplQWx0VGV4dChpc0ZvckNvcHlpbmcpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uc2VyaWFsaXplKGlzRm9yQ29weWluZyk7XG4gIH1cbiAgaGFzQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0LmlzRW1wdHkoKTtcbiAgfVxuICBoYXNBbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uaGFzRGF0YSgpID8/IGZhbHNlO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0b3Itcm90YXRpb25cIiwgKDM2MCAtIHRoaXMucm90YXRpb24pICUgMzYwKTtcbiAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLm5hbWU7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSB0aGlzLiNkaXNhYmxlZCA/IC0xIDogMDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSkge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAodGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4V2lkdGggPSBgJHsoMTAwICogcGFyZW50SGVpZ2h0IC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICB0aGlzLmRpdi5zdHlsZS5tYXhIZWlnaHQgPSBgJHsoMTAwICogcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy5kaXYsIFtcInBvaW50ZXJkb3duXCJdKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9pc0RyYWdnYWJsZSkge1xuICAgICAgdGhpcy4jc2V0VXBEcmFnU2Vzc2lvbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgfVxuICBnZXQgaXNTZWxlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdWlNYW5hZ2VyLmlzU2VsZWN0ZWQodGhpcyk7XG4gIH1cbiAgI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuICAjc2V0VXBEcmFnU2Vzc2lvbihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzU2VsZWN0ZWRcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJtb3ZpbmdcIik7XG4gICAgICB0aGlzLiNwcmV2RHJhZ1ggPSBldmVudC5jbGllbnRYO1xuICAgICAgdGhpcy4jcHJldkRyYWdZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGNvbnN0IHBvaW50ZXJNb3ZlQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgICAgY2xpZW50WTogeVxuICAgICAgICB9ID0gZTtcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHggLSB0aGlzLiNwcmV2RHJhZ1gsIHkgLSB0aGlzLiNwcmV2RHJhZ1kpO1xuICAgICAgICB0aGlzLiNwcmV2RHJhZ1ggPSB4O1xuICAgICAgICB0aGlzLiNwcmV2RHJhZ1kgPSB5O1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZHJhZ1NlbGVjdGVkRWRpdG9ycyh0eCwgdHkpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgcG9pbnRlck1vdmVDYWxsYmFjaywge1xuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICB0aGlzLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwibW92aW5nXCIpO1xuICAgICAgfVxuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLmVuZERyYWdTZXNzaW9uKCkpIHtcbiAgICAgICAgdGhpcy4jc2VsZWN0T25Qb2ludGVyRXZlbnQoZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgbW92ZUluRE9NKCkge1xuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgfVxuICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI21vdmVJbkRPTVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5wYXJlbnQ/Lm1vdmVFZGl0b3JJbkRPTSh0aGlzKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KSB7XG4gICAgcGFyZW50LmNoYW5nZVBhcmVudCh0aGlzKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGdldFJlY3QodHgsIHR5LCByb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3Qgc2hpZnRYID0gdHggLyBzY2FsZTtcbiAgICBjb25zdCBzaGlmdFkgPSB0eSAvIHNjYWxlO1xuICAgIGNvbnN0IHggPSB0aGlzLnggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgeSA9IHRoaXMueSAqIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VZLCB4ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgKyBwYWdlWV07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyBwYWdlWSwgeCArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgcGFnZVksIHggLSBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWSwgeCAtIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCArIHBhZ2VZXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFJlY3RJbkN1cnJlbnRDb29yZHMocmVjdCwgcGFnZUhlaWdodCkge1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWN0O1xuICAgIGNvbnN0IHdpZHRoID0geDIgLSB4MTtcbiAgICBjb25zdCBoZWlnaHQgPSB5MiAtIHkxO1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTIsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkxLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTEsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MiwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7fVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgfVxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkO1xuICB9XG4gIG5lZWRzVG9CZVJlYnVpbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2ICYmICF0aGlzLmlzQXR0YWNoZWRUb0RPTTtcbiAgfVxuICAjYWRkRm9jdXNMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzQUMgfHwgIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIH1cbiAgcm90YXRlKF9hbmdsZSkge31cbiAgc2VyaWFsaXplRGVsZXRlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBbiBlZGl0b3IgbXVzdCBiZSBzZXJpYWxpemFibGVcIik7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgY29uc3QgZWRpdG9yID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKHtcbiAgICAgIHBhcmVudCxcbiAgICAgIGlkOiBwYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICB1aU1hbmFnZXJcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGVkaXRvci4jYWNjZXNzaWJpbGl0eURhdGEgPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGVkaXRvci5nZXRSZWN0SW5DdXJyZW50Q29vcmRzKGRhdGEucmVjdCwgcGFnZUhlaWdodCk7XG4gICAgZWRpdG9yLnggPSB4IC8gcGFnZVdpZHRoO1xuICAgIGVkaXRvci55ID0geSAvIHBhZ2VIZWlnaHQ7XG4gICAgZWRpdG9yLndpZHRoID0gd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IGhlaWdodCAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgaGFzQmVlbk1vZGlmaWVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAodGhpcy5kZWxldGVkIHx8IHRoaXMuc2VyaWFsaXplKCkgIT09IG51bGwpO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNmb2N1c0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2ZvY3VzQUMgPSBudWxsO1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVtb3ZlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgICAgdGhpcy4jbW92ZUluRE9NVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIHRoaXMucmVtb3ZlRWRpdFRvb2xiYXIoKTtcbiAgICBpZiAodGhpcy4jdGVsZW1ldHJ5VGltZW91dHMpIHtcbiAgICAgIGZvciAoY29uc3QgdGltZW91dCBvZiB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy52YWx1ZXMoKSkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1ha2VSZXNpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVJlc2l6ZXJzKCk7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgYmluZEV2ZW50cyh0aGlzLCB0aGlzLmRpdiwgW1wia2V5ZG93blwiXSk7XG4gICAgfVxuICB9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAga2V5ZG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5pc1Jlc2l6YWJsZSB8fCBldmVudC50YXJnZXQgIT09IHRoaXMuZGl2IHx8IGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLiNyZXNpemVyc0Rpdi5jaGlsZHJlbjtcbiAgICBpZiAoIXRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICB0aGlzLiNhbGxSZXNpemVyRGl2cyA9IEFycmF5LmZyb20oY2hpbGRyZW4pO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyS2V5ZG93biA9IHRoaXMuI3Jlc2l6ZXJLZXlkb3duLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBib3VuZFJlc2l6ZXJCbHVyID0gdGhpcy4jcmVzaXplckJsdXIuYmluZCh0aGlzKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzcGluYnV0dG9uXCIpO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgYm91bmRSZXNpemVyS2V5ZG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJvdW5kUmVzaXplckJsdXIsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jcmVzaXplckZvY3VzLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuI2FsbFJlc2l6ZXJEaXZzWzBdO1xuICAgIGxldCBmaXJzdFBvc2l0aW9uID0gMDtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGRpdiA9PT0gZmlyc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmaXJzdFBvc2l0aW9uKys7XG4gICAgfVxuICAgIGNvbnN0IG5leHRGaXJzdFBvc2l0aW9uID0gKDM2MCAtIHRoaXMucm90YXRpb24gKyB0aGlzLnBhcmVudFJvdGF0aW9uKSAlIDM2MCAvIDkwICogKHRoaXMuI2FsbFJlc2l6ZXJEaXZzLmxlbmd0aCAvIDQpO1xuICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiAhPT0gZmlyc3RQb3NpdGlvbikge1xuICAgICAgaWYgKG5leHRGaXJzdFBvc2l0aW9uIDwgZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpcnN0UG9zaXRpb24gLSBuZXh0Rmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKHRoaXMuI3Jlc2l6ZXJzRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRGaXJzdFBvc2l0aW9uID4gZmlyc3RQb3NpdGlvbikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHRGaXJzdFBvc2l0aW9uIC0gZmlyc3RQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RDaGlsZC5iZWZvcmUodGhpcy4jcmVzaXplcnNEaXYubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBkaXYgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1tpKytdO1xuICAgICAgICBjb25zdCBuYW1lID0gZGl2LmdldEF0dHJpYnV0ZShcImRhdGEtcmVzaXplci1uYW1lXCIpO1xuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQW5ub3RhdGlvbkVkaXRvci5fbDEwblJlc2l6ZXJbbmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZXRSZXNpemVyVGFiSW5kZXgoMCk7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gdHJ1ZTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdENoaWxkLmZvY3VzKHtcbiAgICAgIGZvY3VzVmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgI3Jlc2l6ZXJLZXlkb3duKGV2ZW50KSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fcmVzaXplcktleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjcmVzaXplckJsdXIoZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkICYmIGV2ZW50LnJlbGF0ZWRUYXJnZXQ/LnBhcmVudE5vZGUgIT09IHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB9XG4gIH1cbiAgI3Jlc2l6ZXJGb2N1cyhuYW1lKSB7XG4gICAgdGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lID0gdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID8gbmFtZSA6IFwiXCI7XG4gIH1cbiAgI3NldFJlc2l6ZXJUYWJJbmRleCh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBkaXYgb2YgdGhpcy4jYWxsUmVzaXplckRpdnMpIHtcbiAgICAgIGRpdi50YWJJbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBfcmVzaXplV2l0aEtleWJvYXJkKHgsIHkpIHtcbiAgICBpZiAoIXRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUodGhpcy4jZm9jdXNlZFJlc2l6ZXJOYW1lLCB7XG4gICAgICBtb3ZlbWVudFg6IHgsXG4gICAgICBtb3ZlbWVudFk6IHlcbiAgICB9KTtcbiAgfVxuICAjc3RvcFJlc2l6aW5nKCkge1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFJlc2l6ZXJUYWJJbmRleCgtMSk7XG4gICAgaWYgKHRoaXMuI3NhdmVkRGltZW5zaW9ucykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzYXZlZFgsXG4gICAgICAgIHNhdmVkWSxcbiAgICAgICAgc2F2ZWRXaWR0aCxcbiAgICAgICAgc2F2ZWRIZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNzYXZlZERpbWVuc2lvbnM7XG4gICAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjayhzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZCgpIHtcbiAgICB0aGlzLiNzdG9wUmVzaXppbmcoKTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIHNlbGVjdCgpIHtcbiAgICB0aGlzLm1ha2VSZXNpemFibGUoKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIGlmICghdGhpcy5fZWRpdFRvb2xiYXIpIHtcbiAgICAgIHRoaXMuYWRkRWRpdFRvb2xiYXIoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKSkge1xuICAgICAgICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uc2hvdygpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZUFsdFRleHRCYWRnZShmYWxzZSk7XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgdGhpcy4jcmVzaXplcnNEaXY/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAodGhpcy5kaXY/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyLmRpdi5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZUFsdFRleHRCYWRnZSh0cnVlKTtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHt9XG4gIGRpc2FibGVFZGl0aW5nKCkge31cbiAgZW5hYmxlRWRpdGluZygpIHt9XG4gIGVudGVySW5FZGl0TW9kZSgpIHt9XG4gIGdldEltYWdlRm9yQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG4gIHNldCBpc0VkaXRpbmcodmFsdWUpIHtcbiAgICB0aGlzLiNpc0VkaXRpbmcgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuI2tlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgIHN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICB9XG4gIHN0YXRpYyBnZXQgTUlOX1NJWkUoKSB7XG4gICAgcmV0dXJuIDE2O1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5SW5pdGlhbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogXCJhZGRlZFwiXG4gICAgfTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9yZXBvcnRUZWxlbWV0cnkoZGF0YSwgbXVzdFdhaXQgPSBmYWxzZSkge1xuICAgIGlmIChtdXN0V2FpdCkge1xuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgfHw9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGxldCB0aW1lb3V0ID0gdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZ2V0KGFjdGlvbik7XG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeShkYXRhKTtcbiAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuZGVsZXRlKGFjdGlvbik7XG4gICAgICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9LCBBbm5vdGF0aW9uRWRpdG9yLl90ZWxlbWV0cnlUaW1lb3V0KTtcbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNldChhY3Rpb24sIHRpbWVvdXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnR5cGUgfHw9IHRoaXMuZWRpdG9yVHlwZTtcbiAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgIGRhdGFcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzaG93KHZpc2libGUgPSB0aGlzLl9pc1Zpc2libGUpIHtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcbiAgICB0aGlzLl9pc1Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG4gIGVuYWJsZSgpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSBmYWxzZTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgdGhpcy4jZGlzYWJsZWQgPSB0cnVlO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBsZXQgY29udGVudCA9IGFubm90YXRpb24uY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCIuYW5ub3RhdGlvbkNvbnRlbnRcIik7XG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25Db250ZW50XCIsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICBhbm5vdGF0aW9uLmNvbnRhaW5lci5wcmVwZW5kKGNvbnRlbnQpO1xuICAgIH0gZWxzZSBpZiAoY29udGVudC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgY29uc3QgY2FudmFzID0gY29udGVudDtcbiAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvbkNvbnRlbnRcIiwgdGhpcy5lZGl0b3JUeXBlKTtcbiAgICAgIGNhbnZhcy5iZWZvcmUoY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0Q2hpbGRcbiAgICB9ID0gYW5ub3RhdGlvbi5jb250YWluZXI7XG4gICAgaWYgKGZpcnN0Q2hpbGQ/Lm5vZGVOYW1lID09PSBcIkRJVlwiICYmIGZpcnN0Q2hpbGQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYW5ub3RhdGlvbkNvbnRlbnRcIikpIHtcbiAgICAgIGZpcnN0Q2hpbGQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBGYWtlRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHBhcmFtcyk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkID0gcGFyYW1zLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgdGhpcy5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9zaGFyZWQvbXVybXVyaGFzaDMuanNcbmNvbnN0IFNFRUQgPSAweGMzZDJlMWYwO1xuY29uc3QgTUFTS19ISUdIID0gMHhmZmZmMDAwMDtcbmNvbnN0IE1BU0tfTE9XID0gMHhmZmZmO1xuY2xhc3MgTXVybXVySGFzaDNfNjQge1xuICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgdGhpcy5oMSA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gICAgdGhpcy5oMiA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gIH1cbiAgdXBkYXRlKGlucHV0KSB7XG4gICAgbGV0IGRhdGEsIGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoICogMik7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhmZikge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgPj4+IDg7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKCk7XG4gICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBmb3JtYXQsIG11c3QgYmUgYSBzdHJpbmcgb3IgVHlwZWRBcnJheS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrQ291bnRzID0gbGVuZ3RoID4+IDI7XG4gICAgY29uc3QgdGFpbExlbmd0aCA9IGxlbmd0aCAtIGJsb2NrQ291bnRzICogNDtcbiAgICBjb25zdCBkYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGRhdGEuYnVmZmVyLCAwLCBibG9ja0NvdW50cyk7XG4gICAgbGV0IGsxID0gMCxcbiAgICAgIGsyID0gMDtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGNvbnN0IEMxID0gMHhjYzllMmQ1MSxcbiAgICAgIEMyID0gMHgxYjg3MzU5MztcbiAgICBjb25zdCBDMV9MT1cgPSBDMSAmIE1BU0tfTE9XLFxuICAgICAgQzJfTE9XID0gQzIgJiBNQVNLX0xPVztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrQ291bnRzOyBpKyspIHtcbiAgICAgIGlmIChpICYgMSkge1xuICAgICAgICBrMSA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgICAgICBoMSA9IGgxICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrMiA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsyID0gazIgKiBDMSAmIE1BU0tfSElHSCB8IGsyICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsyID0gazIgPDwgMTUgfCBrMiA+Pj4gMTc7XG4gICAgICAgIGsyID0gazIgKiBDMiAmIE1BU0tfSElHSCB8IGsyICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgyIF49IGsyO1xuICAgICAgICBoMiA9IGgyIDw8IDEzIHwgaDIgPj4+IDE5O1xuICAgICAgICBoMiA9IGgyICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9XG4gICAgfVxuICAgIGsxID0gMDtcbiAgICBzd2l0Y2ggKHRhaWxMZW5ndGgpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAyXSA8PCAxNjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAxXSA8PCA4O1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNF07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGlmIChibG9ja0NvdW50cyAmIDEpIHtcbiAgICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoMiBePSBrMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmgxID0gaDE7XG4gICAgdGhpcy5oMiA9IGgyO1xuICB9XG4gIGhleGRpZ2VzdCgpIHtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweGVkNTU4Y2NkICYgTUFTS19ISUdIIHwgaDEgKiAweDhjY2QgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhmZjUxYWZkNyAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhhZmQ3ZWQ1NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweDFhODVlYzUzICYgTUFTS19ISUdIIHwgaDEgKiAweGVjNTMgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhjNGNlYjlmZSAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhiOWZlMWE4NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIikgKyAoaDIgPj4+IDApLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYW5ub3RhdGlvbl9zdG9yYWdlLmpzXG5cblxuXG5jb25zdCBTZXJpYWxpemFibGVFbXB0eSA9IE9iamVjdC5mcmVlemUoe1xuICBtYXA6IG51bGwsXG4gIGhhc2g6IFwiXCIsXG4gIHRyYW5zZmVyOiB1bmRlZmluZWRcbn0pO1xuY2xhc3MgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICAjbW9kaWZpZWQgPSBmYWxzZTtcbiAgI21vZGlmaWVkSWRzID0gbnVsbDtcbiAgI3N0b3JhZ2UgPSBuZXcgTWFwKCk7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub25TZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vblJlc2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID0gbnVsbDtcbiAgfVxuICBnZXRWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVmYXVsdFZhbHVlLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0UmF3VmFsdWUoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gIH1cbiAgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuI3N0b3JhZ2UuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgW2VudHJ5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAob2JqW2VudHJ5XSAhPT0gdmFsKSB7XG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIG9ialtlbnRyeV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgdGhpcy4jc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvciAmJiB0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IodmFsdWUuY29uc3RydWN0b3IuX3R5cGUpO1xuICAgIH1cbiAgfVxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2UuaGFzKGtleSk7XG4gIH1cbiAgZ2V0QWxsKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemUgPiAwID8gb2JqZWN0RnJvbU1hcCh0aGlzLiNzdG9yYWdlKSA6IG51bGw7XG4gIH1cbiAgc2V0QWxsKG9iaikge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgICB0aGlzLnNldFZhbHVlKGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2Uuc2l6ZTtcbiAgfVxuICAjc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKCF0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uU2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uU2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAodGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25SZXNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblJlc2V0TW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHJldHVybiBuZXcgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBTZXJpYWxpemFibGVFbXB0eTtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpLFxuICAgICAgaGFzaCA9IG5ldyBNdXJtdXJIYXNoM182NCgpLFxuICAgICAgdHJhbnNmZXIgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgaGFzQml0bWFwID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuI3N0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB2YWwgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yID8gdmFsLnNlcmlhbGl6ZShmYWxzZSwgY29udGV4dCkgOiB2YWw7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBtYXAuc2V0KGtleSwgc2VyaWFsaXplZCk7XG4gICAgICAgIGhhc2gudXBkYXRlKGAke2tleX06JHtKU09OLnN0cmluZ2lmeShzZXJpYWxpemVkKX1gKTtcbiAgICAgICAgaGFzQml0bWFwIHx8PSAhIXNlcmlhbGl6ZWQuYml0bWFwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzQml0bWFwKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG1hcC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUuYml0bWFwKSB7XG4gICAgICAgICAgdHJhbnNmZXIucHVzaCh2YWx1ZS5iaXRtYXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXAuc2l6ZSA+IDAgPyB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoOiBoYXNoLmhleGRpZ2VzdCgpLFxuICAgICAgdHJhbnNmZXJcbiAgICB9IDogU2VyaWFsaXphYmxlRW1wdHk7XG4gIH1cbiAgZ2V0IGVkaXRvclN0YXRzKCkge1xuICAgIGxldCBzdGF0cyA9IG51bGw7XG4gICAgY29uc3QgdHlwZVRvRWRpdG9yID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBbm5vdGF0aW9uRWRpdG9yKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRvclN0YXRzID0gdmFsdWUudGVsZW1ldHJ5RmluYWxEYXRhO1xuICAgICAgaWYgKCFlZGl0b3JTdGF0cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IGVkaXRvclN0YXRzO1xuICAgICAgaWYgKCF0eXBlVG9FZGl0b3IuaGFzKHR5cGUpKSB7XG4gICAgICAgIHR5cGVUb0VkaXRvci5zZXQodHlwZSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKS5jb25zdHJ1Y3Rvcik7XG4gICAgICB9XG4gICAgICBzdGF0cyB8fD0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGNvbnN0IG1hcCA9IHN0YXRzW3R5cGVdIHx8PSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMoZWRpdG9yU3RhdHMpKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ZXJzID0gbWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIWNvdW50ZXJzKSB7XG4gICAgICAgICAgY291bnRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgbWFwLnNldChrZXksIGNvdW50ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3VudCA9IGNvdW50ZXJzLmdldCh2YWwpID8/IDA7XG4gICAgICAgIGNvdW50ZXJzLnNldCh2YWwsIGNvdW50ICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW3R5cGUsIGVkaXRvcl0gb2YgdHlwZVRvRWRpdG9yKSB7XG4gICAgICBzdGF0c1t0eXBlXSA9IGVkaXRvci5jb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKHN0YXRzW3R5cGVdKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRzO1xuICB9XG4gIHJlc2V0TW9kaWZpZWRJZHMoKSB7XG4gICAgdGhpcy4jbW9kaWZpZWRJZHMgPSBudWxsO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICBpZiAodGhpcy4jbW9kaWZpZWRJZHMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNtb2RpZmllZElkcztcbiAgICB9XG4gICAgY29uc3QgaWRzID0gW107XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHx8ICF2YWx1ZS5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF2YWx1ZS5zZXJpYWxpemUoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlkcy5wdXNoKHZhbHVlLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jbW9kaWZpZWRJZHMgPSB7XG4gICAgICBpZHM6IG5ldyBTZXQoaWRzKSxcbiAgICAgIGhhc2g6IGlkcy5qb2luKFwiLFwiKVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgZXh0ZW5kcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNzZXJpYWxpemFibGU7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHBhcmVudC5zZXJpYWxpemFibGU7XG4gICAgY29uc3QgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUobWFwLCB0cmFuc2ZlciA/IHtcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA6IG51bGwpO1xuICAgIHRoaXMuI3NlcmlhbGl6YWJsZSA9IHtcbiAgICAgIG1hcDogY2xvbmUsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9O1xuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBQcmludEFubm90YXRpb25TdG9yYWdlLnByaW50XCIpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlcmlhbGl6YWJsZTtcbiAgfVxuICBnZXQgbW9kaWZpZWRJZHMoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIm1vZGlmaWVkSWRzXCIsIHtcbiAgICAgIGlkczogbmV3IFNldCgpLFxuICAgICAgaGFzaDogXCJcIlxuICAgIH0pO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZvbnRfbG9hZGVyLmpzXG5cbmNsYXNzIEZvbnRMb2FkZXIge1xuICAjc3lzdGVtRm9udHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBzdHlsZUVsZW1lbnQgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMubG9hZGluZ1JlcXVlc3RzID0gW107XG4gICAgdGhpcy5sb2FkVGVzdEZvbnRJZCA9IDA7XG4gIH1cbiAgYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgcmVtb3ZlTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKCF0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZCh0aGlzLnN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSB0aGlzLnN0eWxlRWxlbWVudC5zaGVldDtcbiAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUocnVsZSwgc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgbmF0aXZlRm9udEZhY2Ugb2YgdGhpcy5uYXRpdmVGb250RmFjZXMpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jc3lzdGVtRm9udHMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2FkU3lzdGVtRm9udCh7XG4gICAgc3lzdGVtRm9udEluZm86IGluZm8sXG4gICAgX2luc3BlY3RGb250XG4gIH0pIHtcbiAgICBpZiAoIWluZm8gfHwgdGhpcy4jc3lzdGVtRm9udHMuaGFzKGluZm8ubG9hZGVkTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXNzZXJ0KCF0aGlzLmRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UobG9hZGVkTmFtZSwgc3JjLCBzdHlsZSk7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgICAgdGhpcy4jc3lzdGVtRm9udHMuYWRkKGxvYWRlZE5hbWUpO1xuICAgICAgICBfaW5zcGVjdEZvbnQ/LihpbmZvKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB3YXJuKGBDYW5ub3QgbG9hZCBzeXN0ZW0gZm9udDogJHtpbmZvLmJhc2VGb250TmFtZX0sIGluc3RhbGxpbmcgaXQgY291bGQgaGVscCB0byBpbXByb3ZlIFBERiByZW5kZXJpbmcuYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2FkIGZvbnQgJyR7bmF0aXZlRm9udEZhY2UuZmFtaWx5fSc6ICcke2V4fScuYCk7XG4gICAgICAgICAgZm9udC5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBmb250LmNyZWF0ZUZvbnRGYWNlUnVsZSgpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICBpZiAodGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKHJlc29sdmUpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCBoYXNGb250cyA9ICEhdGhpcy5fZG9jdW1lbnQ/LmZvbnRzO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIGhhc0ZvbnRzKTtcbiAgfVxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgbGV0IHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIGlmIChpc05vZGVKUykge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIG5hdmlnYXRvcj8udXNlckFnZW50ID09PSBcInN0cmluZ1wiICYmIC9Nb3ppbGxhXFwvNS4wLio/cnY6XFxkKy4qPyBHZWNrby8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkXCIsIHN1cHBvcnRlZCk7XG4gIH1cbiAgX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gY29tcGxldGVSZXF1ZXN0KCkge1xuICAgICAgYXNzZXJ0KCFyZXF1ZXN0LmRvbmUsIFwiY29tcGxldGVSZXF1ZXN0KCkgY2Fubm90IGJlIGNhbGxlZCB0d2ljZS5cIik7XG4gICAgICByZXF1ZXN0LmRvbmUgPSB0cnVlO1xuICAgICAgd2hpbGUgKGxvYWRpbmdSZXF1ZXN0cy5sZW5ndGggPiAwICYmIGxvYWRpbmdSZXF1ZXN0c1swXS5kb25lKSB7XG4gICAgICAgIGNvbnN0IG90aGVyUmVxdWVzdCA9IGxvYWRpbmdSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICBzZXRUaW1lb3V0KG90aGVyUmVxdWVzdC5jYWxsYmFjaywgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxvYWRpbmdSZXF1ZXN0c1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICBkb25lOiBmYWxzZSxcbiAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICBjYWxsYmFja1xuICAgIH07XG4gICAgbG9hZGluZ1JlcXVlc3RzLnB1c2gocmVxdWVzdCk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cbiAgZ2V0IF9sb2FkVGVzdEZvbnQoKSB7XG4gICAgY29uc3QgdGVzdEZvbnQgPSBhdG9iKFwiVDFSVVR3QUxBSUFBQXdBd1EwWkdJREh0Wmc0QUFBT1lBQUFBZ1VaR1ZFMWxrelp3QUFBRUhBQUFBQnhIUkVWR0FCUUFcIiArIFwiRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFcIiArIFwiQUx3QUFBQTJhR2hsWVFka0Erb0FBQUQwQUFBQUpHaHRkSGdENkFBQUFBQUVXQUFBQUFadFlYaHdBQUpRQUFBQUFSZ0FcIiArIFwiQUFBR2JtRnRaVmptZEg0QUFBR0FBQUFBc1hCdmMzVC9oZ0F6QUFBRGVBQUFBQ0FBQVFBQUFBRUFBTFpSRnNSZkR6ejFcIiArIFwiQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0RcIiArIFwiNkFBQUFBQUQ2QUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBVUFBQUFnQUFBQVFENkFIMEFBVUFBQUtLQXJ3QUFBQ01cIiArIFwiQW9vQ3ZBQUFBZUFBTVFFQ0FBQUNBQVlKQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFGQm1SV1FBd0FBdUFDNERcIiArIFwiSVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFcIiArIFwiQUFFQUFRQUFBQUVBQUFBQUFBSUFBUUFBQUFFQUFBQUFBQU1BQVFBQUFBRUFBQUFBQUFRQUFRQUFBQUVBQUFBQUFBVUFcIiArIFwiQVFBQUFBRUFBQUFBQUFZQUFRQUFBQU1BQVFRSkFBQUFBZ0FCQUFNQUFRUUpBQUVBQWdBQkFBTUFBUVFKQUFJQUFnQUJcIiArIFwiQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllcIiArIFwiQUFBQUFBQUFBd0FBQUFNQUFBQWNBQUVBQUFBQUFEd0FBd0FCQUFBQUhBQUVBQ0FBQUFBRUFBUUFBUUFBQUM3Ly93QUFcIiArIFwiQUM3Ly8vL1RBQUVBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFEL2d3QXlBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQkFBUUVBQUVCQVFKWUFBRUJBU0g0RHdENEd3SEVBdmdjQS9nWEJJd01BWXVMK256NXRRWGtENWozQ0JMbkVRQUNcIiArIFwiQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNcIiArIFwiRG92NmZBSDZmQVQrZlBwOCtud0hEb3NNQ3ZtMUN2bTFEQXo2ZkJRQUFBQUFBQUFCQUFBQUFNbUpiekVBQUFBQXpnVGpcIiArIFwiRlFBQUFBRE9CT1FwQUFFQUFBQUFBQUFBREFBVUFBUUFBQUFCQUFBQUFnQUJBQUFBQUFBQUFBQUQ2QUFBQUFBQUFBPT1cIik7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9sb2FkVGVzdEZvbnRcIiwgdGVzdEZvbnQpO1xuICB9XG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDB4ZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZVN0cmluZyhzLCBvZmZzZXQsIHJlbW92ZSwgaW5zZXJ0KSB7XG4gICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3QgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgIHJldHVybiBjaHVuazEgKyBpbnNlcnQgKyBjaHVuazI7XG4gICAgfVxuICAgIGxldCBpLCBpaTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBpc0ZvbnRSZWFkeShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCsrY2FsbGVkID4gMzApIHtcbiAgICAgICAgd2FybihcIkxvYWQgdGVzdCBmb250IG5ldmVyIGxvYWRlZC5cIik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGN0eC5mb250ID0gXCIzMHB4IFwiICsgbmFtZTtcbiAgICAgIGN0eC5maWxsVGV4dChcIi5cIiwgMCwgMjApO1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICAgIGlmIChpbWFnZURhdGEuZGF0YVszXSA+IDApIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0VGltZW91dChpc0ZvbnRSZWFkeS5iaW5kKG51bGwsIG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRUZXN0Rm9udElkID0gYGx0JHtEYXRlLm5vdygpfSR7dGhpcy5sb2FkVGVzdEZvbnRJZCsrfWA7XG4gICAgbGV0IGRhdGEgPSB0aGlzLl9sb2FkVGVzdEZvbnQ7XG4gICAgY29uc3QgQ09NTUVOVF9PRkZTRVQgPSA5NzY7XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDT01NRU5UX09GRlNFVCwgbG9hZFRlc3RGb250SWQubGVuZ3RoLCBsb2FkVGVzdEZvbnRJZCk7XG4gICAgY29uc3QgQ0ZGX0NIRUNLU1VNX09GRlNFVCA9IDE2O1xuICAgIGNvbnN0IFhYWFhfVkFMVUUgPSAweDU4NTg1ODU4O1xuICAgIGxldCBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuICAgIGZvciAoaSA9IDAsIGlpID0gbG9hZFRlc3RGb250SWQubGVuZ3RoIC0gMzsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQsIGkpIHwgMDtcbiAgICB9XG4gICAgaWYgKGkgPCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgpIHtcbiAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQgKyBcIlhYWFwiLCBpKSB8IDA7XG4gICAgfVxuICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCwgNCwgc3RyaW5nMzIoY2hlY2tzdW0pKTtcbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICBjb25zdCBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHtsb2FkVGVzdEZvbnRJZH1cIjtzcmM6JHt1cmx9fWA7XG4gICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgIGNvbnN0IGRpdiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIGRpdi5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS5oZWlnaHQgPSBcIjEwcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnN0eWxlLnRvcCA9IGRpdi5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgW2ZvbnQubG9hZGVkTmFtZSwgbG9hZFRlc3RGb250SWRdKSB7XG4gICAgICBjb25zdCBzcGFuID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuLnRleHRDb250ZW50ID0gXCJIaVwiO1xuICAgICAgc3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gbmFtZTtcbiAgICAgIGRpdi5hcHBlbmQoc3Bhbik7XG4gICAgfVxuICAgIHRoaXMuX2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgaXNGb250UmVhZHkobG9hZFRlc3RGb250SWQsICgpID0+IHtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIHJlcXVlc3QuY29tcGxldGUoKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgRm9udEZhY2VPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcih0cmFuc2xhdGVkRGF0YSwge1xuICAgIGRpc2FibGVGb250RmFjZSA9IGZhbHNlLFxuICAgIGluc3BlY3RGb250ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5jb21waWxlZEdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBpIGluIHRyYW5zbGF0ZWREYXRhKSB7XG4gICAgICB0aGlzW2ldID0gdHJhbnNsYXRlZERhdGFbaV07XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZUZvbnRGYWNlID0gZGlzYWJsZUZvbnRGYWNlID09PSB0cnVlO1xuICAgIHRoaXMuX2luc3BlY3RGb250ID0gaW5zcGVjdEZvbnQ7XG4gIH1cbiAgY3JlYXRlTmF0aXZlRm9udEZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmF0aXZlRm9udEZhY2U7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmxvYWRlZE5hbWUsIHRoaXMuZGF0YSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgIHdlaWdodDogdGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzLnN0eWxlID0gYG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZ2A7XG4gICAgICB9XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHksIHRoaXMuZGF0YSwgY3NzKTtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzKTtcbiAgICByZXR1cm4gbmF0aXZlRm9udEZhY2U7XG4gIH1cbiAgY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7dG9CYXNlNjRVdGlsKHRoaXMuZGF0YSl9KTtgO1xuICAgIGxldCBydWxlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5sb2FkZWROYW1lfVwiO3NyYzoke3VybH19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNzcyA9IGBmb250LXdlaWdodDogJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHR9O2A7XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3MgKz0gYGZvbnQtc3R5bGU6IG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZztgO1xuICAgICAgfVxuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5fVwiOyR7Y3NzfXNyYzoke3VybH19YDtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzLCB1cmwpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIGdldFBhdGhHZW5lcmF0b3Iob2JqcywgY2hhcmFjdGVyKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdO1xuICAgIH1cbiAgICBsZXQgY21kcztcbiAgICB0cnkge1xuICAgICAgY21kcyA9IG9ianMuZ2V0KHRoaXMubG9hZGVkTmFtZSArIFwiX3BhdGhfXCIgKyBjaGFyYWN0ZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBnZXRQYXRoR2VuZXJhdG9yIC0gaWdub3JpbmcgY2hhcmFjdGVyOiBcIiR7ZXh9XCIuYCk7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShjbWRzKSB8fCBjbWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IGZ1bmN0aW9uIChjLCBzaXplKSB7fTtcbiAgICB9XG4gICAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBjbWRzLmxlbmd0aDsgaSA8IGlpOykge1xuICAgICAgc3dpdGNoIChjbWRzW2krK10pIHtcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLkJFWklFUl9DVVJWRV9UTzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBbYSwgYiwgYywgZCwgZSwgZl0gPSBjbWRzLnNsaWNlKGksIGkgKyA2KTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5iZXppZXJDdXJ2ZVRvKGEsIGIsIGMsIGQsIGUsIGYpKTtcbiAgICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5NT1ZFX1RPOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IFthLCBiXSA9IGNtZHMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjdHggPT4gY3R4Lm1vdmVUbyhhLCBiKSk7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuTElORV9UTzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBbYSwgYl0gPSBjbWRzLnNsaWNlKGksIGkgKyAyKTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5saW5lVG8oYSwgYikpO1xuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLlFVQURSQVRJQ19DVVJWRV9UTzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBbYSwgYiwgYywgZF0gPSBjbWRzLnNsaWNlKGksIGkgKyA0KTtcbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGEsIGIsIGMsIGQpKTtcbiAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5SRVNUT1JFOlxuICAgICAgICAgIGNvbW1hbmRzLnB1c2goY3R4ID0+IGN0eC5yZXN0b3JlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZvbnRSZW5kZXJPcHMuU0FWRTpcbiAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHguc2F2ZSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBGb250UmVuZGVyT3BzLlNDQUxFOlxuICAgICAgICAgIGFzc2VydChjb21tYW5kcy5sZW5ndGggPT09IDIsIFwiU2NhbGUgY29tbWFuZCBpcyBvbmx5IHZhbGlkIGF0IHRoZSB0aGlyZCBwb3NpdGlvbi5cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5UUkFOU0ZPUk06XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgW2EsIGIsIGMsIGQsIGUsIGZdID0gY21kcy5zbGljZShpLCBpICsgNik7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpKTtcbiAgICAgICAgICAgIGkgKz0gNjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRm9udFJlbmRlck9wcy5UUkFOU0xBVEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgW2EsIGJdID0gY21kcy5zbGljZShpLCBpICsgMik7XG4gICAgICAgICAgICBjb21tYW5kcy5wdXNoKGN0eCA9PiBjdHgudHJhbnNsYXRlKGEsIGIpKTtcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBmdW5jdGlvbiBnbHlwaERyYXdlcihjdHgsIHNpemUpIHtcbiAgICAgIGNvbW1hbmRzWzBdKGN0eCk7XG4gICAgICBjb21tYW5kc1sxXShjdHgpO1xuICAgICAgY3R4LnNjYWxlKHNpemUsIC1zaXplKTtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IGNvbW1hbmRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29tbWFuZHNbaV0oY3R4KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhc19mYWN0b3J5LmpzXG5cbmNsYXNzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgI2VuYWJsZUhXQSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuI2VuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLiNlbmFibGVIV0FcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMgPSBudWxsO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBlbmFibGVIV0EgPSBmYWxzZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZW5hYmxlSFdBXG4gICAgfSk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NtYXBfcmVhZGVyX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGwsXG4gICAgaXNDb21wcmVzc2VkID0gdHJ1ZVxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgY01hcFVybGAgYW5kIGBjTWFwUGFja2VkYCBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXAgbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCkudGhlbihjTWFwRGF0YSA9PiAoe1xuICAgICAgY01hcERhdGEsXG4gICAgICBpc0NvbXByZXNzZWQ6IHRoaXMuaXNDb21wcmVzc2VkXG4gICAgfSkpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkICR7dGhpcy5pc0NvbXByZXNzZWQgPyBcImJpbmFyeSBcIiA6IFwiXCJ9Q01hcCBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCB0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYXJyYXlidWZmZXJcIiA6IFwidGV4dFwiKTtcbiAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoZGF0YSkgOiBzdHJpbmdUb0J5dGVzKGRhdGEpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZpbHRlcl9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHt9XG59XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjYmFzZVVybDtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI19oY21DYWNoZTtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy4jZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIGdldCAjY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19jYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjaGNtQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19oY21DYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuI19kZWZzKSB7XG4gICAgICBjb25zdCBkaXYgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGRpdjtcbiAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgc3R5bGUuY29udGFpbiA9IFwic3RyaWN0XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IDA7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSAwO1xuICAgICAgc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICBjb25zdCBzdmcgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcInN2Z1wiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZGVmc1wiKTtcbiAgICAgIGRpdi5hcHBlbmQoc3ZnKTtcbiAgICAgIHN2Zy5hcHBlbmQodGhpcy4jX2RlZnMpO1xuICAgICAgdGhpcy4jZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI19kZWZzO1xuICB9XG4gICNjcmVhdGVUYWJsZXMobWFwcykge1xuICAgIGlmIChtYXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbWFwUiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIFt0YWJsZSwgdGFibGUsIHRhYmxlXTtcbiAgICB9XG4gICAgY29uc3QgW21hcFIsIG1hcEcsIG1hcEJdID0gbWFwcztcbiAgICBjb25zdCBidWZmZXJSID0gbmV3IEFycmF5KDI1Nik7XG4gICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckdbaV0gPSBtYXBHW2ldIC8gMjU1O1xuICAgICAgYnVmZmVyQltpXSA9IG1hcEJbaV0gLyAyNTU7XG4gICAgfVxuICAgIHJldHVybiBbYnVmZmVyUi5qb2luKFwiLFwiKSwgYnVmZmVyRy5qb2luKFwiLFwiKSwgYnVmZmVyQi5qb2luKFwiLFwiKV07XG4gIH1cbiAgI2NyZWF0ZVVybChpZCkge1xuICAgIGlmICh0aGlzLiNiYXNlVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuI2Jhc2VVcmwgPSBcIlwiO1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jZG9jdW1lbnQuVVJMO1xuICAgICAgaWYgKHVybCAhPT0gdGhpcy4jZG9jdW1lbnQuYmFzZVVSSSkge1xuICAgICAgICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICAgICAgICB3YXJuKCcjY3JlYXRlVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNiYXNlVXJsID0gdXJsLnNwbGl0KFwiI1wiLCAxKVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYHVybCgke3RoaXMuI2Jhc2VVcmx9IyR7aWR9KWA7XG4gIH1cbiAgYWRkRmlsdGVyKG1hcHMpIHtcbiAgICBpZiAoIW1hcHMpIHtcbiAgICAgIHJldHVybiBcIm5vbmVcIjtcbiAgICB9XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcHMpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBbdGFibGVSLCB0YWJsZUcsIHRhYmxlQl0gPSB0aGlzLiNjcmVhdGVUYWJsZXMobWFwcyk7XG4gICAgY29uc3Qga2V5ID0gbWFwcy5sZW5ndGggPT09IDEgPyB0YWJsZVIgOiBgJHt0YWJsZVJ9JHt0YWJsZUd9JHt0YWJsZUJ9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcHMsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV90cmFuc2Zlcl9tYXBfJHt0aGlzLiNpZCsrfWA7XG4gICAgY29uc3QgdXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlUiwgdGFibGVHLCB0YWJsZUIsIGZpbHRlcik7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIGNvbnN0IGtleSA9IGAke2ZnQ29sb3J9LSR7YmdDb2xvcn1gO1xuICAgIGNvbnN0IGZpbHRlck5hbWUgPSBcImJhc2VcIjtcbiAgICBsZXQgaW5mbyA9IHRoaXMuI2hjbUNhY2hlLmdldChmaWx0ZXJOYW1lKTtcbiAgICBpZiAoaW5mbz8ua2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm8uZmlsdGVyPy5yZW1vdmUoKTtcbiAgICAgIGluZm8ua2V5ID0ga2V5O1xuICAgICAgaW5mby51cmwgPSBcIm5vbmVcIjtcbiAgICAgIGluZm8uZmlsdGVyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyA9IHtcbiAgICAgICAga2V5LFxuICAgICAgICB1cmw6IFwibm9uZVwiLFxuICAgICAgICBmaWx0ZXI6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLiNoY21DYWNoZS5zZXQoZmlsdGVyTmFtZSwgaW5mbyk7XG4gICAgfVxuICAgIGlmICghZmdDb2xvciB8fCAhYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBmZ1JHQiA9IHRoaXMuI2dldFJHQihmZ0NvbG9yKTtcbiAgICBmZ0NvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4uZmdSR0IpO1xuICAgIGNvbnN0IGJnUkdCID0gdGhpcy4jZ2V0UkdCKGJnQ29sb3IpO1xuICAgIGJnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5iZ1JHQik7XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgaWYgKGZnQ29sb3IgPT09IFwiIzAwMDAwMFwiICYmIGJnQ29sb3IgPT09IFwiI2ZmZmZmZlwiIHx8IGZnQ29sb3IgPT09IGJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU1OyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpIC8gMjU1O1xuICAgICAgbWFwW2ldID0geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSBtYXAuam9pbihcIixcIik7XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbmZvLmZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHRhYmxlLCB0YWJsZSwgdGFibGUsIGZpbHRlcik7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChjLCBuKSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IGZnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgZW5kID0gYmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkobiArIDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IHN0YXJ0ICsgaSAvIG4gKiAoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcygwLCA1KSwgZ2V0U3RlcHMoMSwgNSksIGdldFN0ZXBzKDIsIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgYWRkQWxwaGFGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICBjb25zdCBrZXkgPSBgYWxwaGFfJHt0YWJsZUF9YDtcbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2FscGhhX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQWxwaGFDb252ZXJzaW9uKHRhYmxlQSwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEx1bWlub3NpdHlGaWx0ZXIobWFwKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KG1hcCB8fCBcImx1bWlub3NpdHlcIik7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB0YWJsZUEsIGtleTtcbiAgICBpZiAobWFwKSB7XG4gICAgICBbdGFibGVBXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhbbWFwXSk7XG4gICAgICBrZXkgPSBgbHVtaW5vc2l0eV8ke3RhYmxlQX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBcImx1bWlub3NpdHlcIjtcbiAgICB9XG4gICAgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9sdW1pbm9zaXR5X21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXAsIHVybCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgdXJsKTtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZEx1bWlub3NpdHlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgaWYgKG1hcCkge1xuICAgICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmaWx0ZXJOYW1lLCBmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfS0ke25ld0ZnQ29sb3J9LSR7bmV3QmdDb2xvcn1gO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IFtmZ1JHQiwgYmdSR0JdID0gW2ZnQ29sb3IsIGJnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgbGV0IGZnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogZmdSR0JbMF0gKyAwLjcxNTIgKiBmZ1JHQlsxXSArIDAuMDcyMiAqIGZnUkdCWzJdKTtcbiAgICBsZXQgYmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBiZ1JHQlswXSArIDAuNzE1MiAqIGJnUkdCWzFdICsgMC4wNzIyICogYmdSR0JbMl0pO1xuICAgIGxldCBbbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGlmIChiZ0dyYXkgPCBmZ0dyYXkpIHtcbiAgICAgIFtmZ0dyYXksIGJnR3JheSwgbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtiZ0dyYXksIGZnR3JheSwgbmV3QmdSR0IsIG5ld0ZnUkdCXTtcbiAgICB9XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoZmcsIGJnLCBuKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoYmdHcmF5IC0gZmdHcmF5KSAvIG47XG4gICAgICBjb25zdCBuZXdTdGFydCA9IGZnIC8gMjU1O1xuICAgICAgY29uc3QgbmV3U3RlcCA9IChiZyAtIGZnKSAvICgyNTUgKiBuKTtcbiAgICAgIGxldCBwcmV2ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5yb3VuZChmZ0dyYXkgKyBpICogc3RlcCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3U3RhcnQgKyBpICogbmV3U3RlcDtcbiAgICAgICAgZm9yIChsZXQgaiA9IHByZXY7IGogPD0gazsgaisrKSB7XG4gICAgICAgICAgYXJyW2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGsgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHByZXY7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhcnJbcHJldiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtXyR7ZmlsdGVyTmFtZX1fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSBpbmZvLmZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMobmV3RmdSR0JbMF0sIG5ld0JnUkdCWzBdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMV0sIG5ld0JnUkdCWzFdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMl0sIG5ld0JnUkdCWzJdLCA1KSwgZmlsdGVyKTtcbiAgICBpbmZvLnVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgcmV0dXJuIGluZm8udXJsO1xuICB9XG4gIGRlc3Ryb3koa2VlcEhDTSA9IGZhbHNlKSB7XG4gICAgaWYgKGtlZXBIQ00gJiYgdGhpcy4jaGNtQ2FjaGUuc2l6ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jX2RlZnMpIHtcbiAgICAgIHRoaXMuI19kZWZzLnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI19kZWZzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI19jYWNoZSkge1xuICAgICAgdGhpcy4jX2NhY2hlLmNsZWFyKCk7XG4gICAgICB0aGlzLiNfY2FjaGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNpZCA9IDA7XG4gIH1cbiAgI2FkZEx1bWlub3NpdHlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMC4zIDAuNTkgMC4xMSAwIDBcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbG9yTWF0cml4KTtcbiAgfVxuICAjYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb2xvck1hdHJpeCA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb2xvck1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJtYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZXNcIiwgXCIwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwIDAgMCAxIDBcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbG9yTWF0cml4KTtcbiAgfVxuICAjY3JlYXRlRmlsdGVyKGlkKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmaWx0ZXJcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLCBcInNSR0JcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICB0aGlzLiNkZWZzLmFwcGVuZChmaWx0ZXIpO1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBmdW5jLCB0YWJsZSkge1xuICAgIGNvbnN0IGZlRnVuYyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIGZ1bmMpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZGlzY3JldGVcIik7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInRhYmxlVmFsdWVzXCIsIHRhYmxlKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZChmZUZ1bmMpO1xuICB9XG4gICNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oclRhYmxlLCBnVGFibGUsIGJUYWJsZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb21wb25lbnRUcmFuc2ZlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY1JcIiwgclRhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNHXCIsIGdUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQlwiLCBiVGFibGUpO1xuICB9XG4gICNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbihhVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNBXCIsIGFUYWJsZSk7XG4gIH1cbiAgI2dldFJHQihjb2xvcikge1xuICAgIHRoaXMuI2RlZnMuc3R5bGUuY29sb3IgPSBjb2xvcjtcbiAgICByZXR1cm4gZ2V0UkdCKGdldENvbXB1dGVkU3R5bGUodGhpcy4jZGVmcykuZ2V0UHJvcGVydHlWYWx1ZShcImNvbG9yXCIpKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9zdGFuZGFyZF9mb250ZGF0YV9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgc3RhbmRhcmRGb250RGF0YVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIGZvbnQgZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3V0aWxzLmpzXG5cblxuXG5cblxuaWYgKGlzTm9kZUpTKSB7XG4gIHZhciBwYWNrYWdlQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICB2YXIgcGFja2FnZU1hcCA9IG51bGw7XG4gIGNvbnN0IGxvYWRQYWNrYWdlcyA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBmcyA9IGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6IHRydWUqL1wiZnNcIiksXG4gICAgICBodHRwID0gYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTogdHJ1ZSovXCJodHRwXCIpLFxuICAgICAgaHR0cHMgPSBhd2FpdCBpbXBvcnQoLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi9cImh0dHBzXCIpLFxuICAgICAgdXJsID0gYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTogdHJ1ZSovXCJ1cmxcIik7XG4gICAgbGV0IGNhbnZhcywgcGF0aDJkO1xuICAgIHJldHVybiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIGZzLFxuICAgICAgaHR0cCxcbiAgICAgIGh0dHBzLFxuICAgICAgdXJsLFxuICAgICAgY2FudmFzLFxuICAgICAgcGF0aDJkXG4gICAgfSkpO1xuICB9O1xuICBsb2FkUGFja2FnZXMoKS50aGVuKG1hcCA9PiB7XG4gICAgcGFja2FnZU1hcCA9IG1hcDtcbiAgICBwYWNrYWdlQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH0sIHJlYXNvbiA9PiB7XG4gICAgd2FybihgbG9hZFBhY2thZ2VzOiAke3JlYXNvbn1gKTtcbiAgICBwYWNrYWdlTWFwID0gbmV3IE1hcCgpO1xuICAgIHBhY2thZ2VDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfSk7XG59XG5jbGFzcyBOb2RlUGFja2FnZXMge1xuICBzdGF0aWMgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHBhY2thZ2VDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc3RhdGljIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHBhY2thZ2VNYXA/LmdldChuYW1lKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKSB7XG4gIGNvbnN0IGZzID0gTm9kZVBhY2thZ2VzLmdldChcImZzXCIpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodXJsKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xufVxuY2xhc3MgTm9kZUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlRmlsdGVyRmFjdG9yeSB7fVxuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IE5vZGVQYWNrYWdlcy5nZXQoXCJjYW52YXNcIik7XG4gICAgcmV0dXJuIGNhbnZhcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuY2xhc3MgTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3BhdHRlcm5faGVscGVyLmpzXG5cblxuY29uc3QgUGF0aFR5cGUgPSB7XG4gIEZJTEw6IFwiRmlsbFwiLFxuICBTVFJPS0U6IFwiU3Ryb2tlXCIsXG4gIFNIQURJTkc6IFwiU2hhZGluZ1wiXG59O1xuZnVuY3Rpb24gYXBwbHlCb3VuZGluZ0JveChjdHgsIGJib3gpIHtcbiAgaWYgKCFiYm94KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICBjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuY2xhc3MgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgZ2V0UGF0dGVybigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGF0dGVybmAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90eXBlID0gSVJbMV07XG4gICAgdGhpcy5fYmJveCA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9yU3RvcHMgPSBJUlszXTtcbiAgICB0aGlzLl9wMCA9IElSWzRdO1xuICAgIHRoaXMuX3AxID0gSVJbNV07XG4gICAgdGhpcy5fcjAgPSBJUls2XTtcbiAgICB0aGlzLl9yMSA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlR3JhZGllbnQoY3R4KSB7XG4gICAgbGV0IGdyYWQ7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiB0aGlzLl9jb2xvclN0b3BzKSB7XG4gICAgICBncmFkLmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSB8fCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuRklMTCkge1xuICAgICAgY29uc3Qgb3duZXJCQm94ID0gb3duZXIuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKG93bmVyQkJveFsyXSAtIG93bmVyQkJveFswXSkgfHwgMTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChvd25lckJCb3hbM10gLSBvd25lckJCb3hbMV0pIHx8IDE7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRtcEN0eC5yZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC50cmFuc2xhdGUoLW93bmVyQkJveFswXSwgLW93bmVyQkJveFsxXSk7XG4gICAgICBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oaW52ZXJzZSwgWzEsIDAsIDAsIDEsIG93bmVyQkJveFswXSwgb3duZXJCQm94WzFdXSk7XG4gICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgICAgYXBwbHlCb3VuZGluZ0JveCh0bXBDdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KHRtcEN0eCk7XG4gICAgICB0bXBDdHguZmlsbCgpO1xuICAgICAgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICAgICAgY29uc3QgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChpbnZlcnNlKTtcbiAgICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9jcmVhdGVHcmFkaWVudChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHAxLCBwMiwgcDMsIGMxLCBjMiwgYzMpIHtcbiAgY29uc3QgY29vcmRzID0gY29udGV4dC5jb29yZHMsXG4gICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgIHJvd1NpemUgPSBkYXRhLndpZHRoICogNDtcbiAgbGV0IHRtcDtcbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMiArIDFdID4gY29vcmRzW3AzICsgMV0pIHtcbiAgICB0bXAgPSBwMjtcbiAgICBwMiA9IHAzO1xuICAgIHAzID0gdG1wO1xuICAgIHRtcCA9IGMyO1xuICAgIGMyID0gYzM7XG4gICAgYzMgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgY29uc3QgeDEgPSAoY29vcmRzW3AxXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTEgPSAoY29vcmRzW3AxICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgyID0gKGNvb3Jkc1twMl0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkyID0gKGNvb3Jkc1twMiArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MyA9IChjb29yZHNbcDNdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MyA9IChjb29yZHNbcDMgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgaWYgKHkxID49IHkzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGMxciA9IGNvbG9yc1tjMV0sXG4gICAgYzFnID0gY29sb3JzW2MxICsgMV0sXG4gICAgYzFiID0gY29sb3JzW2MxICsgMl07XG4gIGNvbnN0IGMyciA9IGNvbG9yc1tjMl0sXG4gICAgYzJnID0gY29sb3JzW2MyICsgMV0sXG4gICAgYzJiID0gY29sb3JzW2MyICsgMl07XG4gIGNvbnN0IGMzciA9IGNvbG9yc1tjM10sXG4gICAgYzNnID0gY29sb3JzW2MzICsgMV0sXG4gICAgYzNiID0gY29sb3JzW2MzICsgMl07XG4gIGNvbnN0IG1pblkgPSBNYXRoLnJvdW5kKHkxKSxcbiAgICBtYXhZID0gTWF0aC5yb3VuZCh5Myk7XG4gIGxldCB4YSwgY2FyLCBjYWcsIGNhYjtcbiAgbGV0IHhiLCBjYnIsIGNiZywgY2JiO1xuICBmb3IgKGxldCB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICBpZiAoeSA8IHkyKSB7XG4gICAgICBjb25zdCBrID0geSA8IHkxID8gMCA6ICh5MSAtIHkpIC8gKHkxIC0geTIpO1xuICAgICAgeGEgPSB4MSAtICh4MSAtIHgyKSAqIGs7XG4gICAgICBjYXIgPSBjMXIgLSAoYzFyIC0gYzJyKSAqIGs7XG4gICAgICBjYWcgPSBjMWcgLSAoYzFnIC0gYzJnKSAqIGs7XG4gICAgICBjYWIgPSBjMWIgLSAoYzFiIC0gYzJiKSAqIGs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrO1xuICAgICAgaWYgKHkgPiB5Mykge1xuICAgICAgICBrID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MiAtIHkpIC8gKHkyIC0geTMpO1xuICAgICAgfVxuICAgICAgeGEgPSB4MiAtICh4MiAtIHgzKSAqIGs7XG4gICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIGs7XG4gICAgICBjYWcgPSBjMmcgLSAoYzJnIC0gYzNnKSAqIGs7XG4gICAgICBjYWIgPSBjMmIgLSAoYzJiIC0gYzNiKSAqIGs7XG4gICAgfVxuICAgIGxldCBrO1xuICAgIGlmICh5IDwgeTEpIHtcbiAgICAgIGsgPSAwO1xuICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICBrID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgIH1cbiAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICBjYnIgPSBjMXIgLSAoYzFyIC0gYzNyKSAqIGs7XG4gICAgY2JnID0gYzFnIC0gKGMxZyAtIGMzZykgKiBrO1xuICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICBjb25zdCB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgIGNvbnN0IHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgbGV0IGogPSByb3dTaXplICogeSArIHgxXyAqIDQ7XG4gICAgZm9yIChsZXQgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgayA9ICh4YSAtIHgpIC8gKHhhIC0geGIpO1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICBrID0gMTtcbiAgICAgIH1cbiAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhZyAtIChjYWcgLSBjYmcpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FiIC0gKGNhYiAtIGNiYikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCkge1xuICBjb25zdCBwcyA9IGZpZ3VyZS5jb29yZHM7XG4gIGNvbnN0IGNzID0gZmlndXJlLmNvbG9ycztcbiAgbGV0IGksIGlpO1xuICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgIGNvbnN0IHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgIGNvbnN0IGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIGxldCBxID0gaSAqIHZlcnRpY2VzUGVyUm93O1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKywgcSsrKSB7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3FdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3FdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txICsgdmVydGljZXNQZXJSb3cgKyAxXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRyaWFuZ2xlc1wiOlxuICAgICAgZm9yIChpID0gMCwgaWkgPSBwcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1tpXSwgcHNbaSArIDFdLCBwc1tpICsgMl0sIGNzW2ldLCBjc1tpICsgMV0sIGNzW2kgKyAyXSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gIH1cbn1cbmNsYXNzIE1lc2hTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb29yZHMgPSBJUlsyXTtcbiAgICB0aGlzLl9jb2xvcnMgPSBJUlszXTtcbiAgICB0aGlzLl9maWd1cmVzID0gSVJbNF07XG4gICAgdGhpcy5fYm91bmRzID0gSVJbNV07XG4gICAgdGhpcy5fYmJveCA9IElSWzddO1xuICAgIHRoaXMuX2JhY2tncm91bmQgPSBJUls4XTtcbiAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZU1lc2hDYW52YXMoY29tYmluZWRTY2FsZSwgYmFja2dyb3VuZENvbG9yLCBjYWNoZWRDYW52YXNlcykge1xuICAgIGNvbnN0IEVYUEVDVEVEX1NDQUxFID0gMS4xO1xuICAgIGNvbnN0IE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKHRoaXMuX2JvdW5kc1sxXSk7XG4gICAgY29uc3QgYm91bmRzV2lkdGggPSBNYXRoLmNlaWwodGhpcy5fYm91bmRzWzJdKSAtIG9mZnNldFg7XG4gICAgY29uc3QgYm91bmRzSGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1szXSkgLSBvZmZzZXRZO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc1dpZHRoICogY29tYmluZWRTY2FsZVswXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNIZWlnaHQgKiBjb21iaW5lZFNjYWxlWzFdICogRVhQRUNURURfU0NBTEUpKSwgTUFYX1BBVFRFUk5fU0laRSk7XG4gICAgY29uc3Qgc2NhbGVYID0gYm91bmRzV2lkdGggLyB3aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBib3VuZHNIZWlnaHQgLyBoZWlnaHQ7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGNvb3JkczogdGhpcy5fY29vcmRzLFxuICAgICAgY29sb3JzOiB0aGlzLl9jb2xvcnMsXG4gICAgICBvZmZzZXRYOiAtb2Zmc2V0WCxcbiAgICAgIG9mZnNldFk6IC1vZmZzZXRZLFxuICAgICAgc2NhbGVYOiAxIC8gc2NhbGVYLFxuICAgICAgc2NhbGVZOiAxIC8gc2NhbGVZXG4gICAgfTtcbiAgICBjb25zdCBwYWRkZWRXaWR0aCA9IHdpZHRoICsgQk9SREVSX1NJWkUgKiAyO1xuICAgIGNvbnN0IHBhZGRlZEhlaWdodCA9IGhlaWdodCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBjYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtZXNoXCIsIHBhZGRlZFdpZHRoLCBwYWRkZWRIZWlnaHQpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgYnl0ZXNbaSArIDFdID0gYmFja2dyb3VuZENvbG9yWzFdO1xuICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBmaWd1cmUgb2YgdGhpcy5fZmlndXJlcykge1xuICAgICAgZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpO1xuICAgIH1cbiAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgY29uc3QgY2FudmFzID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgb2Zmc2V0WDogb2Zmc2V0WCAtIEJPUkRFUl9TSVpFICogc2NhbGVYLFxuICAgICAgb2Zmc2V0WTogb2Zmc2V0WSAtIEJPUkRFUl9TSVpFICogc2NhbGVZLFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZXG4gICAgfTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgIGxldCBzY2FsZTtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIHNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUob3duZXIuYmFzZVRyYW5zZm9ybSk7XG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY29uc3QgbWF0cml4U2NhbGUgPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcbiAgICAgICAgc2NhbGUgPSBbc2NhbGVbMF0gKiBtYXRyaXhTY2FsZVswXSwgc2NhbGVbMV0gKiBtYXRyaXhTY2FsZVsxXV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLl9jcmVhdGVNZXNoQ2FudmFzKHNjYWxlLCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORyA/IG51bGwgOiB0aGlzLl9iYWNrZ3JvdW5kLCBvd25lci5jYWNoZWRDYW52YXNlcyk7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBjdHguc2NhbGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICB9XG59XG5jbGFzcyBEdW1teVNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgZ2V0UGF0dGVybigpIHtcbiAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuKElSKSB7XG4gIHN3aXRjaCAoSVJbMF0pIHtcbiAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgIHJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgIHJldHVybiBuZXcgTWVzaFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgIHJldHVybiBuZXcgRHVtbXlTaGFkaW5nUGF0dGVybigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke0lSWzBdfWApO1xufVxuY29uc3QgUGFpbnRUeXBlID0ge1xuICBDT0xPUkVEOiAxLFxuICBVTkNPTE9SRUQ6IDJcbn07XG5jbGFzcyBUaWxpbmdQYXR0ZXJuIHtcbiAgc3RhdGljIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICBjb25zdHJ1Y3RvcihJUiwgY29sb3IsIGN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKSB7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBJUlsyXTtcbiAgICB0aGlzLm1hdHJpeCA9IElSWzNdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jYW52YXNHcmFwaGljc0ZhY3RvcnkgPSBjYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gYmFzZVRyYW5zZm9ybTtcbiAgfVxuICBjcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmJveCxcbiAgICAgIG9wZXJhdG9yTGlzdCxcbiAgICAgIHBhaW50VHlwZSxcbiAgICAgIHRpbGluZ1R5cGUsXG4gICAgICBjb2xvcixcbiAgICAgIGNhbnZhc0dyYXBoaWNzRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB4c3RlcCxcbiAgICAgIHlzdGVwXG4gICAgfSA9IHRoaXM7XG4gICAgeHN0ZXAgPSBNYXRoLmFicyh4c3RlcCk7XG4gICAgeXN0ZXAgPSBNYXRoLmFicyh5c3RlcCk7XG4gICAgaW5mbyhcIlRpbGluZ1R5cGU6IFwiICsgdGlsaW5nVHlwZSk7XG4gICAgY29uc3QgeDAgPSBiYm94WzBdLFxuICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgeTEgPSBiYm94WzNdO1xuICAgIGNvbnN0IHdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBoZWlnaHQgPSB5MSAtIHkwO1xuICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG4gICAgY29uc3QgY3VyTWF0cml4U2NhbGUgPSBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVggPSBtYXRyaXhTY2FsZVswXSAqIGN1ck1hdHJpeFNjYWxlWzBdO1xuICAgIGNvbnN0IGNvbWJpbmVkU2NhbGVZID0gbWF0cml4U2NhbGVbMV0gKiBjdXJNYXRyaXhTY2FsZVsxXTtcbiAgICBsZXQgY2FudmFzV2lkdGggPSB3aWR0aCxcbiAgICAgIGNhbnZhc0hlaWdodCA9IGhlaWdodCxcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IGZhbHNlLFxuICAgICAgcmVkcmF3VmVydGljYWxseSA9IGZhbHNlO1xuICAgIGNvbnN0IHhTY2FsZWRTdGVwID0gTWF0aC5jZWlsKHhzdGVwICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRTdGVwID0gTWF0aC5jZWlsKHlzdGVwICogY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHhTY2FsZWRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIGNvbWJpbmVkU2NhbGVYKTtcbiAgICBjb25zdCB5U2NhbGVkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIGNvbWJpbmVkU2NhbGVZKTtcbiAgICBpZiAoeFNjYWxlZFN0ZXAgPj0geFNjYWxlZFdpZHRoKSB7XG4gICAgICBjYW52YXNXaWR0aCA9IHhzdGVwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWRyYXdIb3Jpem9udGFsbHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoeVNjYWxlZFN0ZXAgPj0geVNjYWxlZEhlaWdodCkge1xuICAgICAgY2FudmFzSGVpZ2h0ID0geXN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd1ZlcnRpY2FsbHkgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBkaW14ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzV2lkdGgsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IGRpbXkgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNIZWlnaHQsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVZKTtcbiAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIGRpbXguc2l6ZSwgZGlteS5zaXplKTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBncmFwaGljcyA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeS5jcmVhdGVDYW52YXNHcmFwaGljcyh0bXBDdHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICB0bXBDdHgudHJhbnNsYXRlKC1kaW14LnNjYWxlICogeDAsIC1kaW15LnNjYWxlICogeTApO1xuICAgIGdyYXBoaWNzLnRyYW5zZm9ybShkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICB0bXBDdHguc2F2ZSgpO1xuICAgIHRoaXMuY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICBncmFwaGljcy5iYXNlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShncmFwaGljcy5jdHgpO1xuICAgIGdyYXBoaWNzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICBncmFwaGljcy5lbmREcmF3aW5nKCk7XG4gICAgdG1wQ3R4LnJlc3RvcmUoKTtcbiAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5IHx8IHJlZHJhd1ZlcnRpY2FsbHkpIHtcbiAgICAgIGNvbnN0IGltYWdlID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgIGlmIChyZWRyYXdIb3Jpem9udGFsbHkpIHtcbiAgICAgICAgY2FudmFzV2lkdGggPSB4c3RlcDtcbiAgICAgIH1cbiAgICAgIGlmIChyZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICAgIGNhbnZhc0hlaWdodCA9IHlzdGVwO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlteDIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgICBjb25zdCBkaW15MiA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgICAgY29uc3QgeFNpemUgPSBkaW14Mi5zaXplO1xuICAgICAgY29uc3QgeVNpemUgPSBkaW15Mi5zaXplO1xuICAgICAgY29uc3QgdG1wQ2FudmFzMiA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm4td29ya2Fyb3VuZFwiLCB4U2l6ZSwgeVNpemUpO1xuICAgICAgY29uc3QgdG1wQ3R4MiA9IHRtcENhbnZhczIuY29udGV4dDtcbiAgICAgIGNvbnN0IGlpID0gcmVkcmF3SG9yaXpvbnRhbGx5ID8gTWF0aC5mbG9vcih3aWR0aCAvIHhzdGVwKSA6IDA7XG4gICAgICBjb25zdCBqaiA9IHJlZHJhd1ZlcnRpY2FsbHkgPyBNYXRoLmZsb29yKGhlaWdodCAvIHlzdGVwKSA6IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpaTsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDw9IGpqOyBqKyspIHtcbiAgICAgICAgICB0bXBDdHgyLmRyYXdJbWFnZShpbWFnZSwgeFNpemUgKiBpLCB5U2l6ZSAqIGosIHhTaXplLCB5U2l6ZSwgMCwgMCwgeFNpemUsIHlTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzOiB0bXBDYW52YXMyLmNhbnZhcyxcbiAgICAgICAgc2NhbGVYOiBkaW14Mi5zY2FsZSxcbiAgICAgICAgc2NhbGVZOiBkaW15Mi5zY2FsZSxcbiAgICAgICAgb2Zmc2V0WDogeDAsXG4gICAgICAgIG9mZnNldFk6IHkwXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiB0bXBDYW52YXMuY2FudmFzLFxuICAgICAgc2NhbGVYOiBkaW14LnNjYWxlLFxuICAgICAgc2NhbGVZOiBkaW15LnNjYWxlLFxuICAgICAgb2Zmc2V0WDogeDAsXG4gICAgICBvZmZzZXRZOiB5MFxuICAgIH07XG4gIH1cbiAgZ2V0U2l6ZUFuZFNjYWxlKHN0ZXAsIHJlYWxPdXRwdXRTaXplLCBzY2FsZSkge1xuICAgIGNvbnN0IG1heFNpemUgPSBNYXRoLm1heChUaWxpbmdQYXR0ZXJuLk1BWF9QQVRURVJOX1NJWkUsIHJlYWxPdXRwdXRTaXplKTtcbiAgICBsZXQgc2l6ZSA9IE1hdGguY2VpbChzdGVwICogc2NhbGUpO1xuICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgIHNpemUgPSBtYXhTaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IHNpemUgLyBzdGVwO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBjbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICBjb25zdCBiYm94V2lkdGggPSB4MSAtIHgwO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5MSAtIHkwO1xuICAgIGdyYXBoaWNzLmN0eC5yZWN0KHgwLCB5MCwgYmJveFdpZHRoLCBiYm94SGVpZ2h0KTtcbiAgICBncmFwaGljcy5jdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoZ2V0Q3VycmVudFRyYW5zZm9ybShncmFwaGljcy5jdHgpLCBbeDAsIHkwLCB4MSwgeTFdKTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICBjdXJyZW50ID0gZ3JhcGhpY3MuY3VycmVudDtcbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFpbnRUeXBlLlVOQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3NzQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwYWludCB0eXBlOiAke3BhaW50VHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBtYXRyaXggPSBpbnZlcnNlO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgbWF0cml4ID0gVXRpbC50cmFuc2Zvcm0obWF0cml4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcik7XG4gICAgbGV0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgobWF0cml4KTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXguc2NhbGUoMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCAxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJyZXBlYXRcIik7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL2ltYWdlX3V0aWxzLmpzXG5cbmZ1bmN0aW9uIGNvbnZlcnRUb1JHQkEocGFyYW1zKSB7XG4gIHN3aXRjaCAocGFyYW1zLmtpbmQpIHtcbiAgICBjYXNlIEltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQShwYXJhbXMpO1xuICAgIGNhc2UgSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgIHJldHVybiBjb252ZXJ0UkdCVG9SR0JBKHBhcmFtcyk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgd2lkdGgsXG4gIGhlaWdodCxcbiAgbm9uQmxhY2tDb2xvciA9IDB4ZmZmZmZmZmYsXG4gIGludmVyc2VEZWNvZGUgPSBmYWxzZVxufSkge1xuICBjb25zdCBibGFjayA9IHV0aWxfRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgY29uc3QgW3plcm9NYXBwaW5nLCBvbmVNYXBwaW5nXSA9IGludmVyc2VEZWNvZGUgPyBbbm9uQmxhY2tDb2xvciwgYmxhY2tdIDogW2JsYWNrLCBub25CbGFja0NvbG9yXTtcbiAgY29uc3Qgd2lkdGhJblNvdXJjZSA9IHdpZHRoID4+IDM7XG4gIGNvbnN0IHdpZHRoUmVtYWluZGVyID0gd2lkdGggJiA3O1xuICBjb25zdCBzcmNMZW5ndGggPSBzcmMubGVuZ3RoO1xuICBkZXN0ID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgbGV0IGRlc3RQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgZm9yIChjb25zdCBtYXggPSBzcmNQb3MgKyB3aWR0aEluU291cmNlOyBzcmNQb3MgPCBtYXg7IHNyY1BvcysrKSB7XG4gICAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1Bvc10gOiAyNTU7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICAgIGlmICh3aWR0aFJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zKytdIDogMjU1O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGhSZW1haW5kZXI7IGorKykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDEgPDwgNyAtIGogPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSR0JUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIGRlc3RQb3MgPSAwLFxuICB3aWR0aCxcbiAgaGVpZ2h0XG59KSB7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuMzIgPSBzcmMubGVuZ3RoID4+IDI7XG4gIGNvbnN0IHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIsIHNyY1BvcywgbGVuMzIpO1xuICBpZiAoRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPj4+IDI0IHwgczIgPDwgOCB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyID4+PiAxNiB8IHMzIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPj4+IDggfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjLmxlbmd0aDsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSB8IHNyY1tqICsgMV0gPDwgOCB8IHNyY1tqICsgMl0gPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPDwgMjQgfCBzMiA+Pj4gOCB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyIDw8IDE2IHwgczMgPj4+IDE2IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPDwgOCB8IDB4ZmY7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmMubGVuZ3RoOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIDw8IDI0IHwgc3JjW2ogKyAxXSA8PCAxNiB8IHNyY1tqICsgMl0gPDwgOCB8IDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyYXlUb1JHQkEoc3JjLCBkZXN0KSB7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMSB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMTAwIHwgMHgwMDAwMDBmZjtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzLmpzXG5cblxuXG5cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBNQVhfU0laRV9UT19DT01QSUxFID0gMTAwMDtcbmNvbnN0IEZVTExfQ0hVTktfSEVJR0hUID0gMTY7XG5mdW5jdGlvbiBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIGRlc3RDdHgpIHtcbiAgaWYgKGN0eC5fcmVtb3ZlTWlycm9yaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dCBpcyBhbHJlYWR5IGZvcndhcmRpbmcgb3BlcmF0aW9ucy5cIik7XG4gIH1cbiAgY3R4Ll9fb3JpZ2luYWxTYXZlID0gY3R4LnNhdmU7XG4gIGN0eC5fX29yaWdpbmFsUmVzdG9yZSA9IGN0eC5yZXN0b3JlO1xuICBjdHguX19vcmlnaW5hbFJvdGF0ZSA9IGN0eC5yb3RhdGU7XG4gIGN0eC5fX29yaWdpbmFsU2NhbGUgPSBjdHguc2NhbGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlID0gY3R4LnRyYW5zbGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm0gPSBjdHgudHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybSA9IGN0eC5zZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0gPSBjdHgucmVzZXRUcmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsQ2xpcCA9IGN0eC5jbGlwO1xuICBjdHguX19vcmlnaW5hbE1vdmVUbyA9IGN0eC5tb3ZlVG87XG4gIGN0eC5fX29yaWdpbmFsTGluZVRvID0gY3R4LmxpbmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvID0gY3R4LmJlemllckN1cnZlVG87XG4gIGN0eC5fX29yaWdpbmFsUmVjdCA9IGN0eC5yZWN0O1xuICBjdHguX19vcmlnaW5hbENsb3NlUGF0aCA9IGN0eC5jbG9zZVBhdGg7XG4gIGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoID0gY3R4LmJlZ2luUGF0aDtcbiAgY3R4Ll9yZW1vdmVNaXJyb3JpbmcgPSAoKSA9PiB7XG4gICAgY3R4LnNhdmUgPSBjdHguX19vcmlnaW5hbFNhdmU7XG4gICAgY3R4LnJlc3RvcmUgPSBjdHguX19vcmlnaW5hbFJlc3RvcmU7XG4gICAgY3R4LnJvdGF0ZSA9IGN0eC5fX29yaWdpbmFsUm90YXRlO1xuICAgIGN0eC5zY2FsZSA9IGN0eC5fX29yaWdpbmFsU2NhbGU7XG4gICAgY3R4LnRyYW5zbGF0ZSA9IGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlO1xuICAgIGN0eC50cmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFRyYW5zZm9ybTtcbiAgICBjdHguc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm07XG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybTtcbiAgICBjdHguY2xpcCA9IGN0eC5fX29yaWdpbmFsQ2xpcDtcbiAgICBjdHgubW92ZVRvID0gY3R4Ll9fb3JpZ2luYWxNb3ZlVG87XG4gICAgY3R4LmxpbmVUbyA9IGN0eC5fX29yaWdpbmFsTGluZVRvO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvID0gY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvO1xuICAgIGN0eC5yZWN0ID0gY3R4Ll9fb3JpZ2luYWxSZWN0O1xuICAgIGN0eC5jbG9zZVBhdGggPSBjdHguX19vcmlnaW5hbENsb3NlUGF0aDtcbiAgICBjdHguYmVnaW5QYXRoID0gY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGg7XG4gICAgZGVsZXRlIGN0eC5fcmVtb3ZlTWlycm9yaW5nO1xuICB9O1xuICBjdHguc2F2ZSA9IGZ1bmN0aW9uIGN0eFNhdmUoKSB7XG4gICAgZGVzdEN0eC5zYXZlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsU2F2ZSgpO1xuICB9O1xuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uIGN0eFJlc3RvcmUoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24gY3R4VHJhbnNsYXRlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG4gIGN0eC5zY2FsZSA9IGZ1bmN0aW9uIGN0eFNjYWxlKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnNjYWxlKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICB9O1xuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGRlc3RDdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4UmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgZGVzdEN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtKCk7XG4gIH07XG4gIGN0eC5yb3RhdGUgPSBmdW5jdGlvbiBjdHhSb3RhdGUoYW5nbGUpIHtcbiAgICBkZXN0Q3R4LnJvdGF0ZShhbmdsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsUm90YXRlKGFuZ2xlKTtcbiAgfTtcbiAgY3R4LmNsaXAgPSBmdW5jdGlvbiBjdHhSb3RhdGUocnVsZSkge1xuICAgIGRlc3RDdHguY2xpcChydWxlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbGlwKHJ1bGUpO1xuICB9O1xuICBjdHgubW92ZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNb3ZlVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubGluZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbExpbmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmJlemllckN1cnZlVG8gPSBmdW5jdGlvbiAoY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSkge1xuICAgIGRlc3RDdHguYmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICB9O1xuICBjdHgucmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgZGVzdEN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gIH07XG4gIGN0eC5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxDbG9zZVBhdGgoKTtcbiAgfTtcbiAgY3R4LmJlZ2luUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlZ2luUGF0aCgpO1xuICB9O1xufVxuY2xhc3MgQ2FjaGVkQ2FudmFzZXMge1xuICBjb25zdHJ1Y3RvcihjYW52YXNGYWN0b3J5KSB7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBnZXRDYW52YXMoaWQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgY2FudmFzRW50cnk7XG4gICAgaWYgKHRoaXMuY2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkucmVzZXQoY2FudmFzRW50cnksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IGNhbnZhc0VudHJ5O1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzRW50cnk7XG4gIH1cbiAgZGVsZXRlKGlkKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgY29uc3QgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5kZXN0cm95KGNhbnZhc0VudHJ5KTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpIHtcbiAgY29uc3QgW2EsIGIsIGMsIGQsIHR4LCB0eV0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WCAqIGEgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RZICogZCArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RYICsgZGVzdFcpICogYSArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RZICsgZGVzdEgpICogZCArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oTWF0aC5zaWduKGEpLCAwLCAwLCBNYXRoLnNpZ24oZCksIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCByV2lkdGgsIHJIZWlnaHQpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JXaWR0aCwgckhlaWdodF07XG4gIH1cbiAgaWYgKGEgPT09IDAgJiYgZCA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RZICogYyArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFggKiBiICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFkgKyBkZXN0SCkgKiBjICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFggKyBkZXN0VykgKiBiICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgwLCBNYXRoLnNpZ24oYiksIE1hdGguc2lnbihjKSwgMCwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJIZWlnaHQsIHJXaWR0aCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbckhlaWdodCwgcldpZHRoXTtcbiAgfVxuICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpO1xuICBjb25zdCBzY2FsZVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICBjb25zdCBzY2FsZVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICByZXR1cm4gW3NjYWxlWCAqIGRlc3RXLCBzY2FsZVkgKiBkZXN0SF07XG59XG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGltZ0RhdGE7XG4gIGlmICh3aWR0aCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUgfHwgaGVpZ2h0ID4gTUFYX1NJWkVfVE9fQ09NUElMRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFBPSU5UX1RPX1BST0NFU1NfTElNSVQgPSAxMDAwO1xuICBjb25zdCBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICBjb25zdCB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIGxldCBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICBsZXQgaSwgaiwgajA7XG4gIGNvbnN0IGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjc7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpLFxuICAgIHBvcyA9IDA7XG4gIGZvciAoY29uc3QgZWxlbSBvZiBpbWdEYXRhLmRhdGEpIHtcbiAgICBsZXQgbWFzayA9IDEyODtcbiAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgIGRhdGFbcG9zKytdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgcG9zID0gMDtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1swXSA9IDE7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqXSA9IGRhdGFbcG9zXSA/IDIgOiAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqXSA9IDI7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGkgPSAxOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBwb3MgPSBpICogbGluZVNpemU7XG4gICAgajAgPSBpICogd2lkdGgxO1xuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBsZXQgc3VtID0gKGRhdGFbcG9zXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplXSA/IDggOiAwKTtcbiAgICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgc3VtID0gKHN1bSA+PiAyKSArIChkYXRhW3BvcyArIDFdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemUgKyAxXSA/IDggOiAwKTtcbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICAgIHBvcysrO1xuICAgIH1cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyAyIDogNDtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwb3MgPSBsaW5lU2l6ZSAqIChoZWlnaHQgLSAxKTtcbiAgajAgPSBpICogd2lkdGgxO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owXSA9IDg7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owICsgal0gPSA0O1xuICAgICsrY291bnQ7XG4gIH1cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIGxldCBwID0gaSAqIHdpZHRoMTtcbiAgICBjb25zdCBlbmQgPSBwICsgd2lkdGg7XG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cbiAgICBpZiAocCA9PT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aC5tb3ZlVG8ocCAlIHdpZHRoMSwgaSk7XG4gICAgY29uc3QgcDAgPSBwO1xuICAgIGxldCB0eXBlID0gcG9pbnRzW3BdO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1t0eXBlXTtcbiAgICAgIGRvIHtcbiAgICAgICAgcCArPSBzdGVwO1xuICAgICAgfSB3aGlsZSAoIXBvaW50c1twXSk7XG4gICAgICBjb25zdCBwcCA9IHBvaW50c1twXTtcbiAgICAgIGlmIChwcCAhPT0gNSAmJiBwcCAhPT0gMTApIHtcbiAgICAgICAgdHlwZSA9IHBwO1xuICAgICAgICBwb2ludHNbcF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHBwICYgMHgzMyAqIHR5cGUgPj4gNDtcbiAgICAgICAgcG9pbnRzW3BdICY9IHR5cGUgPj4gMiB8IHR5cGUgPDwgMjtcbiAgICAgIH1cbiAgICAgIHBhdGgubGluZVRvKHAgJSB3aWR0aDEsIHAgLyB3aWR0aDEgfCAwKTtcbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuICAgIC0taTtcbiAgfVxuICBkYXRhID0gbnVsbDtcbiAgcG9pbnRzID0gbnVsbDtcbiAgY29uc3QgZHJhd091dGxpbmUgPSBmdW5jdGlvbiAoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5maWxsKHBhdGgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5hbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLmZvbnRTaXplU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dE1hdHJpeCA9IElERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250TWF0cml4ID0gRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRSaXNlID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIHVwZGF0ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgW3gsIHldID0gVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuICB1cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgcmVjdCkge1xuICAgIGNvbnN0IHAxID0gVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAyID0gVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LnNsaWNlKDIpLCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAzID0gVXRpbC5hcHBseVRyYW5zZm9ybShbcmVjdFswXSwgcmVjdFszXV0sIHRyYW5zZm9ybSk7XG4gICAgY29uc3QgcDQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzFdXSwgdHJhbnNmb3JtKTtcbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKTtcbiAgfVxuICB1cGRhdGVTY2FsaW5nUGF0aE1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIFV0aWwuc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgbWluTWF4WzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIG1pbk1heFsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBtaW5NYXhbMl0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgbWluTWF4WzNdKTtcbiAgfVxuICB1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGNvbnN0IGJveCA9IFV0aWwuYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpO1xuICAgIGlmIChtaW5NYXgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgYm94KTtcbiAgfVxuICBnZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBQYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgY29uc3QgYm94ID0gW3RoaXMubWluWCwgdGhpcy5taW5ZLCB0aGlzLm1heFgsIHRoaXMubWF4WV07XG4gICAgaWYgKHBhdGhUeXBlID09PSBQYXRoVHlwZS5TVFJPS0UpIHtcbiAgICAgIGlmICghdHJhbnNmb3JtKSB7XG4gICAgICAgIHVucmVhY2hhYmxlKFwiU3Ryb2tlIGJvdW5kaW5nIGJveCBtdXN0IGluY2x1ZGUgdHJhbnNmb3JtLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IHNjYWxlWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IHNjYWxlWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pblggPT09IEluZmluaXR5O1xuICB9XG4gIHN0YXJ0TmV3UGF0aEFuZENsaXBCb3goYm94KSB7XG4gICAgdGhpcy5jbGlwQm94ID0gYm94O1xuICAgIHRoaXMubWluWCA9IEluZmluaXR5O1xuICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgIHRoaXMubWF4WCA9IDA7XG4gICAgdGhpcy5tYXhZID0gMDtcbiAgfVxuICBnZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlID0gUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIHJldHVybiBVdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCB0cmFuc2Zvcm0pKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VEYXRhKGN0eCwgaW1nRGF0YSkge1xuICBpZiAodHlwZW9mIEltYWdlRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwLFxuICAgIGRlc3RQb3M7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuICBsZXQgaSwgaiwgdGhpc0NodW5rSGVpZ2h0LCBlbGVtc0luVGhpc0NodW5rO1xuICBpZiAoaW1nRGF0YS5raW5kID09PSB1dGlsX0ltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCkge1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGRlc3QzMiA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlciwgMCwgZGVzdC5ieXRlTGVuZ3RoID4+IDIpO1xuICAgIGNvbnN0IGRlc3QzMkRhdGFMZW5ndGggPSBkZXN0MzIubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxTcmNEaWZmID0gd2lkdGggKyA3ID4+IDM7XG4gICAgY29uc3Qgd2hpdGUgPSAweGZmZmZmZmZmO1xuICAgIGNvbnN0IGJsYWNrID0gdXRpbF9GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdGhpc0NodW5rSGVpZ2h0OyBqKyspIHtcbiAgICAgICAgY29uc3Qgc3JjRGlmZiA9IHNyY0xlbmd0aCAtIHNyY1BvcztcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBjb25zdCBrRW5kID0gc3JjRGlmZiA+IGZ1bGxTcmNEaWZmID8gd2lkdGggOiBzcmNEaWZmICogOCAtIDc7XG4gICAgICAgIGNvbnN0IGtFbmRVbnJvbGxlZCA9IGtFbmQgJiB+NztcbiAgICAgICAgbGV0IG1hc2sgPSAwO1xuICAgICAgICBsZXQgc3JjQnl0ZSA9IDA7XG4gICAgICAgIGZvciAoOyBrIDwga0VuZFVucm9sbGVkOyBrICs9IDgpIHtcbiAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxMjggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDY0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAzMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTYgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBrIDwga0VuZDsgaysrKSB7XG4gICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgbWFzayA9IDEyODtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgbWFzayA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgbWFzayA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKGRlc3RQb3MgPCBkZXN0MzJEYXRhTGVuZ3RoKSB7XG4gICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gMDtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLlJHQkFfMzJCUFApIHtcbiAgICBqID0gMDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBGVUxMX0NIVU5LX0hFSUdIVCAqIDQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaHVua3M7IGkrKykge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgc3JjUG9zICs9IGVsZW1zSW5UaGlzQ2h1bms7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgICBqICs9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIH1cbiAgICBpZiAoaSA8IHRvdGFsQ2h1bmtzKSB7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBwYXJ0aWFsQ2h1bmtIZWlnaHQgKiA0O1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgIHRoaXNDaHVua0hlaWdodCA9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgaWYgKGkgPj0gZnVsbENodW5rcykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSAyNTU7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgaW1hZ2Uga2luZDogJHtpbWdEYXRhLmtpbmR9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlTWFzayhjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgY3R4LmRyYXdJbWFnZShpbWdEYXRhLmJpdG1hcCwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMDtcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgIGNvbnN0IHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgKHtcbiAgICAgIHNyY1Bvc1xuICAgIH0gPSBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQSh7XG4gICAgICBzcmMsXG4gICAgICBzcmNQb3MsXG4gICAgICBkZXN0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXNDaHVua0hlaWdodCxcbiAgICAgIG5vbkJsYWNrQ29sb3I6IDBcbiAgICB9KSk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlDdHhTdGF0ZShzb3VyY2VDdHgsIGRlc3RDdHgpIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IFtcInN0cm9rZVN0eWxlXCIsIFwiZmlsbFN0eWxlXCIsIFwiZmlsbFJ1bGVcIiwgXCJnbG9iYWxBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJmb250XCIsIFwiZmlsdGVyXCJdO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoc291cmNlQ3R4W3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0Q3R4W3Byb3BlcnR5XSA9IHNvdXJjZUN0eFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3RDdHguc2V0TGluZURhc2goc291cmNlQ3R4LmdldExpbmVEYXNoKCkpO1xuICAgIGRlc3RDdHgubGluZURhc2hPZmZzZXQgPSBzb3VyY2VDdHgubGluZURhc2hPZmZzZXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0Q3R4VG9EZWZhdWx0KGN0eCkge1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gXCIjMDAwMDAwXCI7XG4gIGN0eC5maWxsUnVsZSA9IFwibm9uemVyb1wiO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICBjdHgubGluZVdpZHRoID0gMTtcbiAgY3R4LmxpbmVDYXAgPSBcImJ1dHRcIjtcbiAgY3R4LmxpbmVKb2luID0gXCJtaXRlclwiO1xuICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICBjdHguZm9udCA9IFwiMTBweCBzYW5zLXNlcmlmXCI7XG4gIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgfVxuICBpZiAoIWlzTm9kZUpTKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVyXG4gICAgfSA9IGN0eDtcbiAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCh0cmFuc2Zvcm0sIGludGVycG9sYXRlKSB7XG4gIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHNjYWxlID0gVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICBzY2FsZVswXSA9IE1hdGguZnJvdW5kKHNjYWxlWzBdKTtcbiAgc2NhbGVbMV0gPSBNYXRoLmZyb3VuZChzY2FsZVsxXSk7XG4gIGNvbnN0IGFjdHVhbFNjYWxlID0gTWF0aC5mcm91bmQoKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAqIFBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gIHJldHVybiBzY2FsZVswXSA8PSBhY3R1YWxTY2FsZSAmJiBzY2FsZVsxXSA8PSBhY3R1YWxTY2FsZTtcbn1cbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBOT1JNQUxfQ0xJUCA9IHt9O1xuY29uc3QgRU9fQ0xJUCA9IHt9O1xuY2xhc3MgQ2FudmFzR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3RvcihjYW52YXNDdHgsIGNvbW1vbk9ianMsIG9ianMsIGNhbnZhc0ZhY3RvcnksIGZpbHRlckZhY3RvcnksIHtcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgbWFya2VkQ29udGVudFN0YWNrID0gbnVsbFxuICB9LCBhbm5vdGF0aW9uQ2FudmFzTWFwLCBwYWdlQ29sb3JzKSB7XG4gICAgdGhpcy5jdHggPSBjYW52YXNDdHg7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgdGhpcy54b2JqcyA9IG51bGw7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmdyb3VwU3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sgPSBtYXJrZWRDb250ZW50U3RhY2sgfHwgW107XG4gICAgdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcgPSBvcHRpb25hbENvbnRlbnRDb25maWc7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcyA9IG5ldyBDYWNoZWRDYW52YXNlcyh0aGlzLmNhbnZhc0ZhY3RvcnkpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVYID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWSA9IDE7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gWy0xLCAwXTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldE9iamVjdChkYXRhLCBmYWxsYmFjayA9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGF0YSkgOiB0aGlzLm9ianMuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgYmVnaW5EcmF3aW5nKHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld3BvcnQsXG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgYmFja2dyb3VuZCA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRGaWxsU3R5bGUgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcIiNmZmZmZmZcIjtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzYXZlZEZpbGxTdHlsZTtcbiAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNvbXBvc2l0ZUN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi5nZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY29tcG9zaXRlQ3R4KSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWCA9IHRyYW5zZm9ybVswXTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVZID0gdHJhbnNmb3JtWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSB2aWV3cG9ydC5zY2FsZTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgfVxuICBleGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIpIHtcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBsZXQgaSA9IGV4ZWN1dGlvblN0YXJ0SWR4IHx8IDA7XG4gICAgY29uc3QgYXJnc0FycmF5TGVuID0gYXJnc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtPcGVyYXRpb25zID0gYXJnc0FycmF5TGVuIC0gaSA+IEVYRUNVVElPTl9TVEVQUyAmJiB0eXBlb2YgY29udGludWVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBjaHVua09wZXJhdGlvbnMgPyBEYXRlLm5vdygpICsgRVhFQ1VUSU9OX1RJTUUgOiAwO1xuICAgIGxldCBzdGVwcyA9IDA7XG4gICAgY29uc3QgY29tbW9uT2JqcyA9IHRoaXMuY29tbW9uT2JqcztcbiAgICBjb25zdCBvYmpzID0gdGhpcy5vYmpzO1xuICAgIGxldCBmbklkO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoc3RlcHBlciAhPT0gdW5kZWZpbmVkICYmIGkgPT09IHN0ZXBwZXIubmV4dEJyZWFrUG9pbnQpIHtcbiAgICAgICAgc3RlcHBlci5icmVha0l0KGksIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgaWYgKGZuSWQgIT09IE9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgIHRoaXNbZm5JZF0uYXBwbHkodGhpcywgYXJnc0FycmF5W2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwT2JqSWQgb2YgYXJnc0FycmF5W2ldKSB7XG4gICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcbiAgICAgICAgICBpZiAoIW9ianNQb29sLmhhcyhkZXBPYmpJZCkpIHtcbiAgICAgICAgICAgIG9ianNQb29sLmdldChkZXBPYmpJZCwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIGlmIChpID09PSBhcmdzQXJyYXlMZW4pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgY29udGludWVDYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3Jlc3RvcmVJbml0aWFsU3RhdGUoKSB7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggfHwgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zcGFyZW50Q2FudmFzKSB7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY29tcG9zaXRlQ3R4O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudHJhbnNwYXJlbnRDYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmcoKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhbnZhcyBvZiBjYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuY2xlYXIoKTtcbiAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gIH1cbiAgI2RyYXdGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucGFnZUNvbG9ycykge1xuICAgICAgY29uc3QgaGNtRmlsdGVySWQgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMucGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLnBhZ2VDb2xvcnMuYmFja2dyb3VuZCk7XG4gICAgICBpZiAoaGNtRmlsdGVySWQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkRmlsdGVyID0gdGhpcy5jdHguZmlsdGVyO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBoY21GaWx0ZXJJZDtcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHNhdmVkRmlsdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2NhbGVJbWFnZShpbWcsIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy53aWR0aCA/PyBpbWcuZGlzcGxheVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZy5oZWlnaHQgPz8gaW1nLmRpc3BsYXlIZWlnaHQ7XG4gICAgbGV0IHdpZHRoU2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMF0sIGludmVyc2VUcmFuc2Zvcm1bMV0pLCAxKTtcbiAgICBsZXQgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMl0sIGludmVyc2VUcmFuc2Zvcm1bM10pLCAxKTtcbiAgICBsZXQgcGFpbnRXaWR0aCA9IHdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IHRtcENhbnZhc0lkID0gXCJwcmVzY2FsZTFcIjtcbiAgICBsZXQgdG1wQ2FudmFzLCB0bXBDdHg7XG4gICAgd2hpbGUgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxIHx8IGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgIGxldCBuZXdXaWR0aCA9IHBhaW50V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0O1xuICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgIG5ld1dpZHRoID0gcGFpbnRXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRXaWR0aCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50V2lkdGggLyAyKTtcbiAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRIZWlnaHQgLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludEhlaWdodCkgLyAyO1xuICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBwYWludFdpZHRoLCBwYWludEhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBpbWcgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgcGFpbnRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0bXBDYW52YXNJZCA9IHRtcENhbnZhc0lkID09PSBcInByZXNjYWxlMVwiID8gXCJwcmVzY2FsZTJcIiA6IFwicHJlc2NhbGUxXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbWcsXG4gICAgICBwYWludFdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIF9jcmVhdGVNYXNrQ2FudmFzKGltZykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZztcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICBsZXQgY2FjaGUsIGNhY2hlS2V5LCBzY2FsZWQsIG1hc2tDYW52YXM7XG4gICAgaWYgKChpbWcuYml0bWFwIHx8IGltZy5kYXRhKSAmJiBpbWcuY291bnQgPiAxKSB7XG4gICAgICBjb25zdCBtYWluS2V5ID0gaW1nLmJpdG1hcCB8fCBpbWcuZGF0YS5idWZmZXI7XG4gICAgICBjYWNoZUtleSA9IEpTT04uc3RyaW5naWZ5KGlzUGF0dGVybkZpbGwgPyBjdXJyZW50VHJhbnNmb3JtIDogW2N1cnJlbnRUcmFuc2Zvcm0uc2xpY2UoMCwgNCksIGZpbGxDb2xvcl0pO1xuICAgICAgY2FjaGUgPSB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmdldChtYWluS2V5KTtcbiAgICAgIGlmICghY2FjaGUpIHtcbiAgICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuc2V0KG1haW5LZXksIGNhY2hlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhY2hlZEltYWdlID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICAgIGlmIChjYWNoZWRJbWFnZSAmJiAhaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5yb3VuZChNYXRoLm1pbihjdXJyZW50VHJhbnNmb3JtWzBdLCBjdXJyZW50VHJhbnNmb3JtWzJdKSArIGN1cnJlbnRUcmFuc2Zvcm1bNF0pO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5yb3VuZChNYXRoLm1pbihjdXJyZW50VHJhbnNmb3JtWzFdLCBjdXJyZW50VHJhbnNmb3JtWzNdKSArIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNhbnZhczogY2FjaGVkSW1hZ2UsXG4gICAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgICBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBzY2FsZWQgPSBjYWNoZWRJbWFnZTtcbiAgICB9XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0NhbnZhcy5jb250ZXh0LCBpbWcpO1xuICAgIH1cbiAgICBsZXQgbWFza1RvQ2FudmFzID0gVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgWzEgLyB3aWR0aCwgMCwgMCwgLTEgLyBoZWlnaHQsIDAsIDBdKTtcbiAgICBtYXNrVG9DYW52YXMgPSBVdGlsLnRyYW5zZm9ybShtYXNrVG9DYW52YXMsIFsxLCAwLCAwLCAxLCAwLCAtaGVpZ2h0XSk7XG4gICAgY29uc3QgW21pblgsIG1pblksIG1heFgsIG1heFldID0gVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgd2lkdGgsIGhlaWdodF0sIG1hc2tUb0NhbnZhcyk7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgucm91bmQobWF4WCAtIG1pblgpIHx8IDE7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKSB8fCAxO1xuICAgIGNvbnN0IGZpbGxDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImZpbGxDYW52YXNcIiwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGZpbGxDdHggPSBmaWxsQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IG1pblg7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IG1pblk7XG4gICAgZmlsbEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBmaWxsQ3R4LnRyYW5zZm9ybSguLi5tYXNrVG9DYW52YXMpO1xuICAgIGlmICghc2NhbGVkKSB7XG4gICAgICBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKG1hc2tDYW52YXMuY2FudmFzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShmaWxsQ3R4KSk7XG4gICAgICBzY2FsZWQgPSBzY2FsZWQuaW1nO1xuICAgICAgaWYgKGNhY2hlICYmIGlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzY2FsZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmaWxsQ3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGdldEltYWdlU21vb3RoaW5nRW5hYmxlZChnZXRDdXJyZW50VHJhbnNmb3JtKGZpbGxDdHgpLCBpbWcuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhmaWxsQ3R4LCBzY2FsZWQsIDAsIDAsIHNjYWxlZC53aWR0aCwgc2NhbGVkLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZmlsbEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgIGNvbnN0IGludmVyc2UgPSBVdGlsLnRyYW5zZm9ybShnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShmaWxsQ3R4KSwgWzEsIDAsIDAsIDEsIC1vZmZzZXRYLCAtb2Zmc2V0WV0pO1xuICAgIGZpbGxDdHguZmlsbFN0eWxlID0gaXNQYXR0ZXJuRmlsbCA/IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgaW52ZXJzZSwgUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICBpZiAod2lkdGggIT09IHRoaXMuY3VycmVudC5saW5lV2lkdGgpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICB9XG4gIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihzdHlsZSkge1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChsaW1pdCkge1xuICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuICBzZXREYXNoKGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hQaGFzZTtcbiAgICB9XG4gIH1cbiAgc2V0UmVuZGVyaW5nSW50ZW50KGludGVudCkge31cbiAgc2V0RmxhdG5lc3MoZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgdGhpcy5zZXREYXNoKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgdGhpcy5zZXRGb250KHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkJNXCI6XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTTWFza1wiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IHZhbHVlID8gdGhpcy50ZW1wU01hc2sgOiBudWxsO1xuICAgICAgICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVFJcIjpcbiAgICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEZpbHRlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuICBjaGVja1NNYXNrU3RhdGUoKSB7XG4gICAgY29uc3QgaW5TTWFza01vZGUgPSB0aGlzLmluU01hc2tNb2RlO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgIWluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmJlZ2luU01hc2tNb2RlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmIGluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgfVxuICBiZWdpblNNYXNrTW9kZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY2FjaGVJZCA9IFwic21hc2tHcm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuY3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4uZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLnN1c3BlbmRlZEN0eCkpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgY3R4KTtcbiAgICBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gIH1cbiAgZW5kU01hc2tNb2RlKCkge1xuICAgIGlmICghdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5kU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBub3QgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgdGhpcy5jdHguX3JlbW92ZU1pcnJvcmluZygpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLmN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuY3R4ID0gdGhpcy5zdXNwZW5kZWRDdHg7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICB9XG4gIGNvbXBvc2UoZGlydHlCb3gpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRpcnR5Qm94KSB7XG4gICAgICBkaXJ0eUJveCA9IFswLCAwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUJveFswXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMF0pO1xuICAgICAgZGlydHlCb3hbMV0gPSBNYXRoLmZsb29yKGRpcnR5Qm94WzFdKTtcbiAgICAgIGRpcnR5Qm94WzJdID0gTWF0aC5jZWlsKGRpcnR5Qm94WzJdKTtcbiAgICAgIGRpcnR5Qm94WzNdID0gTWF0aC5jZWlsKGRpcnR5Qm94WzNdKTtcbiAgICB9XG4gICAgY29uc3Qgc21hc2sgPSB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2s7XG4gICAgY29uc3Qgc3VzcGVuZGVkQ3R4ID0gdGhpcy5zdXNwZW5kZWRDdHg7XG4gICAgdGhpcy5jb21wb3NlU01hc2soc3VzcGVuZGVkQ3R4LCBzbWFzaywgdGhpcy5jdHgsIGRpcnR5Qm94KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBjb21wb3NlU01hc2soY3R4LCBzbWFzaywgbGF5ZXJDdHgsIGxheWVyQm94KSB7XG4gICAgY29uc3QgbGF5ZXJPZmZzZXRYID0gbGF5ZXJCb3hbMF07XG4gICAgY29uc3QgbGF5ZXJPZmZzZXRZID0gbGF5ZXJCb3hbMV07XG4gICAgY29uc3QgbGF5ZXJXaWR0aCA9IGxheWVyQm94WzJdIC0gbGF5ZXJPZmZzZXRYO1xuICAgIGNvbnN0IGxheWVySGVpZ2h0ID0gbGF5ZXJCb3hbM10gLSBsYXllck9mZnNldFk7XG4gICAgaWYgKGxheWVyV2lkdGggPT09IDAgfHwgbGF5ZXJIZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZW5lcmljQ29tcG9zZVNNYXNrKHNtYXNrLmNvbnRleHQsIGxheWVyQ3R4LCBsYXllcldpZHRoLCBsYXllckhlaWdodCwgc21hc2suc3VidHlwZSwgc21hc2suYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgc21hc2sub2Zmc2V0WCwgc21hc2sub2Zmc2V0WSk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguZHJhd0ltYWdlKGxheWVyQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBnZW5lcmljQ29tcG9zZVNNYXNrKG1hc2tDdHgsIGxheWVyQ3R4LCB3aWR0aCwgaGVpZ2h0LCBzdWJ0eXBlLCBiYWNrZHJvcCwgdHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBtYXNrT2Zmc2V0WCwgbWFza09mZnNldFkpIHtcbiAgICBsZXQgbWFza0NhbnZhcyA9IG1hc2tDdHguY2FudmFzO1xuICAgIGxldCBtYXNrWCA9IGxheWVyT2Zmc2V0WCAtIG1hc2tPZmZzZXRYO1xuICAgIGxldCBtYXNrWSA9IGxheWVyT2Zmc2V0WSAtIG1hc2tPZmZzZXRZO1xuICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgY29uc3QgYmFja2Ryb3BSR0IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5iYWNrZHJvcCk7XG4gICAgICBpZiAobWFza1ggPCAwIHx8IG1hc2tZIDwgMCB8fCBtYXNrWCArIHdpZHRoID4gbWFza0NhbnZhcy53aWR0aCB8fCBtYXNrWSArIGhlaWdodCA+IG1hc2tDYW52YXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0V4dGVuc2lvblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmNvbnRleHQ7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgLW1hc2tYLCAtbWFza1kpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcFJHQjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICBtYXNrQ2FudmFzID0gY2FudmFzLmNhbnZhcztcbiAgICAgICAgbWFza1ggPSBtYXNrWSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIG1hc2tDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBjbGlwLnJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5jbGlwKGNsaXApO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wUkdCO1xuICAgICAgICBtYXNrQ3R4LmZpbGxSZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXllckN0eC5zYXZlKCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGxheWVyQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBpZiAoc3VidHlwZSA9PT0gXCJBbHBoYVwiICYmIHRyYW5zZmVyTWFwKSB7XG4gICAgICBsYXllckN0eC5maWx0ZXIgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkQWxwaGFGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH0gZWxzZSBpZiAoc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIpIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRMdW1pbm9zaXR5RmlsdGVyKHRyYW5zZmVyTWFwKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LmNsaXAoY2xpcCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuICAgIGxheWVyQ3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBsYXllckN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgc2F2ZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgICB0aGlzLnN1c3BlbmRlZEN0eC5zYXZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgIHRoaXMuc3RhdGVTdGFjay5wdXNoKG9sZCk7XG4gICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gIH1cbiAgcmVzdG9yZSgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgICAgdGhpcy5zdXNwZW5kZWRDdHgucmVzdG9yZSgpO1xuICAgICAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuY3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cbiAgY29uc3RydWN0UGF0aChvcHMsIGFyZ3MsIG1pbk1heCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICB5ID0gY3VycmVudC55O1xuICAgIGxldCBzdGFydFgsIHN0YXJ0WTtcbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgIGNvbnN0IGlzU2NhbGluZ01hdHJpeCA9IGN1cnJlbnRUcmFuc2Zvcm1bMF0gPT09IDAgJiYgY3VycmVudFRyYW5zZm9ybVszXSA9PT0gMCB8fCBjdXJyZW50VHJhbnNmb3JtWzFdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bMl0gPT09IDA7XG4gICAgY29uc3QgbWluTWF4Rm9yQmV6aWVyID0gaXNTY2FsaW5nTWF0cml4ID8gbWluTWF4LnNsaWNlKDApIDogbnVsbDtcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIGlpID0gb3BzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHN3aXRjaCAob3BzW2ldIHwgMCkge1xuICAgICAgICBjYXNlIE9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgW3gsIHksIHh3LCB5aF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgT1BTLm1vdmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMubGluZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgIGlmICghaXNTY2FsaW5nTWF0cml4KSB7XG4gICAgICAgICAgICBjdXJyZW50LnVwZGF0ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE9QUy5jdXJ2ZVRvOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY3VydmVUbzI6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10pO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCB4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCB4LCB5LCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBPUFMuY2xvc2VQYXRoOlxuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgY3VycmVudC51cGRhdGVTY2FsaW5nUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBtaW5NYXhGb3JCZXppZXIpO1xuICAgIH1cbiAgICBjdXJyZW50LnNldEN1cnJlbnRQb2ludCh4LCB5KTtcbiAgfVxuICBjbG9zZVBhdGgoKSB7XG4gICAgdGhpcy5jdHguY2xvc2VQYXRoKCk7XG4gIH1cbiAgc3Ryb2tlKGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU1RST0tFKTtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKGZhbHNlKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIH1cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhO1xuICB9XG4gIGNsb3NlU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5zdHJva2UoKTtcbiAgfVxuICBmaWxsKGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBsZXQgbmVlZFJlc3RvcmUgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwpO1xuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgoaW50ZXJzZWN0KTtcbiAgICB9XG4gIH1cbiAgZW9GaWxsKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmZpbGwoZmFsc2UpO1xuICAgIHRoaXMuc3Ryb2tlKGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gIH1cbiAgZW9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VFT0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGVuZFBhdGgoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGNsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IE5PUk1BTF9DTElQO1xuICB9XG4gIGVvQ2xpcCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gRU9fQ0xJUDtcbiAgfVxuICBiZWdpblRleHQoKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBJREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBlbmRUZXh0KCkge1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChwYXRocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXRoLnRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNsYXRlKHBhdGgueCwgcGF0aC55KTtcbiAgICAgIHBhdGguYWRkVG9QYXRoKGN0eCwgcGF0aC5mb250U2l6ZSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICB9XG4gIHNldExlYWRpbmcobGVhZGluZykge1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZm9udE9iaikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIGZvbnQgZm9yICR7Zm9udFJlZk5hbWV9YCk7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCB8fCBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgd2FybihcIkludmFsaWQgZm9udCBtYXRyaXggZm9yIGZvbnQgXCIgKyBmb250UmVmTmFtZSk7XG4gICAgfVxuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGlmIChmb250T2JqLmlzVHlwZTNGb250KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSBmb250T2JqLmxvYWRlZE5hbWUgfHwgXCJzYW5zLXNlcmlmXCI7XG4gICAgY29uc3QgdHlwZWZhY2UgPSBmb250T2JqLnN5c3RlbUZvbnRJbmZvPy5jc3MgfHwgYFwiJHtuYW1lfVwiLCAke2ZvbnRPYmouZmFsbGJhY2tOYW1lfWA7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGxldCBicm93c2VyRm9udFNpemUgPSBzaXplO1xuICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUlOX0ZPTlRfU0laRTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPiBNQVhfRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemVTY2FsZSA9IHNpemUgLyBicm93c2VyRm9udFNpemU7XG4gICAgdGhpcy5jdHguZm9udCA9IGAke2l0YWxpY30gJHtib2xkfSAke2Jyb3dzZXJGb250U2l6ZX1weCAke3R5cGVmYWNlfWA7XG4gIH1cbiAgc2V0VGV4dFJlbmRlcmluZ01vZGUobW9kZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IG1vZGU7XG4gIH1cbiAgc2V0VGV4dFJpc2UocmlzZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gIH1cbiAgbW92ZVRleHQoeCwgeSkge1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYICs9IHg7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgKz0geTtcbiAgfVxuICBzZXRMZWFkaW5nTW92ZVRleHQoeCwgeSkge1xuICAgIHRoaXMuc2V0TGVhZGluZygteSk7XG4gICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgfVxuICBzZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIG5leHRMaW5lKCkge1xuICAgIHRoaXMubW92ZVRleHQoMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICB9XG4gIHBhaW50Q2hhcihjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICBjb25zdCBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgY29uc3QgcGF0dGVybkZpbGwgPSBjdXJyZW50LnBhdHRlcm5GaWxsICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGxldCBhZGRUb1BhdGg7XG4gICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IGlzQWRkVG9QYXRoU2V0IHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICBhZGRUb1BhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgcGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkVG9QYXRoKGN0eCwgZm9udFNpemUpO1xuICAgICAgaWYgKHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FkZFRvUGF0aFNldCkge1xuICAgICAgY29uc3QgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHMgfHw9IFtdO1xuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgYWRkVG9QYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0IGlzRm9udFN1YnBpeGVsQUFFbmFibGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IGN0eFxuICAgIH0gPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIDEwLCAxMCk7XG4gICAgY3R4LnNjYWxlKDEuNSwgMSk7XG4gICAgY3R4LmZpbGxUZXh0KFwiSVwiLCAwLCAxMCk7XG4gICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMTAsIDEwKS5kYXRhO1xuICAgIGxldCBlbmFibGVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBpZiAoZGF0YVtpXSA+IDAgJiYgZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dUeXBlM1RleHQoZ2x5cGhzKTtcbiAgICB9XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuVHJhbnNmb3JtO1xuICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKTtcbiAgICAgIHBhdHRlcm5UcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm47XG4gICAgfVxuICAgIGxldCBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlO1xuICAgIGlmIChzY2FsZSA9PT0gMCB8fCBsaW5lV2lkdGggPT09IDApIHtcbiAgICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgbGluZVdpZHRoID0gdGhpcy5nZXRTaW5nbGVQaXhlbFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICB9XG4gICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplU2NhbGUsIGZvbnRTaXplU2NhbGUpO1xuICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgaWYgKGZvbnQuaXNJbnZhbGlkUERGanNGb250KSB7XG4gICAgICBjb25zdCBjaGFycyA9IFtdO1xuICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICAgIGNoYXJzLnB1c2goZ2x5cGgudW5pY29kZSk7XG4gICAgICAgIHdpZHRoICs9IGdseXBoLndpZHRoO1xuICAgICAgfVxuICAgICAgY3R4LmZpbGxUZXh0KGNoYXJzLmpvaW4oXCJcIiksIDAsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKiB0ZXh0SFNjYWxlO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZSgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHggPSAwLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBjb25zdCBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChmb250LnJlbWVhc3VyZSAmJiB3aWR0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZWRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChjaGFyYWN0ZXIpLndpZHRoICogMTAwMCAvIGZvbnRTaXplICogZm9udFNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgIHJlc3RvcmVOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgc2NhbGVkWCAvPSBjaGFyYWN0ZXJTY2FsZVg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWludENoYXIoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZLCBwYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAoYWNjZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFkgPSBzY2FsZWRZIC0gZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIoYWNjZW50LmZvbnRDaGFyLCBzY2FsZWRBY2NlbnRYLCBzY2FsZWRBY2NlbnRZLCBwYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IHZlcnRpY2FsID8gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uIDogd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgeCArPSBjaGFyV2lkdGg7XG4gICAgICBpZiAocmVzdG9yZU5lZWRlZCkge1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQueSAtPSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBzaG93VHlwZTNUZXh0KGdseXBocykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gZm9udC52ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IHRleHRIU2NhbGUgPSBjdXJyZW50LnRleHRIU2NhbGUgKiBmb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IGZvbnRNYXRyaXggPSBjdXJyZW50LmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCBpc1RleHRJbnZpc2libGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5JTlZJU0lCTEU7XG4gICAgbGV0IGksIGdseXBoLCB3aWR0aCwgc3BhY2luZ0xlbmd0aDtcbiAgICBpZiAoaXNUZXh0SW52aXNpYmxlIHx8IGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55KTtcbiAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgZm9udERpcmVjdGlvbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc3BhY2luZ0xlbmd0aCA9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKHNwYWNpbmdMZW5ndGgsIDApO1xuICAgICAgICBjdXJyZW50LnggKz0gc3BhY2luZ0xlbmd0aCAqIHRleHRIU2NhbGU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3Qgb3BlcmF0b3JMaXN0ID0gZm9udC5jaGFyUHJvY09wZXJhdG9yTGlzdFtnbHlwaC5vcGVyYXRvckxpc3RJZF07XG4gICAgICBpZiAoIW9wZXJhdG9yTGlzdCkge1xuICAgICAgICB3YXJuKGBUeXBlMyBjaGFyYWN0ZXIgXCIke2dseXBoLm9wZXJhdG9yTGlzdElkfVwiIGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nVHlwZTMgPSBnbHlwaDtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIGN0eC5zY2FsZShmb250U2l6ZSwgZm9udFNpemUpO1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLmZvbnRNYXRyaXgpO1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oW2dseXBoLndpZHRoLCAwXSwgZm9udE1hdHJpeCk7XG4gICAgICB3aWR0aCA9IHRyYW5zZm9ybWVkWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB0ZXh0SFNjYWxlO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgfVxuICBzZXRDaGFyV2lkdGgoeFdpZHRoLCB5V2lkdGgpIHt9XG4gIHNldENoYXJXaWR0aEFuZEJvdW5kcyh4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgdGhpcy5jdHgucmVjdChsbHgsIGxseSwgdXJ4IC0gbGx4LCB1cnkgLSBsbHkpO1xuICAgIHRoaXMuY3R4LmNsaXAoKTtcbiAgICB0aGlzLmVuZFBhdGgoKTtcbiAgfVxuICBnZXRDb2xvck5fUGF0dGVybihJUikge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChJUlswXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gSVJbMV07XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtIHx8IGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpO1xuICAgICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVDYW52YXNHcmFwaGljczogY3R4ID0+IG5ldyBDYW52YXNHcmFwaGljcyhjdHgsIHRoaXMuY29tbW9uT2JqcywgdGhpcy5vYmpzLCB0aGlzLmNhbnZhc0ZhY3RvcnksIHRoaXMuZmlsdGVyRmFjdG9yeSwge1xuICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZzogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgICAgICAgbWFya2VkQ29udGVudFN0YWNrOiB0aGlzLm1hcmtlZENvbnRlbnRTdGFja1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHBhdHRlcm4gPSBuZXcgVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihJUlsxXSwgSVJbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICB9XG4gIHNldEZpbGxDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICB9XG4gIHNldFN0cm9rZVRyYW5zcGFyZW50KCkge1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICB9XG4gIHNldEZpbGxSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICB9XG4gIHNldEZpbGxUcmFuc3BhcmVudCgpIHtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICB9XG4gIF9nZXRQYXR0ZXJuKG9iaklkLCBtYXRyaXggPSBudWxsKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHRoaXMuY2FjaGVkUGF0dGVybnMuaGFzKG9iaklkKSkge1xuICAgICAgcGF0dGVybiA9IHRoaXMuY2FjaGVkUGF0dGVybnMuZ2V0KG9iaklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9IGdldFNoYWRpbmdQYXR0ZXJuKHRoaXMuZ2V0T2JqZWN0KG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHBhdHRlcm4ubWF0cml4ID0gbWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzaGFkaW5nRmlsbChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvYmpJZCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm4uZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNIQURJTkcpO1xuICAgIGNvbnN0IGludiA9IGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCk7XG4gICAgaWYgKGludikge1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9ID0gY3R4LmNhbnZhcztcbiAgICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBVdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52KTtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KC0xZTEwLCAtMWUxMCwgMmUxMCwgMmUxMCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICBiZWdpbklubGluZUltYWdlKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW5saW5lSW1hZ2VcIik7XG4gIH1cbiAgYmVnaW5JbWFnZURhdGEoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbWFnZURhdGFcIik7XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCk7XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgICAgIHRoaXMuY3R4LnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heChnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KSwgYmJveCk7XG4gICAgICB0aGlzLmNsaXAoKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBwYWludEZvcm1YT2JqZWN0RW5kKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgIGluZm8oXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgIHdhcm4oXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IFV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdXJyZW50Q3R4KSk7XG4gICAgY29uc3QgY2FudmFzQm91bmRzID0gWzAsIDAsIGN1cnJlbnRDdHguY2FudmFzLndpZHRoLCBjdXJyZW50Q3R4LmNhbnZhcy5oZWlnaHRdO1xuICAgIGJvdW5kcyA9IFV0aWwuaW50ZXJzZWN0KGJvdW5kcywgY2FudmFzQm91bmRzKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IoYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcihib3VuZHNbMV0pO1xuICAgIGNvbnN0IGRyYXduV2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzJdKSAtIG9mZnNldFgsIDEpO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKGJvdW5kc1szXSkgLSBvZmZzZXRZLCAxKTtcbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHRdKTtcbiAgICBsZXQgY2FjaGVJZCA9IFwiZ3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgY2FjaGVJZCArPSBcIl9zbWFza19cIiArIHRoaXMuc21hc2tDb3VudGVyKysgJSAyO1xuICAgIH1cbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGdyb3VwQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGdyb3VwQ3R4LnRyYW5zZm9ybSguLi5jdXJyZW50VHJhbnNmb3JtKTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMuc21hc2tTdGFjay5wdXNoKHtcbiAgICAgICAgY2FudmFzOiBzY3JhdGNoQ2FudmFzLmNhbnZhcyxcbiAgICAgICAgY29udGV4dDogZ3JvdXBDdHgsXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgICAgIHN1YnR5cGU6IGdyb3VwLnNtYXNrLnN1YnR5cGUsXG4gICAgICAgIGJhY2tkcm9wOiBncm91cC5zbWFzay5iYWNrZHJvcCxcbiAgICAgICAgdHJhbnNmZXJNYXA6IGdyb3VwLnNtYXNrLnRyYW5zZmVyTWFwIHx8IG51bGwsXG4gICAgICAgIHN0YXJ0VHJhbnNmb3JtSW52ZXJzZTogbnVsbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICBjdXJyZW50Q3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29weUN0eFN0YXRlKGN1cnJlbnRDdHgsIGdyb3VwQ3R4KTtcbiAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgIHRoaXMuc2V0R1N0YXRlKFtbXCJCTVwiLCBcInNvdXJjZS1vdmVyXCJdLCBbXCJjYVwiLCAxXSwgW1wiQ0FcIiwgMV1dKTtcbiAgICB0aGlzLmdyb3VwU3RhY2sucHVzaChjdXJyZW50Q3R4KTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwrKztcbiAgfVxuICBlbmRHcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICBjb25zdCBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZ3JvdXBTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMudGVtcFNNYXNrID0gdGhpcy5zbWFza1N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNdHggPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLmN1cnJlbnRNdHgpO1xuICAgICAgY29uc3QgZGlydHlCb3ggPSBVdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCBncm91cEN0eC5jYW52YXMud2lkdGgsIGdyb3VwQ3R4LmNhbnZhcy5oZWlnaHRdLCBjdXJyZW50TXR4KTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShncm91cEN0eC5jYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKGRpcnR5Qm94KTtcbiAgICB9XG4gIH1cbiAgYmVnaW5Bbm5vdGF0aW9uKGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5zYXZlKCk7XG4gICAgaWYgKHRoaXMuYmFzZVRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLnRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgfVxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHJlY3RbMl0gLSByZWN0WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gcmVjdFszXSAtIHJlY3RbMV07XG4gICAgICBpZiAoaGFzT3duQ2FudmFzICYmIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0uc2xpY2UoKTtcbiAgICAgICAgdHJhbnNmb3JtWzRdIC09IHJlY3RbMF07XG4gICAgICAgIHRyYW5zZm9ybVs1XSAtPSByZWN0WzFdO1xuICAgICAgICByZWN0ID0gcmVjdC5zbGljZSgpO1xuICAgICAgICByZWN0WzBdID0gcmVjdFsxXSA9IDA7XG4gICAgICAgIHJlY3RbMl0gPSB3aWR0aDtcbiAgICAgICAgcmVjdFszXSA9IGhlaWdodDtcbiAgICAgICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCkpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgdmlld3BvcnRTY2FsZVxuICAgICAgICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiB0aGlzLm91dHB1dFNjYWxlWCAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogdGhpcy5vdXRwdXRTY2FsZVkgKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZShjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgIH0gPSB0aGlzLmFubm90YXRpb25DYW52YXM7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcC5zZXQoaWQsIGNhbnZhcyk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eCA9IHRoaXMuY3R4O1xuICAgICAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHNjYWxlWCwgMCwgMCwgLXNjYWxlWSwgMCwgaGVpZ2h0ICogc2NhbGVZKTtcbiAgICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgICAgdGhpcy5jdHgucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcCgpO1xuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLm1hdHJpeCk7XG4gIH1cbiAgZW5kQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uQ2FudmFzKSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gaW1nLmNvdW50O1xuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGdseXBoID0gdGhpcy5wcm9jZXNzaW5nVHlwZTM7XG4gICAgaWYgKGdseXBoKSB7XG4gICAgICBpZiAoZ2x5cGguY29tcGlsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbHlwaC5jb21waWxlZCA9IGNvbXBpbGVUeXBlM0dseXBoKGltZyk7XG4gICAgICB9XG4gICAgICBpZiAoZ2x5cGguY29tcGlsZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQoY3R4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhpbWcpO1xuICAgIGNvbnN0IG1hc2tDYW52YXMgPSBtYXNrLmNhbnZhcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQoaW1nLCBzY2FsZVgsIHNrZXdYID0gMCwgc2tld1kgPSAwLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbWcgPSB0aGlzLmdldE9iamVjdChpbWcuZGF0YSwgaW1nKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCAwLCAwKTtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhpbWcpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgbWFzay5vZmZzZXRYIC0gY3VycmVudFRyYW5zZm9ybVs0XSwgbWFzay5vZmZzZXRZIC0gY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRyYW5zID0gVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0pO1xuICAgICAgY29uc3QgW3gsIHldID0gVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIHRyYW5zKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UobWFzay5jYW52YXMsIHgsIHkpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3QoZGF0YSwgaW1hZ2UpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgbWFza0NhbnZhcy5jYW52YXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIDAsIC0xLCAxLCAxKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0KG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICB3YXJuKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdChvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBtYXAgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgbWFwLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IFtzY2FsZVgsIDAsIDAsIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdXSxcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMoY3R4KSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgIT09IFwibm9uZVwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiBjdHguY2FudmFzO1xuICB9XG4gIGFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIGltZ0RhdGEuYml0bWFwO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXAsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWdEYXRhO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgdG1wQ3R4LmZpbHRlciA9IHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHM7XG4gICAgdG1wQ3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApO1xuICAgIHRtcEN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICByZXR1cm4gdG1wQ2FudmFzLmNhbnZhcztcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAoIWlzTm9kZUpTKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpbHRlclxuICAgICAgfSA9IGN0eDtcbiAgICAgIGlmIChmaWx0ZXIgIT09IFwibm9uZVwiICYmIGZpbHRlciAhPT0gXCJcIikge1xuICAgICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgIWltZ0RhdGEuZGF0YSkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKGltZ1RvUGFpbnQsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkpO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLCBpbWdEYXRhLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzY2FsZWQuaW1nLCAwLCAwLCBzY2FsZWQucGFpbnRXaWR0aCwgc2NhbGVkLnBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhLmJpdG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdyA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBtYXApIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmVudHJ5LnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgaW1nVG9QYWludCwgZW50cnkueCwgZW50cnkueSwgZW50cnkudywgZW50cnkuaCwgMCwgLTEsIDEsIDEpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBtYXJrUG9pbnQodGFnKSB7fVxuICBtYXJrUG9pbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHt9XG4gIGJlZ2luTWFya2VkQ29udGVudCh0YWcpIHtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAodGFnID09PSBcIk9DXCIpIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZy5pc1Zpc2libGUocHJvcGVydGllcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KCkge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBiZWdpbkNvbXBhdCgpIHt9XG4gIGVuZENvbXBhdCgpIHt9XG4gIGNvbnN1bWVQYXRoKGNsaXBCb3gpIHtcbiAgICBjb25zdCBpc0VtcHR5ID0gdGhpcy5jdXJyZW50LmlzRW1wdHlDbGlwKCk7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVDbGlwRnJvbVBhdGgoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmNvbXBvc2UoY2xpcEJveCk7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KHRoaXMuY3VycmVudC5jbGlwQm94KTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gIH1cbiAgZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgpIHtcbiAgICAgIGNvbnN0IG0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IDEgLyBNYXRoLm1pbihNYXRoLmFicyhtWzBdKSwgTWF0aC5hYnMobVszXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMobVswXSAqIG1bM10gLSBtWzJdICogbVsxXSk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChtWzBdLCBtWzJdKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KG1bMV0sIG1bM10pO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gTWF0aC5tYXgobm9ybVgsIG5vcm1ZKSAvIGFic0RldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGg7XG4gIH1cbiAgZ2V0U2NhbGVGb3JTdHJva2luZygpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBkXG4gICAgICB9ID0gdGhpcy5jdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICBsZXQgc2NhbGVYLCBzY2FsZVk7XG4gICAgICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5hYnMoYSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5hYnMoZCk7XG4gICAgICAgIGlmIChub3JtWCA9PT0gbm9ybVkpIHtcbiAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSAxIC8gbm9ybVg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gc2NhbGVkTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSAxIC8gbm9ybVg7XG4gICAgICAgICAgc2NhbGVZID0gMSAvIG5vcm1ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFhMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBjb25zdCBzY2FsZWRZTGluZVdpZHRoID0gbm9ybVkgKiBsaW5lV2lkdGg7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVkWExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gc2NhbGVkWUxpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWUxpbmVXaWR0aCA6IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKGEgKiBkIC0gYiAqIGMpO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZIC8gYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YIC8gYWJzRGV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJhc2VBcmVhID0gbGluZVdpZHRoICogYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZID4gYmFzZUFyZWEgPyBub3JtWSAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCA+IGJhc2VBcmVhID8gbm9ybVggLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSBzY2FsZVg7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzFdID0gc2NhbGVZO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZztcbiAgfVxuICByZXNjYWxlQW5kU3Ryb2tlKHNhdmVSZXN0b3JlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGluZVdpZHRoXG4gICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gdGhpcy5nZXRTY2FsZUZvclN0cm9raW5nKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAxO1xuICAgIGlmIChzY2FsZVggPT09IDEgJiYgc2NhbGVZID09PSAxKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhc2hlcyA9IGN0eC5nZXRMaW5lRGFzaCgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICBpZiAoZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcy5tYXAoeCA9PiB4IC8gc2NhbGUpKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCAvPSBzY2FsZTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgaXNDb250ZW50VmlzaWJsZSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tYXJrZWRDb250ZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICghdGhpcy5tYXJrZWRDb250ZW50U3RhY2tbaV0udmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mb3IgKGNvbnN0IG9wIGluIE9QUykge1xuICBpZiAoQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW09QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS93b3JrZXJfb3B0aW9ucy5qc1xuY2xhc3MgR2xvYmFsV29ya2VyT3B0aW9ucyB7XG4gIHN0YXRpYyAjcG9ydCA9IG51bGw7XG4gIHN0YXRpYyAjc3JjID0gXCJcIjtcbiAgc3RhdGljIGdldCB3b3JrZXJQb3J0KCkge1xuICAgIHJldHVybiB0aGlzLiNwb3J0O1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyUG9ydCh2YWwpIHtcbiAgICBpZiAoISh0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIFdvcmtlcikgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJQb3J0YCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jcG9ydCA9IHZhbDtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3JjO1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyU3JjKHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJTcmNgIHR5cGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzcmMgPSB2YWw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9tZXNzYWdlX2hhbmRsZXIuanNcblxuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuZnVuY3Rpb24gd3JhcFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKCEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIHJlYXNvbiA9PT0gXCJvYmplY3RcIiAmJiByZWFzb24gIT09IG51bGwpKSB7XG4gICAgdW5yZWFjaGFibGUoJ3dyYXBSZWFzb246IEV4cGVjdGVkIFwicmVhc29uXCIgdG8gYmUgYSAocG9zc2libHkgY2xvbmVkKSBFcnJvci4nKTtcbiAgfVxuICBzd2l0Y2ggKHJlYXNvbi5uYW1lKSB7XG4gICAgY2FzZSBcIkFib3J0RXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IEFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcbiAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBNaXNzaW5nUERGRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcbiAgICBjYXNlIFwiUGFzc3dvcmRFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUGFzc3dvcmRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5jb2RlKTtcbiAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLnN0YXR1cyk7XG4gICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5kZXRhaWxzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxufVxuY2xhc3MgTWVzc2FnZUhhbmRsZXIge1xuICAjbWVzc2FnZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB0aGlzLnNvdXJjZU5hbWUgPSBzb3VyY2VOYW1lO1xuICAgIHRoaXMudGFyZ2V0TmFtZSA9IHRhcmdldE5hbWU7XG4gICAgdGhpcy5jb21PYmogPSBjb21PYmo7XG4gICAgdGhpcy5jYWxsYmFja0lkID0gMTtcbiAgICB0aGlzLnN0cmVhbUlkID0gMTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGlvbkhhbmRsZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbU9iai5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLiNvbk1lc3NhZ2UuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsOiB0aGlzLiNtZXNzYWdlQUMuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI29uTWVzc2FnZSh7XG4gICAgZGF0YVxuICB9KSB7XG4gICAgaWYgKGRhdGEudGFyZ2V0TmFtZSAhPT0gdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLnN0cmVhbSkge1xuICAgICAgdGhpcy4jcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoIWNhcGFiaWxpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke2NhbGxiYWNrSWR9YCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuREFUQSkge1xuICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25IYW5kbGVyW2RhdGEuYWN0aW9uXTtcbiAgICBpZiAoIWFjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogJHtkYXRhLmFjdGlvbn1gKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xuICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZSxcbiAgICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXNvbHZlKGFjdGlvbihkYXRhLmRhdGEpKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsID0gcHVsbENhcGFiaWxpdHk7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVsbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IHJlYXNvbiA9PiB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbmtDYXBhYmlsaXR5OiBQcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICByZWFkeTogbnVsbFxuICAgIH07XG4gICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtU2luay5yZWFkeSA9IHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSA9IHN0cmVhbVNpbms7XG4gICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUoYWN0aW9uKGRhdGEuZGF0YSwgc3RyZWFtU2luaykpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sXG4gICAgICBzdHJlYW1TaW5rID0gdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgc3dpdGNoIChkYXRhLnN0cmVhbSkge1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW1TaW5rLmRlc2lyZWRTaXplIDw9IDAgJiYgZGF0YS5kZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1TaW5rLmRlc2lyZWRTaXplID0gZGF0YS5kZXNpcmVkU2l6ZTtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHN0cmVhbVNpbmsub25QdWxsPy4oKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVOUVVFVUU6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUoZGF0YS5jaHVuayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNMT1NFOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJjbG9zZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FUlJPUjpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiZXJyb3Igc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcih3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShzdHJlYW1TaW5rLm9uQ2FuY2VsPy4od3JhcFJlYXNvbihkYXRhLnJlYXNvbikpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgc3RyZWFtU2luay5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbD8ucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21lc3NhZ2VBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNtZXNzYWdlQUMgPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L21ldGFkYXRhLmpzXG5cbmNsYXNzIE1ldGFkYXRhIHtcbiAgI21ldGFkYXRhTWFwO1xuICAjZGF0YTtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcnNlZERhdGEsXG4gICAgcmF3RGF0YVxuICB9KSB7XG4gICAgdGhpcy4jbWV0YWRhdGFNYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG4gIGdldFJhdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5nZXQobmFtZSkgPz8gbnVsbDtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIG9iamVjdEZyb21NYXAodGhpcy4jbWV0YWRhdGFNYXApO1xuICB9XG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhTWFwLmhhcyhuYW1lKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9vcHRpb25hbF9jb250ZW50X2NvbmZpZy5qc1xuXG5cbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKFwiSU5URVJOQUxcIik7XG5jbGFzcyBPcHRpb25hbENvbnRlbnRHcm91cCB7XG4gICNpc0Rpc3BsYXkgPSBmYWxzZTtcbiAgI2lzUHJpbnQgPSBmYWxzZTtcbiAgI3VzZXJTZXQgPSBmYWxzZTtcbiAgI3Zpc2libGUgPSB0cnVlO1xuICBjb25zdHJ1Y3RvcihyZW5kZXJpbmdJbnRlbnQsIHtcbiAgICBuYW1lLFxuICAgIGludGVudCxcbiAgICB1c2FnZSxcbiAgICByYkdyb3Vwc1xuICB9KSB7XG4gICAgdGhpcy4jaXNEaXNwbGF5ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZKTtcbiAgICB0aGlzLiNpc1ByaW50ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmludGVudCA9IGludGVudDtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy5yYkdyb3VwcyA9IHJiR3JvdXBzO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIGlmICh0aGlzLiN1c2VyU2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy4jdmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN2aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHByaW50LFxuICAgICAgdmlld1xuICAgIH0gPSB0aGlzLnVzYWdlO1xuICAgIGlmICh0aGlzLiNpc0Rpc3BsYXkpIHtcbiAgICAgIHJldHVybiB2aWV3Py52aWV3U3RhdGUgIT09IFwiT0ZGXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1ByaW50KSB7XG4gICAgICByZXR1cm4gcHJpbnQ/LnByaW50U3RhdGUgIT09IFwiT0ZGXCI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zZXRWaXNpYmxlKGludGVybmFsLCB2aXNpYmxlLCB1c2VyU2V0ID0gZmFsc2UpIHtcbiAgICBpZiAoaW50ZXJuYWwgIT09IElOVEVSTkFMKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkludGVybmFsIG1ldGhvZCBgX3NldFZpc2libGVgIGNhbGxlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuI3VzZXJTZXQgPSB1c2VyU2V0O1xuICAgIHRoaXMuI3Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG59XG5jbGFzcyBPcHRpb25hbENvbnRlbnRDb25maWcge1xuICAjY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gICNncm91cHMgPSBuZXcgTWFwKCk7XG4gICNpbml0aWFsSGFzaCA9IG51bGw7XG4gICNvcmRlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSkge1xuICAgIHRoaXMucmVuZGVyaW5nSW50ZW50ID0gcmVuZGVyaW5nSW50ZW50O1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuI29yZGVyID0gZGF0YS5vcmRlcjtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGRhdGEuZ3JvdXBzKSB7XG4gICAgICB0aGlzLiNncm91cHMuc2V0KGdyb3VwLmlkLCBuZXcgT3B0aW9uYWxDb250ZW50R3JvdXAocmVuZGVyaW5nSW50ZW50LCBncm91cCkpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iYXNlU3RhdGUgPT09IFwiT0ZGXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy4jZ3JvdXBzLnZhbHVlcygpKSB7XG4gICAgICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb24gb2YgZGF0YS5vbikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvbikuX3NldFZpc2libGUoSU5URVJOQUwsIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9mZiBvZiBkYXRhLm9mZikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvZmYpLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxIYXNoID0gdGhpcy5nZXRIYXNoKCk7XG4gIH1cbiAgI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRvciA9IGFycmF5WzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgIGxldCBzdGF0ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jZ3JvdXBzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbWVudCkudmlzaWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2VsZW1lbnR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiQW5kXCI6XG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9yXCI6XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOb3RcIjpcbiAgICAgICAgICByZXR1cm4gIXN0YXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiQW5kXCI7XG4gIH1cbiAgaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgaWYgKHRoaXMuI2dyb3Vwcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgaW5mbyhcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGRlZmluZWQuXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChncm91cC50eXBlID09PSBcIk9DR1wiKSB7XG4gICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoZ3JvdXAuaWQpKSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2dyb3VwLmlkfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGdyb3VwLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cC5wb2xpY3kgfHwgZ3JvdXAucG9saWN5ID09PSBcIkFueU9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3YXJuKGBVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5ICR7Z3JvdXAucG9saWN5fS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuKGBVbmtub3duIGdyb3VwIHR5cGUgJHtncm91cC50eXBlfS5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRWaXNpYmlsaXR5KGlkLCB2aXNpYmxlID0gdHJ1ZSwgcHJlc2VydmVSQiA9IHRydWUpIHtcbiAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoaWQpO1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJlc2VydmVSQiAmJiB2aXNpYmxlICYmIGdyb3VwLnJiR3JvdXBzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCByYkdyb3VwIG9mIGdyb3VwLnJiR3JvdXBzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3RoZXJJZCBvZiByYkdyb3VwKSB7XG4gICAgICAgICAgaWYgKG90aGVySWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aGlzLiNncm91cHMuZ2V0KG90aGVySWQpPy5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgISF2aXNpYmxlLCB0cnVlKTtcbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBzZXRPQ0dTdGF0ZSh7XG4gICAgc3RhdGUsXG4gICAgcHJlc2VydmVSQlxuICB9KSB7XG4gICAgbGV0IG9wZXJhdG9yO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBzdGF0ZSkge1xuICAgICAgc3dpdGNoIChlbGVtKSB7XG4gICAgICAgIGNhc2UgXCJPTlwiOlxuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgIGNhc2UgXCJUb2dnbGVcIjpcbiAgICAgICAgICBvcGVyYXRvciA9IGVsZW07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbSk7XG4gICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgdHJ1ZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgZmFsc2UsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sICFncm91cC52aXNpYmxlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgZ2V0IGhhc0luaXRpYWxWaXNpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLiNpbml0aWFsSGFzaCA9PT0gbnVsbCB8fCB0aGlzLmdldEhhc2goKSA9PT0gdGhpcy4jaW5pdGlhbEhhc2g7XG4gIH1cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNvcmRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuI29yZGVyLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGhpcy4jZ3JvdXBzLmtleXMoKV07XG4gIH1cbiAgZ2V0R3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuc2l6ZSA+IDAgPyBvYmplY3RGcm9tTWFwKHRoaXMuI2dyb3VwcykgOiBudWxsO1xuICB9XG4gIGdldEdyb3VwKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoaWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0SGFzaCgpIHtcbiAgICBpZiAodGhpcy4jY2FjaGVkR2V0SGFzaCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2g7XG4gICAgfVxuICAgIGNvbnN0IGhhc2ggPSBuZXcgTXVybXVySGFzaDNfNjQoKTtcbiAgICBmb3IgKGNvbnN0IFtpZCwgZ3JvdXBdIG9mIHRoaXMuI2dyb3Vwcykge1xuICAgICAgaGFzaC51cGRhdGUoYCR7aWR9OiR7Z3JvdXAudmlzaWJsZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlZEdldEhhc2ggPSBoYXNoLmhleGRpZ2VzdCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RyYW5zcG9ydF9zdHJlYW0uanNcblxuXG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtIHtcbiAgY29uc3RydWN0b3IocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCB7XG4gICAgZGlzYWJsZVJhbmdlID0gZmFsc2UsXG4gICAgZGlzYWJsZVN0cmVhbSA9IGZhbHNlXG4gIH0pIHtcbiAgICBhc3NlcnQocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGgsXG4gICAgICBpbml0aWFsRGF0YSxcbiAgICAgIHByb2dyZXNzaXZlRG9uZSxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lXG4gICAgfSA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGluaXRpYWxEYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpbml0aWFsRGF0YS5ieXRlTGVuZ3RoID09PSBpbml0aWFsRGF0YS5idWZmZXIuYnl0ZUxlbmd0aCA/IGluaXRpYWxEYXRhLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIWRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMgPSBbXTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcigobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZCxcbiAgICAgICAgdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihjaHVuayA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG4gIF9vblJlY2VpdmVEYXRhKHtcbiAgICBiZWdpbixcbiAgICBjaHVua1xuICB9KSB7XG4gICAgY29uc3QgYnVmZmVyID0gY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGNodW5rLmJ5dGVMZW5ndGggPT09IGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID8gY2h1bmsuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgYXNzZXJ0KGZvdW5kLCBcIl9vblJlY2VpdmVEYXRhIC0gbm8gYFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcmAgaW5zdGFuY2UgZm91bmQuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICBpZiAoZXZ0LnRvdGFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JhbmdlUmVhZGVyc1swXT8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Lm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9vblByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ucHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gdHJ1ZTtcbiAgfVxuICBfcmVtb3ZlUmFuZ2VSZWFkZXIocmVhZGVyKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX3JhbmdlUmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgY29uc3QgcXVldWVkQ2h1bmtzID0gdGhpcy5fcXVldWVkQ2h1bmtzO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IG51bGw7XG4gICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lLCB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSk7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgcXVldWVkQ2h1bmtzLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2RvbmUgPSBwcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBpc1BkZkZpbGUoY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpID8gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgOiBudWxsO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IHF1ZXVlZENodW5rcyB8fCBbXTtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9oZWFkZXJzUmVhZHkgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBzdHJlYW0uX2Z1bGxSZXF1ZXN0UmVhZGVyID0gdGhpcztcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmtzLnB1c2goY2h1bmspO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBwcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX2VuZCA9IGVuZDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY29udGVudF9kaXNwb3NpdGlvbi5qc1xuXG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gIGxldCBuZWVkc0VuY29kaW5nRml4dXAgPSB0cnVlO1xuICBsZXQgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCpcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gdW5lc2NhcGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjNTk4N2RlY29kZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUodG1wKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICBmdW5jdGlvbiB0b1BhcmFtUmVnRXhwKGF0dHJpYnV0ZVBhdHRlcm4sIGZsYWdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXCIoPzpefDspXFxcXHMqXCIgKyBhdHRyaWJ1dGVQYXR0ZXJuICsgXCJcXFxccyo9XFxcXHMqXCIgKyBcIihcIiArICdbXlwiO1xcXFxzXVteO1xcXFxzXSonICsgXCJ8XCIgKyAnXCIoPzpbXlwiXFxcXFxcXFxdfFxcXFxcXFxcXCI/KStcIj8nICsgXCIpXCIsIGZsYWdzKTtcbiAgfVxuICBmdW5jdGlvbiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSkge1xuICAgIGlmIChlbmNvZGluZykge1xuICAgICAgaWYgKCEvXltcXHgwMC1cXHhGRl0rJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGl0ZXIgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKigoPyEwXFxcXGQpXFxcXGQrKShcXFxcKj8pXCIsIFwiaWdcIik7XG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGNoZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICghKG4gaW4gbWF0Y2hlcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBwYXJ0ID0gcmZjNTk4N2RlY29kZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjYxNnVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZUFsbCgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kaW5nZW5kID0gZXh0dmFsdWUuaW5kZXhPZihcIidcIik7XG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIwNDdkZWNvZGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoXCI9P1wiKSB8fCAvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dCA9IGF0b2IodGV4dCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29ya191dGlscy5qc1xuXG5cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhpc0h0dHAsIGh0dHBIZWFkZXJzKSB7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBpZiAoIWlzSHR0cCB8fCAhaHR0cEhlYWRlcnMgfHwgdHlwZW9mIGh0dHBIZWFkZXJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICBjb25zdCB2YWwgPSBodHRwSGVhZGVyc1trZXldO1xuICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgcmVzcG9uc2VIZWFkZXJzLFxuICBpc0h0dHAsXG4gIHJhbmdlQ2h1bmtTaXplLFxuICBkaXNhYmxlUmFuZ2Vcbn0pIHtcbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIGFsbG93UmFuZ2VSZXF1ZXN0czogZmFsc2UsXG4gICAgc3VnZ2VzdGVkTGVuZ3RoOiB1bmRlZmluZWRcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuc3VnZ2VzdGVkTGVuZ3RoID0gbGVuZ3RoO1xuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGRpc2FibGVSYW5nZSB8fCAhaXNIdHRwKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBpZiAocmVzcG9uc2VIZWFkZXJzLmdldChcIkFjY2VwdC1SYW5nZXNcIikgIT09IFwiYnl0ZXNcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgY29uc3QgY29udGVudEVuY29kaW5nID0gcmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuICBpZiAoY29udGVudEVuY29kaW5nICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5hbGxvd1JhbmdlUmVxdWVzdHMgPSB0cnVlO1xuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpIHtcbiAgY29uc3QgY29udGVudERpc3Bvc2l0aW9uID0gcmVzcG9uc2VIZWFkZXJzLmdldChcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICBsZXQgZmlsZW5hbWUgPSBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgICBpZiAoZmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlbmFtZSA9IGRlY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZSk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIGlmIChpc1BkZkZpbGUoZmlsZW5hbWUpKSB7XG4gICAgICByZXR1cm4gZmlsZW5hbWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHVybCkge1xuICBpZiAoc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAgICByZXR1cm4gbmV3IE1pc3NpbmdQREZFeGNlcHRpb24oJ01pc3NpbmcgUERGIFwiJyArIHVybCArICdcIi4nKTtcbiAgfVxuICByZXR1cm4gbmV3IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKCR7c3RhdHVzfSkgd2hpbGUgcmV0cmlldmluZyBQREYgXCIke3VybH1cIi5gLCBzdGF0dXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXNwb25zZVN0YXR1cyhzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gMjA2O1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9mZXRjaF9zdHJlYW0uanNcblxuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiXG4gIH07XG59XG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gdmFsLmJ1ZmZlcjtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHdhcm4oYGdldEFycmF5QnVmZmVyIC0gdW5leHBlY3RlZCBkYXRhIGZvcm1hdDogJHt2YWx9YCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpLmJ1ZmZlcjtcbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIHNvdXJjZS5odHRwSGVhZGVycyk7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRmV0Y2hTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHN0cmVhbS5oZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBpc0h0dHA6IHN0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKG5ldyBBYm9ydEV4Y2VwdGlvbihcIlN0cmVhbWluZyBpcyBkaXNhYmxlZC5cIikpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuYXBwZW5kKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YmVnaW59LSR7ZW5kIC0gMX1gKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgfSkuY2F0Y2godGhpcy5fcmVhZENhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZG9uZVxuICAgIH0gPSBhd2FpdCB0aGlzLl9yZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGdldEFycmF5QnVmZmVyKHZhbHVlKSxcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fcmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9uZXR3b3JrLmpzXG5cblxuY29uc3QgT0tfUkVTUE9OU0UgPSAyMDA7XG5jb25zdCBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UgPSAyMDY7XG5mdW5jdGlvbiBuZXR3b3JrX2dldEFycmF5QnVmZmVyKHhocikge1xuICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gc3RyaW5nVG9CeXRlcyhkYXRhKS5idWZmZXI7XG59XG5jbGFzcyBOZXR3b3JrTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1cmwsXG4gICAgaHR0cEhlYWRlcnMsXG4gICAgd2l0aENyZWRlbnRpYWxzXG4gIH0pIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBodHRwSGVhZGVycyk7XG4gICAgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSB3aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5jdXJyWGhySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICByZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgbGlzdGVuZXJzKSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGJlZ2luLFxuICAgICAgZW5kXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBhcmdzW3Byb3BdID0gbGlzdGVuZXJzW3Byb3BdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFyZ3MpO1xuICB9XG4gIHJlcXVlc3RGdWxsKGxpc3RlbmVycykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobGlzdGVuZXJzKTtcbiAgfVxuICByZXF1ZXN0KGFyZ3MpIHtcbiAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuaGVhZGVycykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0h0dHAgJiYgXCJiZWdpblwiIGluIGFyZ3MgJiYgXCJlbmRcIiBpbiBhcmdzKSB7XG4gICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsIGBieXRlcz0ke2FyZ3MuYmVnaW59LSR7YXJncy5lbmQgLSAxfWApO1xuICAgICAgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgfVxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgaWYgKGFyZ3Mub25FcnJvcikge1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGFyZ3Mub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLm9uU3RhdGVDaGFuZ2UuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQgPSBhcmdzLm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSA9IGFyZ3Mub25Eb25lO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IgPSBhcmdzLm9uRXJyb3I7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcyA9IGFyZ3Mub25Qcm9ncmVzcztcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgICByZXR1cm4geGhySWQ7XG4gIH1cbiAgb25Qcm9ncmVzcyh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzPy4oZXZ0KTtcbiAgfVxuICBvblN0YXRlQ2hhbmdlKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhociA9IHBlbmRpbmdSZXF1ZXN0LnhocjtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQoKTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICB9XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICh4aHIuc3RhdHVzID09PSAwICYmIHRoaXMuaXNIdHRwKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgY29uc3Qgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IG5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIoeGhyKTtcbiAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApLFxuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgYmVnaW46IDAsXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgIH1cbiAgfVxuICBnZXRSZXF1ZXN0WGhyKHhocklkKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gIH1cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuICBhYm9ydFJlcXVlc3QoeGhySWQpIHtcbiAgICBjb25zdCB4aHIgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgeGhyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UpO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdEZ1bGwoYXJncyk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhySWQgPSB0aGlzLl9mdWxsUmVxdWVzdElkO1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhyID0gdGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IG5ldyBIZWFkZXJzKGZ1bGxSZXF1ZXN0WGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnRyaW0oKS5zcGxpdCgvW1xcclxcbl0rLykubWFwKHggPT4ge1xuICAgICAgY29uc3QgW2tleSwgLi4udmFsXSA9IHguc3BsaXQoXCI6IFwiKTtcbiAgICAgIHJldHVybiBba2V5LCB2YWwuam9pbihcIjogXCIpXTtcbiAgICB9KSk7XG4gICAgY29uc3Qge1xuICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKHJlc3BvbnNlSGVhZGVycyk7XG4gICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIH1cbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3Ioc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID0gMDtcbiAgfVxuICBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICB0b3RhbDogZXZ0Lmxlbmd0aENvbXB1dGFibGUgPyBldnQudG90YWwgOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpO1xuICAgIH1cbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gIH1cbn1cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IG1hbmFnZXIudXJsO1xuICAgIHRoaXMuX3JlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGFyZ3MpO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMub25DbG9zZWQgPSBudWxsO1xuICB9XG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLm9uQ2xvc2VkPy4odGhpcyk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgY29uc3QgY2h1bmsgPSBkYXRhLmNodW5rO1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jbG9zZSgpO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fcmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fcmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3N0cmVhbS5qc1xuXG5cblxuY29uc3QgdXJsUmVnZXggPSAvXlthLXpdW2EtejAtOVxcLSsuXSs6L2k7XG5mdW5jdGlvbiBwYXJzZVVybE9yUGF0aChzb3VyY2VVcmwpIHtcbiAgaWYgKHVybFJlZ2V4LnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiBuZXcgVVJMKHNvdXJjZVVybCk7XG4gIH1cbiAgY29uc3QgdXJsID0gTm9kZVBhY2thZ2VzLmdldChcInVybFwiKTtcbiAgcmV0dXJuIG5ldyBVUkwodXJsLnBhdGhUb0ZpbGVVUkwoc291cmNlVXJsKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0KHVybCwgaGVhZGVycywgY2FsbGJhY2spIHtcbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgY29uc3QgaHR0cCA9IE5vZGVQYWNrYWdlcy5nZXQoXCJodHRwXCIpO1xuICAgIHJldHVybiBodHRwLnJlcXVlc3QodXJsLCB7XG4gICAgICBoZWFkZXJzXG4gICAgfSwgY2FsbGJhY2spO1xuICB9XG4gIGNvbnN0IGh0dHBzID0gTm9kZVBhY2thZ2VzLmdldChcImh0dHBzXCIpO1xuICByZXR1cm4gaHR0cHMucmVxdWVzdCh1cmwsIHtcbiAgICBoZWFkZXJzXG4gIH0sIGNhbGxiYWNrKTtcbn1cbmNsYXNzIFBERk5vZGVTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnVybCA9IHBhcnNlVXJsT3JQYXRoKHNvdXJjZS51cmwpO1xuICAgIHRoaXMuaXNIdHRwID0gdGhpcy51cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIiB8fCB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbiAgICB0aGlzLmlzRnNVcmwgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiO1xuICAgIHRoaXMuaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5pc0h0dHAsIHNvdXJjZS5odHRwSGVhZGVycyk7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpIDogbmV3IFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKSA6IG5ldyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJhbmdlUmVhZGVyKTtcbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBhd2FpdCB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBjb25zdCBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICByZXR1cm4gdGhpcy5yZWFkKCk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICB0b3RhbDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuX2Vycm9yKG5ldyBBYm9ydEV4Y2VwdGlvbihcInN0cmVhbWluZyBpcyBkaXNhYmxlZFwiKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcyhzdHJlYW0uaGVhZGVycyk7XG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuX3JlYWRhYmxlU3RyZWFtLmhlYWRlcnMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBpc0h0dHA6IHN0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgIH07XG4gICAgdGhpcy5fcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QodGhpcy5fdXJsLCBoZWFkZXJzLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgdGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICAgIHRoaXMuX3JlcXVlc3QuZW5kKCk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlciBleHRlbmRzIEJhc2VSYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgc3RhcnQsIGVuZCkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5mcm9tRW50cmllcyhzdHJlYW0uaGVhZGVycyk7XG4gICAgaGVhZGVycy5SYW5nZSA9IGBieXRlcz0ke3N0YXJ0fS0ke2VuZCAtIDF9YDtcbiAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3RoaXMuX3VybH1cIi5gKTtcbiAgICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UpO1xuICAgIH07XG4gICAgdGhpcy5fcmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3QodGhpcy5fdXJsLCBoZWFkZXJzLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgdGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0LmVuZCgpO1xuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIGV4dGVuZHMgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGNvbnN0IGZzID0gTm9kZVBhY2thZ2VzLmdldChcImZzXCIpO1xuICAgIGZzLnByb21pc2VzLmxzdGF0KHRoaXMuX3VybCkudGhlbihzdGF0ID0+IHtcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdGF0LnNpemU7XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCkpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIGVycm9yID0+IHtcbiAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIGVycm9yID0gbmV3IE1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGNvbnN0IGZzID0gTm9kZVBhY2thZ2VzLmdldChcImZzXCIpO1xuICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0odGhpcy5fdXJsLCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZDogZW5kIC0gMVxuICAgIH0pKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS90ZXh0X2xheWVyLmpzXG5cblxuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY29uc3QgREVGQVVMVF9GT05UX0FTQ0VOVCA9IDAuODtcbmNsYXNzIFRleHRMYXllciB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjZGlzYWJsZVByb2Nlc3NJdGVtcyA9IGZhbHNlO1xuICAjZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgI2xhbmcgPSBudWxsO1xuICAjbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICNwYWdlSGVpZ2h0ID0gMDtcbiAgI3BhZ2VXaWR0aCA9IDA7XG4gICNyZWFkZXIgPSBudWxsO1xuICAjcm9vdENvbnRhaW5lciA9IG51bGw7XG4gICNyb3RhdGlvbiA9IDA7XG4gICNzY2FsZSA9IDA7XG4gICNzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI3RleHRDb250ZW50SXRlbXNTdHIgPSBbXTtcbiAgI3RleHRDb250ZW50U291cmNlID0gbnVsbDtcbiAgI3RleHREaXZzID0gW107XG4gICN0ZXh0RGl2UHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gICN0cmFuc2Zvcm0gPSBudWxsO1xuICBzdGF0aWMgI2FzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0N0eEZvbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljICNtaW5Gb250U2l6ZSA9IG51bGw7XG4gIHN0YXRpYyAjcGVuZGluZ1RleHRMYXllcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGlmICh0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRleHRDb250ZW50U291cmNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dENvbnRlbnRTb3VyY2UpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJ0ZXh0Q29udGVudFNvdXJjZVwiIHBhcmFtZXRlciBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgdGhpcy4jcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgZGl2OiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogbnVsbFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLiNwYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy4jcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgVGV4dExheWVyLiNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCk7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICAgICB0aGlzLiNzdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgc3RhdGljIGdldCBmb250RmFtaWx5TWFwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luZG93cyxcbiAgICAgIGlzRmlyZWZveFxuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJmb250RmFtaWx5TWFwXCIsIG5ldyBNYXAoW1tcInNhbnMtc2VyaWZcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiQ2FsaWJyaSwgXCIgOiBcIlwifXNhbnMtc2VyaWZgXSwgW1wibW9ub3NwYWNlXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkx1Y2lkYSBDb25zb2xlLCBcIiA6IFwiXCJ9bW9ub3NwYWNlYF1dKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNyZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLiNzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICB0aGlzLiNwcm9jZXNzSXRlbXModmFsdWUuaXRlbXMpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfTtcbiAgICB0aGlzLiNyZWFkZXIgPSB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmFkZCh0aGlzKTtcbiAgICBwdW1wKCk7XG4gICAgcmV0dXJuIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0LFxuICAgIG9uQmVmb3JlID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT09IHRoaXMuI3JvdGF0aW9uKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuI3Jvb3RDb250YWluZXIsIHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgIT09IHRoaXMuI3NjYWxlKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNzY2FsZSA9IHNjYWxlO1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgIGN0eDogVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZylcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiN0ZXh0RGl2cykge1xuICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgICB0aGlzLiNsYXlvdXQocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IGFib3J0RXggPSBuZXcgQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpO1xuICAgIHRoaXMuI3JlYWRlcj8uY2FuY2VsKGFib3J0RXgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNyZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KGFib3J0RXgpO1xuICB9XG4gIGdldCB0ZXh0RGl2cygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dERpdnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50SXRlbXNTdHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gIH1cbiAgI3Byb2Nlc3NJdGVtcyhpdGVtcykge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuY3R4ID8/PSBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKTtcbiAgICBjb25zdCB0ZXh0RGl2cyA9IHRoaXMuI3RleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAodGV4dERpdnMubGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgICAgd2FybihcIklnbm9yaW5nIGFkZGl0aW9uYWwgdGV4dERpdnMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXCIpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIHRoaXMuI2FwcGVuZFRleHQoaXRlbSk7XG4gICAgfVxuICB9XG4gICNhcHBlbmRUZXh0KGdlb20pIHtcbiAgICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB7XG4gICAgICBhbmdsZTogMCxcbiAgICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIHRoaXMuI3RleHREaXZzLnB1c2godGV4dERpdik7XG4gICAgY29uc3QgdHggPSBVdGlsLnRyYW5zZm9ybSh0aGlzLiN0cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLiNzdHlsZUNhY2hlW2dlb20uZm9udE5hbWVdO1xuICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICAgIGxldCBmb250RmFtaWx5ID0gdGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQgJiYgc3R5bGUuZm9udFN1YnN0aXR1dGlvbiB8fCBzdHlsZS5mb250RmFtaWx5O1xuICAgIGZvbnRGYW1pbHkgPSBUZXh0TGF5ZXIuZm9udEZhbWlseU1hcC5nZXQoZm9udEZhbWlseSkgfHwgZm9udEZhbWlseTtcbiAgICBjb25zdCBmb250SGVpZ2h0ID0gTWF0aC5oeXBvdCh0eFsyXSwgdHhbM10pO1xuICAgIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogVGV4dExheWVyLiNnZXRBc2NlbnQoZm9udEZhbWlseSwgdGhpcy4jbGFuZyk7XG4gICAgbGV0IGxlZnQsIHRvcDtcbiAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgIGxlZnQgPSB0eFs0XTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IHR4WzRdICsgZm9udEFzY2VudCAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHRvcCA9IHR4WzVdIC0gZm9udEFzY2VudCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVGYWN0b3JTdHIgPSBcImNhbGModmFyKC0tc2NhbGUtZmFjdG9yKSpcIjtcbiAgICBjb25zdCBkaXZTdHlsZSA9IHRleHREaXYuc3R5bGU7XG4gICAgaWYgKHRoaXMuI2NvbnRhaW5lciA9PT0gdGhpcy4jcm9vdENvbnRhaW5lcikge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAkeygxMDAgKiBsZWZ0IC8gdGhpcy4jcGFnZVdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7KDEwMCAqIHRvcCAvIHRoaXMuI3BhZ2VIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdlN0eWxlLmxlZnQgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2xlZnQudG9GaXhlZCgyKX1weClgO1xuICAgICAgZGl2U3R5bGUudG9wID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHt0b3AudG9GaXhlZCgyKX1weClgO1xuICAgIH1cbiAgICBkaXZTdHlsZS5mb250U2l6ZSA9IGAke3NjYWxlRmFjdG9yU3RyfSR7KFRleHRMYXllci4jbWluRm9udFNpemUgKiBmb250SGVpZ2h0KS50b0ZpeGVkKDIpfXB4KWA7XG4gICAgZGl2U3R5bGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICAgIHRleHREaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG4gICAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgICBpZiAodGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQpIHtcbiAgICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IHN0eWxlLmZvbnRTdWJzdGl0dXRpb25Mb2FkZWROYW1lIHx8IGdlb20uZm9udE5hbWU7XG4gICAgfVxuICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuYW5nbGUgPSBhbmdsZSAqICgxODAgLyBNYXRoLlBJKTtcbiAgICB9XG4gICAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuICAgIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ2VvbS5zdHIgIT09IFwiIFwiICYmIGdlb20udHJhbnNmb3JtWzBdICE9PSBnZW9tLnRyYW5zZm9ybVszXSkge1xuICAgICAgY29uc3QgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLFxuICAgICAgICBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgICBpZiAoYWJzU2NhbGVYICE9PSBhYnNTY2FsZVkgJiYgTWF0aC5tYXgoYWJzU2NhbGVYLCBhYnNTY2FsZVkpIC8gTWF0aC5taW4oYWJzU2NhbGVYLCBhYnNTY2FsZVkpID4gMS41KSB7XG4gICAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gICAgfVxuICAgIHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5kaXYgPSB0ZXh0RGl2O1xuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMucHJvcGVydGllcyA9IHRleHREaXZQcm9wZXJ0aWVzO1xuICAgIHRoaXMuI2xheW91dCh0aGlzLiNsYXlvdXRUZXh0UGFyYW1zKTtcbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZCh0ZXh0RGl2KTtcbiAgICB9XG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmhhc0VPTCkge1xuICAgICAgY29uc3QgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIik7XG4gICAgICBici5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChicik7XG4gICAgfVxuICB9XG4gICNsYXlvdXQocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2LFxuICAgICAgcHJvcGVydGllcyxcbiAgICAgIGN0eFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuICAgIGlmIChUZXh0TGF5ZXIuI21pbkZvbnRTaXplID4gMSkge1xuICAgICAgdHJhbnNmb3JtID0gYHNjYWxlKCR7MSAvIFRleHRMYXllci4jbWluRm9udFNpemV9KWA7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHByb3BlcnRpZXMuaGFzVGV4dCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb250RmFtaWx5XG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhbnZhc1dpZHRoLFxuICAgICAgICBmb250U2l6ZVxuICAgICAgfSA9IHByb3BlcnRpZXM7XG4gICAgICBUZXh0TGF5ZXIuI2Vuc3VyZUN0eEZvbnQoY3R4LCBmb250U2l6ZSAqIHRoaXMuI3NjYWxlLCBmb250RmFtaWx5KTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGhcbiAgICAgIH0gPSBjdHgubWVhc3VyZVRleHQoZGl2LnRleHRDb250ZW50KTtcbiAgICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gYHNjYWxlWCgke2NhbnZhc1dpZHRoICogdGhpcy4jc2NhbGUgLyB3aWR0aH0pICR7dHJhbnNmb3JtfWA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgcm90YXRlKCR7cHJvcGVydGllcy5hbmdsZX1kZWcpICR7dHJhbnNmb3JtfWA7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy4jcGVuZGluZ1RleHRMYXllcnMuc2l6ZSA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYXNjZW50Q2FjaGUuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGNhbnZhc1xuICAgIH0gb2YgdGhpcy4jY2FudmFzQ29udGV4dHMudmFsdWVzKCkpIHtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGhpcy4jY2FudmFzQ29udGV4dHMuY2xlYXIoKTtcbiAgfVxuICBzdGF0aWMgI2dldEN0eChsYW5nID0gbnVsbCkge1xuICAgIGxldCBjdHggPSB0aGlzLiNjYW52YXNDb250ZXh0cy5nZXQobGFuZyB8fD0gXCJcIik7XG4gICAgaWYgKCFjdHgpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJoaWRkZW5DYW52YXNFbGVtZW50XCI7XG4gICAgICBjYW52YXMubGFuZyA9IGxhbmc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChjYW52YXMpO1xuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIGFscGhhOiBmYWxzZSxcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRzLnNldChsYW5nLCBjdHgpO1xuICAgICAgdGhpcy4jY2FudmFzQ3R4Rm9udHMuc2V0KGN0eCwge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICBmYW1pbHk6IFwiXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3R4O1xuICB9XG4gIHN0YXRpYyAjZW5zdXJlQ3R4Rm9udChjdHgsIHNpemUsIGZhbWlseSkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuI2NhbnZhc0N0eEZvbnRzLmdldChjdHgpO1xuICAgIGlmIChzaXplID09PSBjYWNoZWQuc2l6ZSAmJiBmYW1pbHkgPT09IGNhY2hlZC5mYW1pbHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LmZvbnQgPSBgJHtzaXplfXB4ICR7ZmFtaWx5fWA7XG4gICAgY2FjaGVkLnNpemUgPSBzaXplO1xuICAgIGNhY2hlZC5mYW1pbHkgPSBmYW1pbHk7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCkge1xuICAgIGlmICh0aGlzLiNtaW5Gb250U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICBkaXYuc3R5bGUubGluZUhlaWdodCA9IDE7XG4gICAgZGl2LnN0eWxlLmZvbnRTaXplID0gXCIxcHhcIjtcbiAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgZGl2LnRleHRDb250ZW50ID0gXCJYXCI7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB0aGlzLiNtaW5Gb250U2l6ZSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgZGl2LnJlbW92ZSgpO1xuICB9XG4gIHN0YXRpYyAjZ2V0QXNjZW50KGZvbnRGYW1pbHksIGxhbmcpIHtcbiAgICBjb25zdCBjYWNoZWRBc2NlbnQgPSB0aGlzLiNhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gICAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEFzY2VudDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy4jZ2V0Q3R4KGxhbmcpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIHRoaXMuI2Vuc3VyZUN0eEZvbnQoY3R4LCBERUZBVUxUX0ZPTlRfU0laRSwgZm9udEZhbWlseSk7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChcIlwiKTtcbiAgICBsZXQgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgbGV0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICAgIGlmIChhc2NlbnQpIHtcbiAgICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgICAgdGhpcy4jYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm4gcmF0aW87XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpO1xuICAgIGN0eC5zdHJva2VUZXh0KFwiZ1wiLCAwLCAwKTtcbiAgICBsZXQgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpLmRhdGE7XG4gICAgZGVzY2VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHBpeGVscy5sZW5ndGggLSAxIC0gMzsgaSA+PSAwOyBpIC09IDQpIHtcbiAgICAgIGlmIChwaXhlbHNbaV0gPiAwKSB7XG4gICAgICAgIGRlc2NlbnQgPSBNYXRoLmNlaWwoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgY3R4LnN0cm9rZVRleHQoXCJBXCIsIDAsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICBwaXhlbHMgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSkuZGF0YTtcbiAgICBhc2NlbnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBpeGVscy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgICBhc2NlbnQgPSBERUZBVUxUX0ZPTlRfU0laRSAtIE1hdGguZmxvb3IoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50ID8gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpIDogREVGQVVMVF9GT05UX0FTQ0VOVDtcbiAgICB0aGlzLiNhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfdGV4dC5qc1xuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFID0gNjU1MzY7XG5jb25zdCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG5jb25zdCBERUxBWUVEX0NMRUFOVVBfVElNRU9VVCA9IDUwMDA7XG5jb25zdCBEZWZhdWx0Q2FudmFzRmFjdG9yeSA9IGlzTm9kZUpTID8gTm9kZUNhbnZhc0ZhY3RvcnkgOiBET01DYW52YXNGYWN0b3J5O1xuY29uc3QgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gaXNOb2RlSlMgPyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgOiBET01DTWFwUmVhZGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gaXNOb2RlSlMgPyBOb2RlRmlsdGVyRmFjdG9yeSA6IERPTUZpbHRlckZhY3Rvcnk7XG5jb25zdCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBpc05vZGVKUyA/IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA6IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjID0ge30pIHtcbiAgaWYgKHR5cGVvZiBzcmMgPT09IFwic3RyaW5nXCIgfHwgc3JjIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgc3JjID0ge1xuICAgICAgdXJsOiBzcmNcbiAgICB9O1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhzcmMpKSB7XG4gICAgc3JjID0ge1xuICAgICAgZGF0YTogc3JjXG4gICAgfTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgY29uc3Qge1xuICAgIGRvY0lkXG4gIH0gPSB0YXNrO1xuICBjb25zdCB1cmwgPSBzcmMudXJsID8gZ2V0VXJsUHJvcChzcmMudXJsKSA6IG51bGw7XG4gIGNvbnN0IGRhdGEgPSBzcmMuZGF0YSA/IGdldERhdGFQcm9wKHNyYy5kYXRhKSA6IG51bGw7XG4gIGNvbnN0IGh0dHBIZWFkZXJzID0gc3JjLmh0dHBIZWFkZXJzIHx8IG51bGw7XG4gIGNvbnN0IHdpdGhDcmVkZW50aWFscyA9IHNyYy53aXRoQ3JlZGVudGlhbHMgPT09IHRydWU7XG4gIGNvbnN0IHBhc3N3b3JkID0gc3JjLnBhc3N3b3JkID8/IG51bGw7XG4gIGNvbnN0IHJhbmdlVHJhbnNwb3J0ID0gc3JjLnJhbmdlIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0ID8gc3JjLnJhbmdlIDogbnVsbDtcbiAgY29uc3QgcmFuZ2VDaHVua1NpemUgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5yYW5nZUNodW5rU2l6ZSkgJiYgc3JjLnJhbmdlQ2h1bmtTaXplID4gMCA/IHNyYy5yYW5nZUNodW5rU2l6ZSA6IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRTtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNEYXRhU2NoZW1lKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IHR5cGVvZiBzcmMuY01hcFVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5jTWFwVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gdHlwZW9mIHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsID09PSBcInN0cmluZ1wiID8gc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFpc05vZGVKUztcbiAgY29uc3QgaXNDaHJvbWUgPSB0eXBlb2Ygc3JjLmlzQ2hyb21lID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc0Nocm9tZSA6ICF1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzRmlyZWZveCAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICEhd2luZG93Py5jaHJvbWU7XG4gIGNvbnN0IGNhbnZhc01heEFyZWFJbkJ5dGVzID0gTnVtYmVyLmlzSW50ZWdlcihzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMpID8gc3JjLmNhbnZhc01heEFyZWFJbkJ5dGVzIDogLTE7XG4gIGNvbnN0IGRpc2FibGVGb250RmFjZSA9IHR5cGVvZiBzcmMuZGlzYWJsZUZvbnRGYWNlID09PSBcImJvb2xlYW5cIiA/IHNyYy5kaXNhYmxlRm9udEZhY2UgOiBpc05vZGVKUztcbiAgY29uc3QgZm9udEV4dHJhUHJvcGVydGllcyA9IHNyYy5mb250RXh0cmFQcm9wZXJ0aWVzID09PSB0cnVlO1xuICBjb25zdCBlbmFibGVYZmEgPSBzcmMuZW5hYmxlWGZhID09PSB0cnVlO1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gc3JjLm93bmVyRG9jdW1lbnQgfHwgZ2xvYmFsVGhpcy5kb2N1bWVudDtcbiAgY29uc3QgZGlzYWJsZVJhbmdlID0gc3JjLmRpc2FibGVSYW5nZSA9PT0gdHJ1ZTtcbiAgY29uc3QgZGlzYWJsZVN0cmVhbSA9IHNyYy5kaXNhYmxlU3RyZWFtID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlQXV0b0ZldGNoID0gc3JjLmRpc2FibGVBdXRvRmV0Y2ggPT09IHRydWU7XG4gIGNvbnN0IHBkZkJ1ZyA9IHNyYy5wZGZCdWcgPT09IHRydWU7XG4gIGNvbnN0IENhbnZhc0ZhY3RvcnkgPSBzcmMuQ2FudmFzRmFjdG9yeSB8fCBEZWZhdWx0Q2FudmFzRmFjdG9yeTtcbiAgY29uc3QgRmlsdGVyRmFjdG9yeSA9IHNyYy5GaWx0ZXJGYWN0b3J5IHx8IERlZmF1bHRGaWx0ZXJGYWN0b3J5O1xuICBjb25zdCBlbmFibGVIV0EgPSBzcmMuZW5hYmxlSFdBID09PSB0cnVlO1xuICBjb25zdCBsZW5ndGggPSByYW5nZVRyYW5zcG9ydCA/IHJhbmdlVHJhbnNwb3J0Lmxlbmd0aCA6IHNyYy5sZW5ndGggPz8gTmFOO1xuICBjb25zdCB1c2VTeXN0ZW1Gb250cyA9IHR5cGVvZiBzcmMudXNlU3lzdGVtRm9udHMgPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVN5c3RlbUZvbnRzIDogIWlzTm9kZUpTICYmICFkaXNhYmxlRm9udEZhY2U7XG4gIGNvbnN0IHVzZVdvcmtlckZldGNoID0gdHlwZW9mIHNyYy51c2VXb3JrZXJGZXRjaCA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlV29ya2VyRmV0Y2ggOiBDTWFwUmVhZGVyRmFjdG9yeSA9PT0gRE9NQ01hcFJlYWRlckZhY3RvcnkgJiYgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPT09IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ICYmIGNNYXBVcmwgJiYgc3RhbmRhcmRGb250RGF0YVVybCAmJiBpc1ZhbGlkRmV0Y2hVcmwoY01hcFVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgaXNWYWxpZEZldGNoVXJsKHN0YW5kYXJkRm9udERhdGFVcmwsIGRvY3VtZW50LmJhc2VVUkkpO1xuICBpZiAoc3JjLmNhbnZhc0ZhY3RvcnkpIHtcbiAgICBkZXByZWNhdGVkKFwiYGNhbnZhc0ZhY3RvcnlgLWluc3RhbmNlIG9wdGlvbiwgcGxlYXNlIHVzZSBgQ2FudmFzRmFjdG9yeWAgaW5zdGVhZC5cIik7XG4gIH1cbiAgaWYgKHNyYy5maWx0ZXJGYWN0b3J5KSB7XG4gICAgZGVwcmVjYXRlZChcImBmaWx0ZXJGYWN0b3J5YC1pbnN0YW5jZSBvcHRpb24sIHBsZWFzZSB1c2UgYEZpbHRlckZhY3RvcnlgIGluc3RlYWQuXCIpO1xuICB9XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gIHNldFZlcmJvc2l0eUxldmVsKHZlcmJvc2l0eSk7XG4gIGNvbnN0IHRyYW5zcG9ydEZhY3RvcnkgPSB7XG4gICAgY2FudmFzRmFjdG9yeTogbmV3IENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgb3duZXJEb2N1bWVudCxcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pLFxuICAgIGZpbHRlckZhY3Rvcnk6IG5ldyBGaWx0ZXJGYWN0b3J5KHtcbiAgICAgIGRvY0lkLFxuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0pLFxuICAgIGNNYXBSZWFkZXJGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pLFxuICAgIHN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pXG4gIH07XG4gIGlmICghd29ya2VyKSB7XG4gICAgY29uc3Qgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0XG4gICAgfTtcbiAgICB3b3JrZXIgPSB3b3JrZXJQYXJhbXMucG9ydCA/IFBERldvcmtlci5mcm9tUG9ydCh3b3JrZXJQYXJhbXMpIDogbmV3IFBERldvcmtlcih3b3JrZXJQYXJhbXMpO1xuICAgIHRhc2suX3dvcmtlciA9IHdvcmtlcjtcbiAgfVxuICBjb25zdCBkb2NQYXJhbXMgPSB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogXCI0LjguNjlcIixcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgaXNDaHJvbWUsXG4gICAgICBjYW52YXNNYXhBcmVhSW5CeXRlcyxcbiAgICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgICB1c2VTeXN0ZW1Gb250cyxcbiAgICAgIGNNYXBVcmw6IHVzZVdvcmtlckZldGNoID8gY01hcFVybCA6IG51bGwsXG4gICAgICBzdGFuZGFyZEZvbnREYXRhVXJsOiB1c2VXb3JrZXJGZXRjaCA/IHN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsXG4gICAgfVxuICB9O1xuICBjb25zdCB0cmFuc3BvcnRQYXJhbXMgPSB7XG4gICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50LFxuICAgIGxvYWRpbmdQYXJhbXM6IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtlcklkUHJvbWlzZSA9IHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIGRvY1BhcmFtcywgZGF0YSA/IFtkYXRhLmJ1ZmZlcl0gOiBudWxsKTtcbiAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICBpZiAocmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbShyYW5nZVRyYW5zcG9ydCwge1xuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldERvY3VtZW50IC0gbm8gYHVybGAgcGFyYW1ldGVyIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBOZXR3b3JrU3RyZWFtO1xuICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgIGNvbnN0IGlzRmV0Y2hTdXBwb3J0ZWQgPSB0eXBlb2YgZmV0Y2ggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFJlc3BvbnNlICE9PSBcInVuZGVmaW5lZFwiICYmIFwiYm9keVwiIGluIFJlc3BvbnNlLnByb3RvdHlwZTtcbiAgICAgICAgTmV0d29ya1N0cmVhbSA9IGlzRmV0Y2hTdXBwb3J0ZWQgJiYgaXNWYWxpZEZldGNoVXJsKHVybCkgPyBQREZGZXRjaFN0cmVhbSA6IFBERk5vZGVTdHJlYW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBOZXR3b3JrU3RyZWFtID0gaXNWYWxpZEZldGNoVXJsKHVybCkgPyBQREZGZXRjaFN0cmVhbSA6IFBERk5ldHdvcmtTdHJlYW07XG4gICAgICB9XG4gICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IE5ldHdvcmtTdHJlYW0oe1xuICAgICAgICB1cmwsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgaHR0cEhlYWRlcnMsXG4gICAgICAgIHdpdGhDcmVkZW50aWFscyxcbiAgICAgICAgcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgZGlzYWJsZVN0cmVhbVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3b3JrZXJJZFByb21pc2UudGhlbih3b3JrZXJJZCA9PiB7XG4gICAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihkb2NJZCwgd29ya2VySWQsIHdvcmtlci5wb3J0KTtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBXb3JrZXJUcmFuc3BvcnQobWVzc2FnZUhhbmRsZXIsIHRhc2ssIG5ldHdvcmtTdHJlYW0sIHRyYW5zcG9ydFBhcmFtcywgdHJhbnNwb3J0RmFjdG9yeSk7XG4gICAgICB0YXNrLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiUmVhZHlcIiwgbnVsbCk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKHRhc2suX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgcmV0dXJuIHRhc2s7XG59XG5mdW5jdGlvbiBnZXRVcmxQcm9wKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcmV0dXJuIHZhbC5ocmVmO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodmFsLCB3aW5kb3cubG9jYXRpb24pLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIGlmIChpc05vZGVKUyAmJiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiB1cmwgZGF0YTogXCIgKyBcImVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbCk7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpIHx8IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIWlzTmFOKHZhbD8ubGVuZ3RoKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIGJpbmFyeSBkYXRhOiBlaXRoZXIgVHlwZWRBcnJheSwgXCIgKyBcInN0cmluZywgb3IgYXJyYXktbGlrZSBvYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIGRhdGEgcHJvcGVydHkuXCIpO1xufVxuZnVuY3Rpb24gaXNSZWZQcm94eShyZWYpIHtcbiAgcmV0dXJuIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiYgTnVtYmVyLmlzSW50ZWdlcihyZWY/Lm51bSkgJiYgcmVmLm51bSA+PSAwICYmIE51bWJlci5pc0ludGVnZXIocmVmPy5nZW4pICYmIHJlZi5nZW4gPj0gMDtcbn1cbmNsYXNzIFBERkRvY3VtZW50TG9hZGluZ1Rhc2sge1xuICBzdGF0aWMgI2RvY0lkID0gMDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICB0aGlzLmRvY0lkID0gYGQke1BERkRvY3VtZW50TG9hZGluZ1Rhc2suI2RvY0lkKyt9YDtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMub25QYXNzd29yZCA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGFzeW5jIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3kgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0Py5kZXN0cm95KCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICh0aGlzLl93b3JrZXI/LnBvcnQpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3dvcmtlci5fcGVuZGluZ0Rlc3Ryb3k7XG4gICAgICB9XG4gICAgICB0aHJvdyBleDtcbiAgICB9XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fd29ya2VyKSB7XG4gICAgICB0aGlzLl93b3JrZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBERkRhdGFSYW5nZVRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKGxlbmd0aCwgaW5pdGlhbERhdGEsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmluaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgdGhpcy5wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIFBERkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlXCIpO1xuICB9XG4gIGFib3J0KCkge31cbn1cbmNsYXNzIFBERkRvY3VtZW50UHJveHkge1xuICBjb25zdHJ1Y3RvcihwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuYW5ub3RhdGlvblN0b3JhZ2U7XG4gIH1cbiAgZ2V0IGNhbnZhc0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5O1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBnZXQgYWxsWGZhSHRtbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbnMoKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb24oaWQpO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYXlvdXQoKTtcbiAgfVxuICBnZXRQYWdlTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VNb2RlKCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcGVuQWN0aW9uKCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBdHRhY2htZW50cygpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERvY0pTQWN0aW9ucygpO1xuICB9XG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPdXRsaW5lKCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKHJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE1hcmtJbmZvKCk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERhdGEoKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zYXZlRG9jdW1lbnQoKTtcbiAgfVxuICBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyB8fCB0aGlzLmlzUHVyZVhmYSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cbiAgY2FjaGVkUGFnZU51bWJlcihyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmNhY2hlZFBhZ2VOdW1iZXIocmVmKTtcbiAgfVxuICBnZXQgbG9hZGluZ1BhcmFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gIH1cbiAgZ2V0IGxvYWRpbmdUYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RmllbGRPYmplY3RzKCk7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuaGFzSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgfVxufVxuY2xhc3MgUERGUGFnZVByb3h5IHtcbiAgI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0cmFuc3BvcnQsIHBkZkJ1ZyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuX3BhZ2VJbmZvID0gcGFnZUluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIHRoaXMuX3N0YXRzID0gcGRmQnVnID8gbmV3IFN0YXRUaW1lcigpIDogbnVsbDtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5jb21tb25PYmpzID0gdHJhbnNwb3J0LmNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLl9tYXliZUNsZWFudXBBZnRlclJlbmRlciA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwYWdlTnVtYmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICB9XG4gIGdldCByb3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJvdGF0ZTtcbiAgfVxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cbiAgZ2V0IHVzZXJVbml0KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgfVxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udmlldztcbiAgfVxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cbiAgZ2V0QW5ub3RhdGlvbnMoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmluZ0ludGVudFxuICAgIH0gPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9ucyh0aGlzLl9wYWdlSW5kZXgsIHJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUpTQWN0aW9ucyh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGFzeW5jIGdldFhmYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhPy5jaGlsZHJlblt0aGlzLl9wYWdlSW5kZXhdIHx8IG51bGw7XG4gIH1cbiAgcmVuZGVyKHtcbiAgICBjYW52YXNDb250ZXh0LFxuICAgIHZpZXdwb3J0LFxuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHRyYW5zZm9ybSA9IG51bGwsXG4gICAgYmFja2dyb3VuZCA9IG51bGwsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IG51bGwsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGwsXG4gICAgcGFnZUNvbG9ycyA9IG51bGwsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsXG4gICAgaXNFZGl0aW5nID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiT3ZlcmFsbFwiKTtcbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlLCBpc0VkaXRpbmcpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5XG4gICAgfSA9IGludGVudEFyZ3M7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSB8fD0gdGhpcy5fdHJhbnNwb3J0LmdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpO1xuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpbnRlbnRQcmludCA9ICEhKHJlbmRlcmluZ0ludGVudCAmIFJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gZXJyb3IgPT4ge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgICBpZiAodGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgfHwgaW50ZW50UHJpbnQpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCghaW50ZW50UHJpbnQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICByZWFzb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIlJlbmRlcmluZ1wiKTtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIk92ZXJhbGxcIik7XG4gICAgICAgIGlmIChnbG9iYWxUaGlzLlN0YXRzPy5lbmFibGVkKSB7XG4gICAgICAgICAgZ2xvYmFsVGhpcy5TdGF0cy5hZGQodGhpcy5wYWdlTnVtYmVyLCB0aGlzLl9zdGF0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICBjb21tb25PYmpzOiB0aGlzLmNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5LFxuICAgICAgZmlsdGVyRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3RvcnksXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6ICFpbnRlbnRQcmludCxcbiAgICAgIHBkZkJ1ZzogdGhpcy5fcGRmQnVnLFxuICAgICAgcGFnZUNvbG9yc1xuICAgIH0pO1xuICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICBjb25zdCByZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrLnRhc2s7XG4gICAgUHJvbWlzZS5hbGwoW2ludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucHJvbWlzZSwgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZV0pLnRoZW4oKFt0cmFuc3BhcmVuY3ksIG9wdGlvbmFsQ29udGVudENvbmZpZ10pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlJlbmRlcmluZ1wiKTtcbiAgICAgIGlmICghKG9wdGlvbmFsQ29udGVudENvbmZpZy5yZW5kZXJpbmdJbnRlbnQgJiByZW5kZXJpbmdJbnRlbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgdXNlIHRoZSBzYW1lIGBpbnRlbnRgLWFyZ3VtZW50IHdoZW4gY2FsbGluZyB0aGUgYFBERlBhZ2VQcm94eS5yZW5kZXJgIFwiICsgXCJhbmQgYFBERkRvY3VtZW50UHJveHkuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnYCBtZXRob2RzLlwiKTtcbiAgICAgIH1cbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5pbml0aWFsaXplR3JhcGhpY3Moe1xuICAgICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgfSk7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH0pLmNhdGNoKGNvbXBsZXRlKTtcbiAgICByZXR1cm4gcmVuZGVyVGFzaztcbiAgfVxuICBnZXRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShvcExpc3RUYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgaXNFZGl0aW5nLCB0cnVlKTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoaW50ZW50QXJncy5jYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBsZXQgb3BMaXN0VGFzaztcbiAgICBpZiAoIWludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICBvcExpc3RUYXNrID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG9wTGlzdFRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCA9IG9wZXJhdG9yTGlzdENoYW5nZWQ7XG4gICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChvcExpc3RUYXNrKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzdHJlYW1UZXh0Q29udGVudCh7XG4gICAgaW5jbHVkZU1hcmtlZENvbnRlbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlTm9ybWFsaXphdGlvbiA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFID0gMTAwO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRUZXh0Q29udGVudFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50OiBpbmNsdWRlTWFya2VkQ29udGVudCA9PT0gdHJ1ZSxcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBkaXNhYmxlTm9ybWFsaXphdGlvbiA9PT0gdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFLFxuICAgICAgc2l6ZSh0ZXh0Q29udGVudCkge1xuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRleHRDb250ZW50KHBhcmFtcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WGZhKCkudGhlbih4ZmEgPT4gWGZhVGV4dC50ZXh0Q29udGVudCh4ZmEpKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLnN0cmVhbVRleHRDb250ZW50KHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dENvbnRlbnQubGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRleHRDb250ZW50LnN0eWxlcywgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pdGVtcy5wdXNoKC4uLnZhbHVlLml0ZW1zKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0ge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgbGFuZzogbnVsbFxuICAgICAgfTtcbiAgICAgIHB1bXAoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0U3RydWN0VHJlZSh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGludGVudFN0YXRlIG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgcmVhc29uOiBuZXcgRXJyb3IoXCJQYWdlIHdhcyBkZXN0cm95ZWQuXCIpLFxuICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgfVxuICBjbGVhbnVwKHJlc2V0U3RhdHMgPSBmYWxzZSkge1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICBjb25zdCBzdWNjZXNzID0gdGhpcy4jdHJ5Q2xlYW51cChmYWxzZSk7XG4gICAgaWYgKHJlc2V0U3RhdHMgJiYgc3VjY2Vzcykge1xuICAgICAgdGhpcy5fc3RhdHMgJiY9IG5ldyBTdGF0VGltZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgI3RyeUNsZWFudXAoZGVsYXllZCA9IGZhbHNlKSB7XG4gICAgdGhpcy4jYWJvcnREZWxheWVkQ2xlYW51cCgpO1xuICAgIGlmICghdGhpcy4jcGVuZGluZ0NsZWFudXAgfHwgdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlbGF5ZWQpIHtcbiAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKGZhbHNlKTtcbiAgICAgIH0sIERFTEFZRURfQ0xFQU5VUF9USU1FT1VUKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICByZW5kZXJUYXNrcyxcbiAgICAgIG9wZXJhdG9yTGlzdFxuICAgIH0gb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICBpZiAocmVuZGVyVGFza3Muc2l6ZSA+IDAgfHwgIW9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gICNhYm9ydERlbGF5ZWRDbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQpO1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgX3N0YXJ0UmVuZGVyUGFnZSh0cmFuc3BhcmVuY3ksIGNhY2hlS2V5KSB7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHk/LnJlc29sdmUodHJhbnNwYXJlbmN5KTtcbiAgfVxuICBfcmVuZGVyUGFnZUNodW5rKG9wZXJhdG9yTGlzdENodW5rLCBpbnRlbnRTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG9wZXJhdG9yTGlzdENodW5rLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5mbkFycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuZm5BcnJheVtpXSk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuYXJnc0FycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuYXJnc0FycmF5W2ldKTtcbiAgICB9XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaztcbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3Quc2VwYXJhdGVBbm5vdHMgPSBvcGVyYXRvckxpc3RDaHVuay5zZXBhcmF0ZUFubm90cztcbiAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaykge1xuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCh0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICBjYWNoZUtleSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSxcbiAgICBtb2RpZmllZElkc1xuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGU7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIG1vZGlmaWVkSWRzXG4gICAgfSwgdHJhbnNmZXIpO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlYWRhYmxlU3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gcmVhZGVyO1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICByZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJQYWdlQ2h1bmsodmFsdWUsIGludGVudFN0YXRlKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBwdW1wKCk7XG4gIH1cbiAgX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnRTdGF0ZSxcbiAgICByZWFzb24sXG4gICAgZm9yY2UgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KTtcbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWZvcmNlKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUucmVuZGVyVGFza3Muc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlYXNvbiBpbnN0YW5jZW9mIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbikge1xuICAgICAgICBsZXQgZGVsYXkgPSBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQ7XG4gICAgICAgIGlmIChyZWFzb24uZXh0cmFEZWxheSA+IDAgJiYgcmVhc29uLmV4dHJhRGVsYXkgPCAxMDAwKSB7XG4gICAgICAgICAgZGVsYXkgKz0gcmVhc29uLmV4dHJhRGVsYXk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlci5jYW5jZWwobmV3IEFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbY3VyQ2FjaGVLZXksIGN1ckludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIGlmIChjdXJJbnRlbnRTdGF0ZSA9PT0gaW50ZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmRlbGV0ZShjdXJDYWNoZUtleSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKTtcbiAgfVxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG59XG5jbGFzcyBMb29wYmFja1BvcnQge1xuICAjbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xuICAjZGVmZXJyZWQgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgcG9zdE1lc3NhZ2Uob2JqLCB0cmFuc2Zlcikge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgZGF0YTogc3RydWN0dXJlZENsb25lKG9iaiwgdHJhbnNmZXIgPyB7XG4gICAgICAgIHRyYW5zZmVyXG4gICAgICB9IDogbnVsbClcbiAgICB9O1xuICAgIHRoaXMuI2RlZmVycmVkLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbbGlzdGVuZXJdIG9mIHRoaXMuI2xpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyLCBvcHRpb25zID0gbnVsbCkge1xuICAgIGxldCBybUFib3J0ID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucz8uc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICB3YXJuKFwiTG9vcGJhY2tQb3J0IC0gY2Fubm90IHVzZSBhbiBgYWJvcnRlZGAgc2lnbmFsLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICBybUFib3J0ID0gKCkgPT4gc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgfVxuICAgIHRoaXMuI2xpc3RlbmVycy5zZXQobGlzdGVuZXIsIHJtQWJvcnQpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBybUFib3J0ID0gdGhpcy4jbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XG4gICAgcm1BYm9ydD8uKCk7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgdGVybWluYXRlKCkge1xuICAgIGZvciAoY29uc3QgWywgcm1BYm9ydF0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICBybUFib3J0Py4oKTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn1cbmNsYXNzIFBERldvcmtlciB7XG4gIHN0YXRpYyAjZmFrZVdvcmtlcklkID0gMDtcbiAgc3RhdGljICNpc1dvcmtlckRpc2FibGVkID0gZmFsc2U7XG4gIHN0YXRpYyAjd29ya2VyUG9ydHM7XG4gIHN0YXRpYyB7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICB0aGlzLiNpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjIHx8PSBcIi4vcGRmLndvcmtlci5tanNcIjtcbiAgICB9XG4gICAgdGhpcy5faXNTYW1lT3JpZ2luID0gKGJhc2VVcmwsIG90aGVyVXJsKSA9PiB7XG4gICAgICBsZXQgYmFzZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGJhc2UgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgICBpZiAoIWJhc2Uub3JpZ2luIHx8IGJhc2Uub3JpZ2luID09PSBcIm51bGxcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG90aGVyID0gbmV3IFVSTChvdGhlclVybCwgYmFzZSk7XG4gICAgICByZXR1cm4gYmFzZS5vcmlnaW4gPT09IG90aGVyLm9yaWdpbjtcbiAgICB9O1xuICAgIHRoaXMuX2NyZWF0ZUNETldyYXBwZXIgPSB1cmwgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGBhd2FpdCBpbXBvcnQoXCIke3VybH1cIik7YDtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3cmFwcGVyXSwge1xuICAgICAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih7XG4gICAgbmFtZSA9IG51bGwsXG4gICAgcG9ydCA9IG51bGwsXG4gICAgdmVyYm9zaXR5ID0gZ2V0VmVyYm9zaXR5TGV2ZWwoKVxuICB9ID0ge30pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgaWYgKHBvcnQpIHtcbiAgICAgIGlmIChQREZXb3JrZXIuI3dvcmtlclBvcnRzPy5oYXMocG9ydCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBtb3JlIHRoYW4gb25lIFBERldvcmtlciBwZXIgcG9ydC5cIik7XG4gICAgICB9XG4gICAgICAoUERGV29ya2VyLiN3b3JrZXJQb3J0cyB8fD0gbmV3IFdlYWtNYXAoKSkuc2V0KHBvcnQsIHRoaXMpO1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW05vZGVQYWNrYWdlcy5wcm9taXNlLCB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgI3Jlc29sdmUoKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICB9KTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKFwibWFpblwiLCBcIndvcmtlclwiLCBwb3J0KTtcbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcbiAgICB0aGlzLiNyZXNvbHZlKCk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKFBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCB8fCBQREZXb3JrZXIuI21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7XG4gICAgICB3b3JrZXJTcmNcbiAgICB9ID0gUERGV29ya2VyO1xuICAgIHRyeSB7XG4gICAgICBpZiAoIVBERldvcmtlci5faXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgIHdvcmtlclNyYyA9IFBERldvcmtlci5fY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjLCB7XG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG4gICAgICBjb25zdCB0ZXJtaW5hdGVFYXJseSA9ICgpID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbDogYWMuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkIHx8ICFkYXRhKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgdGhpcy5fcG9ydCA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICB0aGlzLiNyZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlc3RPYmogPSBuZXcgVWludDhBcnJheSgpO1xuICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgIH07XG4gICAgICBzZW5kVGVzdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gY2F0Y2gge1xuICAgICAgaW5mbyhcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICBfc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICB3YXJuKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlci5cIik7XG4gICAgICBQREZXb3JrZXIuI2lzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9ydCA9IG5ldyBMb29wYmFja1BvcnQoKTtcbiAgICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgICAgY29uc3QgaWQgPSBgZmFrZSR7UERGV29ya2VyLiNmYWtlV29ya2VySWQrK31gO1xuICAgICAgY29uc3Qgd29ya2VySGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgICBXb3JrZXJNZXNzYWdlSGFuZGxlci5zZXR1cCh3b3JrZXJIYW5kbGVyLCBwb3J0KTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgIHRoaXMuI3Jlc29sdmUoKTtcbiAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgIHRoaXMuX3dlYldvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgfVxuICAgIFBERldvcmtlci4jd29ya2VyUG9ydHM/LmRlbGV0ZSh0aGlzLl9wb3J0KTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fbWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21Qb3J0KHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zPy5wb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWRQb3J0ID0gdGhpcy4jd29ya2VyUG9ydHM/LmdldChwYXJhbXMucG9ydCk7XG4gICAgaWYgKGNhY2hlZFBvcnQpIHtcbiAgICAgIGlmIChjYWNoZWRQb3J0Ll9wZW5kaW5nRGVzdHJveSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSB0aGUgd29ya2VyIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG5cIiArIFwiUGxlYXNlIHJlbWVtYmVyIHRvIGF3YWl0IGBQREZEb2N1bWVudExvYWRpbmdUYXNrLmRlc3Ryb3koKWAtY2FsbHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGV29ya2VyKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuICBzdGF0aWMgZ2V0ICNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCBpbXBvcnQoLyp3ZWJwYWNrSWdub3JlOiB0cnVlKi90aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9zZXR1cEZha2VXb3JrZXJHbG9iYWxcIiwgbG9hZGVyKCkpO1xuICB9XG59XG5jbGFzcyBXb3JrZXJUcmFuc3BvcnQge1xuICAjbWV0aG9kUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYWdlUHJvbWlzZXMgPSBuZXcgTWFwKCk7XG4gICNwYWdlUmVmQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICNwYXNzd29yZENhcGFiaWxpdHkgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcywgZmFjdG9yeSkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB0aGlzLmxvYWRpbmdUYXNrID0gbG9hZGluZ1Rhc2s7XG4gICAgdGhpcy5jb21tb25PYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmZvbnRMb2FkZXIgPSBuZXcgRm9udExvYWRlcih7XG4gICAgICBvd25lckRvY3VtZW50OiBwYXJhbXMub3duZXJEb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudDogcGFyYW1zLnN0eWxlRWxlbWVudFxuICAgIH0pO1xuICAgIHRoaXMubG9hZGluZ1BhcmFtcyA9IHBhcmFtcy5sb2FkaW5nUGFyYW1zO1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBmYWN0b3J5LmNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmFjdG9yeS5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuY01hcFJlYWRlckZhY3RvcnkgPSBmYWN0b3J5LmNNYXBSZWFkZXJGYWN0b3J5O1xuICAgIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBmYWN0b3J5LnN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fbmV0d29ya1N0cmVhbSA9IG5ldHdvcmtTdHJlYW07XG4gICAgdGhpcy5fZnVsbFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuICAjY2FjaGVTaW1wbGVNZXRob2QobmFtZSwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIGRhdGEpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzRWRpdGluZyA9IGZhbHNlLCBpc09wTGlzdCA9IGZhbHNlKSB7XG4gICAgbGV0IHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWTtcbiAgICBsZXQgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBTZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgaW50ZW50OiAke2ludGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgYW5ub3RhdGlvblN0b3JhZ2UgPSByZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UICYmIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgaW5zdGFuY2VvZiBQcmludEFubm90YXRpb25TdG9yYWdlID8gcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA6IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19GT1JNUztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGFubm90YXRpb25Nb2RlOiAke2Fubm90YXRpb25Nb2RlfWApO1xuICAgIH1cbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5JU19FRElUSU5HO1xuICAgIH1cbiAgICBpZiAoaXNPcExpc3QpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLk9QTElTVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWRzOiBtb2RpZmllZElkcyxcbiAgICAgIGhhc2g6IG1vZGlmaWVkSWRzSGFzaFxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZS5tb2RpZmllZElkcztcbiAgICBjb25zdCBjYWNoZUtleUJ1ZiA9IFtyZW5kZXJpbmdJbnRlbnQsIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2gsIG1vZGlmaWVkSWRzSGFzaF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5OiBjYWNoZUtleUJ1Zi5qb2luKFwiX1wiKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5Py5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQgZHVyaW5nIG9uUGFzc3dvcmQgY2FsbGJhY2tcIikpO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgfVxuICAgIHRoaXMuI3BhZ2VDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5jbGVhcigpO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJUZXJtaW5hdGVcIiwgbnVsbCk7XG4gICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG4gICAgUHJvbWlzZS5hbGwod2FpdE9uKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3koKTtcbiAgICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICBsb2FkaW5nVGFza1xuICAgIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICBhc3NlcnQodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIoKTtcbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUmVhZGVySGVhZGVyc1JlYWR5XCIsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgYXdhaXQgdGhpcy5fZnVsbFJlYWRlci5oZWFkZXJzUmVhZHk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICBpc1JhbmdlU3VwcG9ydGVkLFxuICAgICAgICBjb250ZW50TGVuZ3RoXG4gICAgICB9ID0gdGhpcy5fZnVsbFJlYWRlcjtcbiAgICAgIGlmICghaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWlzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RQcm9ncmVzcykge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICBpc1JhbmdlU3VwcG9ydGVkLFxuICAgICAgICBjb250ZW50TGVuZ3RoXG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgIGFzc2VydCh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJhbmdlUmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICBjb25zdCByYW5nZVJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZGF0YS5iZWdpbiwgZGF0YS5lbmQpO1xuICAgICAgaWYgKCFyYW5nZVJlYWRlcikge1xuICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNpbmsub25QdWxsID0gKCkgPT4ge1xuICAgICAgICByYW5nZVJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJhbmdlUmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldERvY1wiLCAoe1xuICAgICAgcGRmSW5mb1xuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuX251bVBhZ2VzID0gcGRmSW5mby5udW1QYWdlcztcbiAgICAgIHRoaXMuX2h0bWxGb3JYZmEgPSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBkZWxldGUgcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVzb2x2ZShuZXcgUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0aGlzKSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGV4KSB7XG4gICAgICBsZXQgcmVhc29uO1xuICAgICAgc3dpdGNoIChleC5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBQYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkludmFsaWRQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgTWlzc2luZ1BERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguc3RhdHVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBVbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdW5yZWFjaGFibGUoXCJEb2NFeGNlcHRpb24gLSBleHBlY3RlZCBhIHZhbGlkIEVycm9yLlwiKTtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLl9jYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUGFzc3dvcmRSZXF1ZXN0XCIsIGV4Y2VwdGlvbiA9PiB7XG4gICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGlmIChsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVBhc3N3b3JkID0gcGFzc3dvcmQgPT4ge1xuICAgICAgICAgIGlmIChwYXNzd29yZCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KHBhc3N3b3JkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgICBwYXNzd29yZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4Y2VwdGlvbi5jb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEYXRhTG9hZGVkXCIsIGRhdGEgPT4ge1xuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgdG90YWw6IGRhdGEubGVuZ3RoXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KGRhdGEucGFnZUluZGV4KTtcbiAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5jYWNoZUtleSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJjb21tb25vYmpcIiwgKFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29tbW9uT2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgICAgICAgZm9udEV4dHJhUHJvcGVydGllcyxcbiAgICAgICAgICAgIHBkZkJ1Z1xuICAgICAgICAgIH0gPSB0aGlzLl9wYXJhbXM7XG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBleHBvcnRlZERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkRXJyb3IgPSBleHBvcnRlZERhdGEuZXJyb3I7XG4gICAgICAgICAgICB3YXJuKGBFcnJvciBkdXJpbmcgZm9udCBsb2FkaW5nOiAke2V4cG9ydGVkRXJyb3J9YCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWRFcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5zcGVjdEZvbnQgPSBwZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkID8gKGZvbnQsIHVybCkgPT4gZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yLmZvbnRBZGRlZChmb250LCB1cmwpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBmb250ID0gbmV3IEZvbnRGYWNlT2JqZWN0KGV4cG9ydGVkRGF0YSwge1xuICAgICAgICAgICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgICAgICAgaW5zcGVjdEZvbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmZvbnRMb2FkZXIuYmluZChmb250KS5jYXRjaCgoKSA9PiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9KSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgIGZvbnQuZGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDb3B5TG9jYWxJbWFnZVwiOlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGltYWdlUmVmXG4gICAgICAgICAgfSA9IGV4cG9ydGVkRGF0YTtcbiAgICAgICAgICBhc3NlcnQoaW1hZ2VSZWYsIFwiVGhlIGltYWdlUmVmIG11c3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWdlUHJveHkgb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIGRhdGFdIG9mIHBhZ2VQcm94eS5vYmpzKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhPy5yZWYgIT09IGltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhLmRhdGFMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgc3RydWN0dXJlZENsb25lKGRhdGEpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZGF0YUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIGNvbW1vbiBvYmplY3QgdHlwZSAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCAoW2lkLCBwYWdlSW5kZXgsIHR5cGUsIGltYWdlRGF0YV0pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlUHJveHkgPSB0aGlzLiNwYWdlQ2FjaGUuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFnZVByb3h5Ll9pbnRlbnRTdGF0ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICBpbWFnZURhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgaWYgKGltYWdlRGF0YT8uZGF0YUxlbiA+IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFKSB7XG4gICAgICAgICAgICBwYWdlUHJveHkuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQnVpbHRJbkNNYXBcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmNNYXBSZWFkZXJGYWN0b3J5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXBSZWFkZXJGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jTWFwUmVhZGVyRmFjdG9yeS5mZXRjaChkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoU3RhbmRhcmRGb250RGF0YVwiLCBhc3luYyBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZC5cIik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkgbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIGB1c2VXb3JrZXJGZXRjaGAgcGFyYW1ldGVyLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0YW5kYXJkRm9udERhdGFGYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGF0YVwiLCBudWxsKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2l6ZSA8PSAwKSB7XG4gICAgICB3YXJuKFwic2F2ZURvY3VtZW50IGNhbGxlZCB3aGlsZSBgYW5ub3RhdGlvblN0b3JhZ2VgIGlzIGVtcHR5LCBcIiArIFwicGxlYXNlIHVzZSB0aGUgZ2V0RGF0YS1tZXRob2QgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICBpc1B1cmVYZmE6ICEhdGhpcy5faHRtbEZvclhmYSxcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0sIHRyYW5zZmVyKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VJbmZvLnJlZlN0cikge1xuICAgICAgICB0aGlzLiNwYWdlUmVmQ2FjaGUuc2V0KHBhZ2VJbmZvLnJlZlN0ciwgcGFnZU51bWJlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBwYWdlID0gbmV3IFBERlBhZ2VQcm94eShwYWdlSW5kZXgsIHBhZ2VJbmZvLCB0aGlzLCB0aGlzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgIHRoaXMuI3BhZ2VDYWNoZS5zZXQocGFnZUluZGV4LCBwYWdlKTtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH0pO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5zZXQocGFnZUluZGV4LCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2VJbmRleCByZXF1ZXN0LlwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VJbmRleFwiLCB7XG4gICAgICBudW06IHJlZi5udW0sXG4gICAgICBnZW46IHJlZi5nZW5cbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucyhwYWdlSW5kZXgsIGludGVudCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGludGVudFxuICAgIH0pO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRGaWVsZE9iamVjdHNcIik7XG4gIH1cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkhhc0pTQWN0aW9uc1wiKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldENhbGN1bGF0aW9uT3JkZXJJZHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERlc3RpbmF0aW9uc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25cIiwge1xuICAgICAgaWRcbiAgICB9KTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYWJlbHNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VNb2RlXCIsIG51bGwpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFZpZXdlclByZWZlcmVuY2VzXCIsIG51bGwpO1xuICB9XG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3BlbkFjdGlvblwiLCBudWxsKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBdHRhY2htZW50c1wiLCBudWxsKTtcbiAgfVxuICBnZXREb2NKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RG9jSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUpTQWN0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0cnVjdFRyZWVcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRPcHRpb25hbENvbnRlbnRDb25maWdcIikudGhlbihkYXRhID0+IG5ldyBPcHRpb25hbENvbnRlbnRDb25maWcoZGF0YSwgcmVuZGVyaW5nSW50ZW50KSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbmFtZSA9IFwiR2V0TWV0YWRhdGFcIixcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgbnVsbCkudGhlbihyZXN1bHRzID0+ICh7XG4gICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICBjb250ZW50TGVuZ3RoOiB0aGlzLl9mdWxsUmVhZGVyPy5jb250ZW50TGVuZ3RoID8/IG51bGxcbiAgICB9KSk7XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuc2V0KG5hbWUsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE1hcmtJbmZvXCIsIG51bGwpO1xuICB9XG4gIGFzeW5jIHN0YXJ0Q2xlYW51cChrZWVwTG9hZGVkRm9udHMgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkNsZWFudXBcIiwgbnVsbCk7XG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xlYW51cFN1Y2Nlc3NmdWwgPSBwYWdlLmNsZWFudXAoKTtcbiAgICAgIGlmICghY2xlYW51cFN1Y2Nlc3NmdWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdGFydENsZWFudXA6IFBhZ2UgJHtwYWdlLnBhZ2VOdW1iZXJ9IGlzIGN1cnJlbnRseSByZW5kZXJpbmcuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgIGlmICgha2VlcExvYWRlZEZvbnRzKSB7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkuZGVzdHJveSh0cnVlKTtcbiAgICBUZXh0TGF5ZXIuY2xlYW51cCgpO1xuICB9XG4gIGNhY2hlZFBhZ2VOdW1iZXIocmVmKSB7XG4gICAgaWYgKCFpc1JlZlByb3h5KHJlZikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWZTdHIgPSByZWYuZ2VuID09PSAwID8gYCR7cmVmLm51bX1SYCA6IGAke3JlZi5udW19UiR7cmVmLmdlbn1gO1xuICAgIHJldHVybiB0aGlzLiNwYWdlUmVmQ2FjaGUuZ2V0KHJlZlN0cikgPz8gbnVsbDtcbiAgfVxufVxuY29uc3QgSU5JVElBTF9EQVRBID0gU3ltYm9sKFwiSU5JVElBTF9EQVRBXCIpO1xuY2xhc3MgUERGT2JqZWN0cyB7XG4gICNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI2Vuc3VyZU9iaihvYmpJZCkge1xuICAgIHJldHVybiB0aGlzLiNvYmpzW29iaklkXSB8fD0ge1xuICAgICAgLi4uUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBkYXRhOiBJTklUSUFMX0RBVEFcbiAgICB9O1xuICB9XG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgICAgb2JqLnByb21pc2UudGhlbigoKSA9PiBjYWxsYmFjayhvYmouZGF0YSkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgJHtvYmpJZH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfVxuICBoYXMob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLmRhdGEgIT09IElOSVRJQUxfREFUQTtcbiAgfVxuICByZXNvbHZlKG9iaklkLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgb2JqLmRhdGEgPSBkYXRhO1xuICAgIG9iai5yZXNvbHZlKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGRhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy4jb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBpZiAoZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeWllbGQgW29iaklkLCBkYXRhXTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWxSZW5kZXJUYXNrKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHRoaXMub25Db250aW51ZSA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbChudWxsLCBleHRyYURlbGF5KTtcbiAgfVxuICBnZXQgc2VwYXJhdGVBbm5vdHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VwYXJhdGVBbm5vdHNcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdDtcbiAgICBpZiAoIXNlcGFyYXRlQW5ub3RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXBcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHJldHVybiBzZXBhcmF0ZUFubm90cy5mb3JtIHx8IHNlcGFyYXRlQW5ub3RzLmNhbnZhcyAmJiBhbm5vdGF0aW9uQ2FudmFzTWFwPy5zaXplID4gMDtcbiAgfVxufVxuY2xhc3MgSW50ZXJuYWxSZW5kZXJUYXNrIHtcbiAgI3JBRiA9IG51bGw7XG4gIHN0YXRpYyAjY2FudmFzSW5Vc2UgPSBuZXcgV2Vha1NldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2FsbGJhY2ssXG4gICAgcGFyYW1zLFxuICAgIG9ianMsXG4gICAgY29tbW9uT2JqcyxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIG9wZXJhdG9yTGlzdCxcbiAgICBwYWdlSW5kZXgsXG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy50YXNrID0gbmV3IFJlbmRlclRhc2sodGhpcyk7XG4gICAgdGhpcy5fY2FuY2VsQm91bmQgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRpbnVlQm91bmQgPSB0aGlzLl9jb250aW51ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kID0gdGhpcy5fc2NoZWR1bGVOZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbmV4dEJvdW5kID0gdGhpcy5fbmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHBhcmFtcy5jYW52YXNDb250ZXh0LmNhbnZhcztcbiAgfVxuICBnZXQgY29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdHkucHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gIH1cbiAgaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgfSkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICBpZiAoSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5oYXModGhpcy5fY2FudmFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBzYW1lIGNhbnZhcyBkdXJpbmcgbXVsdGlwbGUgcmVuZGVyKCkgb3BlcmF0aW9ucy4gXCIgKyBcIlVzZSBkaWZmZXJlbnQgY2FudmFzIG9yIGVuc3VyZSBwcmV2aW91cyBvcGVyYXRpb25zIHdlcmUgXCIgKyBcImNhbmNlbGxlZCBvciBjb21wbGV0ZWQuXCIpO1xuICAgICAgfVxuICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5hZGQodGhpcy5fY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BkZkJ1ZyAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnN0ZXBwZXIgPSBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLl9wYWdlSW5kZXgpO1xuICAgICAgdGhpcy5zdGVwcGVyLmluaXQodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgICAgdGhpcy5zdGVwcGVyLm5leHRCcmVha1BvaW50ID0gdGhpcy5zdGVwcGVyLmdldE5leHRCcmVha1BvaW50KCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIGJhY2tncm91bmRcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgdGhpcy5nZnggPSBuZXcgQ2FudmFzR3JhcGhpY3MoY2FudmFzQ29udGV4dCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICB9LCB0aGlzLmFubm90YXRpb25DYW52YXNNYXAsIHRoaXMucGFnZUNvbG9ycyk7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIGlmICh0aGlzLiNyQUYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLiNyQUYpO1xuICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICB9XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICB0aGlzLmNhbGxiYWNrKGVycm9yIHx8IG5ldyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24oYFJlbmRlcmluZyBjYW5jZWxsZWQsIHBhZ2UgJHt0aGlzLl9wYWdlSW5kZXggKyAxfWAsIGV4dHJhRGVsYXkpKTtcbiAgfVxuICBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayB8fD0gdGhpcy5fY29udGludWVCb3VuZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGVwcGVyPy51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY29udGludWUoKTtcbiAgfVxuICBfY29udGludWUoKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMudGFzay5vbkNvbnRpbnVlKSB7XG4gICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dCgpO1xuICAgIH1cbiAgfVxuICBfc2NoZWR1bGVOZXh0KCkge1xuICAgIGlmICh0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHRoaXMuI3JBRiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLiNyQUYgPSBudWxsO1xuICAgICAgICB0aGlzLl9uZXh0Qm91bmQoKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbih0aGlzLl9uZXh0Qm91bmQpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gdGhpcy5nZnguZXhlY3V0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCwgdGhpcy5vcGVyYXRvckxpc3RJZHgsIHRoaXMuX2NvbnRpbnVlQm91bmQsIHRoaXMuc3RlcHBlcik7XG4gICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0SWR4ID09PSB0aGlzLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCB2ZXJzaW9uID0gXCI0LjguNjlcIjtcbmNvbnN0IGJ1aWxkID0gXCIzNjM0ZGFiMTBcIjtcblxuOy8vIC4vc3JjL3NoYXJlZC9zY3JpcHRpbmdfdXRpbHMuanNcbmZ1bmN0aW9uIG1ha2VDb2xvckNvbXAobikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBuKSkgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5mdW5jdGlvbiBzY2FsZUFuZENsYW1wKHgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgMjU1ICogeCkpO1xufVxuY2xhc3MgQ29sb3JDb252ZXJ0ZXJzIHtcbiAgc3RhdGljIENNWUtfRyhbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAxIC0gTWF0aC5taW4oMSwgMC4zICogYyArIDAuNTkgKiBtICsgMC4xMSAqIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIEdfQ01ZSyhbZ10pIHtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCAwLCAwLCAwLCAxIC0gZ107XG4gIH1cbiAgc3RhdGljIEdfUkdCKFtnXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfcmdiKFtnXSkge1xuICAgIGcgPSBzY2FsZUFuZENsYW1wKGcpO1xuICAgIHJldHVybiBbZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfSFRNTChbZ10pIHtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICByZXR1cm4gYCMke0d9JHtHfSR7R31gO1xuICB9XG4gIHN0YXRpYyBSR0JfRyhbciwgZywgYl0pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYl07XG4gIH1cbiAgc3RhdGljIFJHQl9yZ2IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IubWFwKHNjYWxlQW5kQ2xhbXApO1xuICB9XG4gIHN0YXRpYyBSR0JfSFRNTChjb2xvcikge1xuICAgIHJldHVybiBgIyR7Y29sb3IubWFwKG1ha2VDb2xvckNvbXApLmpvaW4oXCJcIil9YDtcbiAgfVxuICBzdGF0aWMgVF9IVE1MKCkge1xuICAgIHJldHVybiBcIiMwMDAwMDAwMFwiO1xuICB9XG4gIHN0YXRpYyBUX3JnYigpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9XG4gIHN0YXRpYyBDTVlLX1JHQihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIDEgLSBNYXRoLm1pbigxLCBjICsgayksIDEgLSBNYXRoLm1pbigxLCBtICsgayksIDEgLSBNYXRoLm1pbigxLCB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBDTVlLX3JnYihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW3NjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIGMgKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIG0gKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIHkgKyBrKSldO1xuICB9XG4gIHN0YXRpYyBDTVlLX0hUTUwoY29tcG9uZW50cykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuQ01ZS19SR0IoY29tcG9uZW50cykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRoaXMuUkdCX0hUTUwocmdiKTtcbiAgfVxuICBzdGF0aWMgUkdCX0NNWUsoW3IsIGcsIGJdKSB7XG4gICAgY29uc3QgYyA9IDEgLSByO1xuICAgIGNvbnN0IG0gPSAxIC0gZztcbiAgICBjb25zdCB5ID0gMSAtIGI7XG4gICAgY29uc3QgayA9IE1hdGgubWluKGMsIG0sIHkpO1xuICAgIHJldHVybiBbXCJDTVlLXCIsIGMsIG0sIHksIGtdO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3N2Z19mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVNWR0ZhY3Rvcnkge1xuICBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2tpcERpbWVuc2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLl9jcmVhdGVTVkcoXCJzdmc6c3ZnXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xuICAgIGlmICghc2tpcERpbWVuc2lvbnMpIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3aWR0aH1weGApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBjcmVhdGVFbGVtZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNWRyh0eXBlKTtcbiAgfVxuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZVNWR2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgRE9NU1ZHRmFjdG9yeSBleHRlbmRzIEJhc2VTVkdGYWN0b3J5IHtcbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3hmYV9sYXllci5qc1xuXG5jbGFzcyBYZmFMYXllciB7XG4gIHN0YXRpYyBzZXR1cFN0b3JhZ2UoaHRtbCwgaWQsIGVsZW1lbnQsIHN0b3JhZ2UsIGludGVudCkge1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH0pO1xuICAgIHN3aXRjaCAoZWxlbWVudC5uYW1lKSB7XG4gICAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgaWYgKGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIgfHwgZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwiY2hlY2tib3hcIikge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT24pIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPZmYpIHtcbiAgICAgICAgICAgIGh0bWwucmVtb3ZlQXR0cmlidXRlKFwiY2hlY2tlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkID8gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9uXCIpIDogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcInhmYU9mZlwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBlbGVtZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uLmF0dHJpYnV0ZXMudmFsdWUgPT09IHN0b3JlZERhdGEudmFsdWUpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb24uYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShcInNlbGVjdGVkXCIpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBcIlwiIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIHNldEF0dHJpYnV0ZXMoe1xuICAgIGh0bWwsXG4gICAgZWxlbWVudCxcbiAgICBzdG9yYWdlID0gbnVsbCxcbiAgICBpbnRlbnQsXG4gICAgbGlua1NlcnZpY2VcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCBpc0hUTUxBbmNob3JFbGVtZW50ID0gaHRtbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50O1xuICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgYXR0cmlidXRlcy5uYW1lID0gYCR7YXR0cmlidXRlcy5uYW1lfS0ke2ludGVudH1gO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkYXRhSWRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImlkXCI6XG4gICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGh0bWwuc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghaXNIVE1MQW5jaG9yRWxlbWVudCB8fCBrZXkgIT09IFwiaHJlZlwiICYmIGtleSAhPT0gXCJuZXdXaW5kb3dcIikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMoaHRtbCwgYXR0cmlidXRlcy5ocmVmLCBhdHRyaWJ1dGVzLm5ld1dpbmRvdyk7XG4gICAgfVxuICAgIGlmIChzdG9yYWdlICYmIGF0dHJpYnV0ZXMuZGF0YUlkKSB7XG4gICAgICB0aGlzLnNldHVwU3RvcmFnZShodG1sLCBhdHRyaWJ1dGVzLmRhdGFJZCwgZWxlbWVudCwgc3RvcmFnZSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyByZW5kZXIocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICBjb25zdCByb290ID0gcGFyYW1ldGVycy54ZmFIdG1sO1xuICAgIGNvbnN0IGludGVudCA9IHBhcmFtZXRlcnMuaW50ZW50IHx8IFwiZGlzcGxheVwiO1xuICAgIGNvbnN0IHJvb3RIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyb290Lm5hbWUpO1xuICAgIGlmIChyb290LmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgIGh0bWw6IHJvb3RIdG1sLFxuICAgICAgICBlbGVtZW50OiByb290LFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaXNOb3RGb3JSaWNoVGV4dCA9IGludGVudCAhPT0gXCJyaWNoVGV4dFwiO1xuICAgIGNvbnN0IHJvb3REaXYgPSBwYXJhbWV0ZXJzLmRpdjtcbiAgICByb290RGl2LmFwcGVuZChyb290SHRtbCk7XG4gICAgaWYgKHBhcmFtZXRlcnMudmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICAgIHJvb3REaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cbiAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCkge1xuICAgICAgcm9vdERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInhmYUxheWVyIHhmYUZvbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRleHREaXZzID0gW107XG4gICAgaWYgKHJvb3QuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAocm9vdC52YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocm9vdC52YWx1ZSk7XG4gICAgICAgIHJvb3RIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgaWYgKGlzTm90Rm9yUmljaFRleHQgJiYgWGZhVGV4dC5zaG91bGRCdWlsZFRleHQocm9vdC5uYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRleHREaXZzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IFtbcm9vdCwgLTEsIHJvb3RIdG1sXV07XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtwYXJlbnQsIGksIGh0bWxdID0gc3RhY2suYXQoLTEpO1xuICAgICAgaWYgKGkgKyAxID09PSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuWysrc3RhY2suYXQoLTEpWzFdXTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICBodG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZEh0bWwgPSBjaGlsZD8uYXR0cmlidXRlcz8ueG1sbnMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoY2hpbGQuYXR0cmlidXRlcy54bWxucywgbmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgaHRtbC5hcHBlbmQoY2hpbGRIdG1sKTtcbiAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHRtbDogY2hpbGRIdG1sLFxuICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkLFxuICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgaW50ZW50LFxuICAgICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuPy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW2NoaWxkLCAtMSwgY2hpbGRIdG1sXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIGlmIChpc05vdEZvclJpY2hUZXh0ICYmIFhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsIG9mIHJvb3REaXYucXVlcnlTZWxlY3RvckFsbChcIi54ZmFOb25JbnRlcmFjdGl2ZSBpbnB1dCwgLnhmYU5vbkludGVyYWN0aXZlIHRleHRhcmVhXCIpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoXCJyZWFkT25seVwiLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHREaXZzXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgcGFyYW1ldGVycy5kaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHBhcmFtZXRlcnMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2Fubm90YXRpb25fbGF5ZXIuanNcblxuXG5cblxuXG5cbmNvbnN0IERFRkFVTFRfVEFCX0lOREVYID0gMTAwMDtcbmNvbnN0IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkUgPSA5O1xuY29uc3QgR2V0RWxlbWVudHNCeU5hbWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gZ2V0UmVjdERpbXMocmVjdCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gIH07XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudEZhY3Rvcnkge1xuICBzdGF0aWMgY3JlYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdWJ0eXBlID0gcGFyYW1ldGVycy5kYXRhLmFubm90YXRpb25UeXBlO1xuICAgIHN3aXRjaCAoc3VidHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5MSU5LOlxuICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLldJREdFVDpcbiAgICAgICAgY29uc3QgZmllbGRUeXBlID0gcGFyYW1ldGVycy5kYXRhLmZpZWxkVHlwZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVHhcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgY2FzZSBcIkNoXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJTaWdcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0lSQ0xFOlxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5JTks6XG4gICAgICAgIHJldHVybiBuZXcgSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPTFlHT046XG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlVOREVSTElORTpcbiAgICAgICAgcmV0dXJuIG5ldyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1FVSUdHTFk6XG4gICAgICAgIHJldHVybiBuZXcgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5GSUxFQVRUQUNITUVOVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjaGFzQm9yZGVyID0gZmFsc2U7XG4gICNwb3B1cEVsZW1lbnQgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzLCB7XG4gICAgaXNSZW5kZXJhYmxlID0gZmFsc2UsXG4gICAgaWdub3JlQm9yZGVyID0gZmFsc2UsXG4gICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICB0aGlzLmlzUmVuZGVyYWJsZSA9IGlzUmVuZGVyYWJsZTtcbiAgICB0aGlzLmRhdGEgPSBwYXJhbWV0ZXJzLmRhdGE7XG4gICAgdGhpcy5sYXllciA9IHBhcmFtZXRlcnMubGF5ZXI7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZVNjcmlwdGluZyA9IHBhcmFtZXRlcnMuZW5hYmxlU2NyaXB0aW5nO1xuICAgIHRoaXMuaGFzSlNBY3Rpb25zID0gcGFyYW1ldGVycy5oYXNKU0FjdGlvbnM7XG4gICAgdGhpcy5fZmllbGRPYmplY3RzID0gcGFyYW1ldGVycy5maWVsZE9iamVjdHM7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJhbWV0ZXJzLnBhcmVudDtcbiAgICBpZiAoaXNSZW5kZXJhYmxlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlUXVhZHJpbGF0ZXJhbHMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaGFzUG9wdXBEYXRhKHtcbiAgICB0aXRsZU9iaixcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dFxuICB9KSB7XG4gICAgcmV0dXJuICEhKHRpdGxlT2JqPy5zdHIgfHwgY29udGVudHNPYmo/LnN0ciB8fCByaWNoVGV4dD8uc3RyKTtcbiAgfVxuICBnZXQgX2lzRWRpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5pc0VkaXRhYmxlO1xuICB9XG4gIGdldCBoYXNQb3B1cERhdGEoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEodGhpcy5kYXRhKTtcbiAgfVxuICB1cGRhdGVFZGl0ZWQocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdC5zbGljZSgwKVxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcmVjdFxuICAgIH0gPSBwYXJhbXM7XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQocmVjdCk7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwRWxlbWVudD8ucG9wdXAudXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQodGhpcy4jdXBkYXRlcy5yZWN0KTtcbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwLnJlc2V0RWRpdGVkKCk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gIH1cbiAgI3NldFJlY3RFZGl0ZWQocmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdDogY3VycmVudFJlY3QsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjdXJyZW50UmVjdD8uc3BsaWNlKDAsIDQsIC4uLnJlY3QpO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHJlY3QpO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocGFnZUhlaWdodCAtIHJlY3RbM10gKyBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGlmIChyb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkpIHtcbiAgICAgIGNvbnRhaW5lci50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBjb250YWluZXI7XG4gICAgc3R5bGUuekluZGV4ID0gdGhpcy5wYXJlbnQuekluZGV4Kys7XG4gICAgaWYgKGRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICBjb250YWluZXIudGl0bGUgPSBkYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG4gICAgaWYgKGRhdGEubm9Sb3RhdGUpIHtcbiAgICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibm9yb3RhdGVcIik7XG4gICAgfVxuICAgIGlmICghZGF0YS5yZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBQb3B1cEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gYCR7ZGF0YS5ib3JkZXJTdHlsZS53aWR0aH1weGA7XG4gICAgICBjb25zdCBob3Jpem9udGFsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS5ob3Jpem9udGFsQ29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmVydGljYWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLnZlcnRpY2FsQ29ybmVyUmFkaXVzO1xuICAgICAgaWYgKGhvcml6b250YWxSYWRpdXMgPiAwIHx8IHZlcnRpY2FsUmFkaXVzID4gMCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke2hvcml6b250YWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHt2ZXJ0aWNhbFJhZGl1c31weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgICAgc3R5bGUuYm9yZGVyUmFkaXVzID0gcmFkaXVzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzIGluc3RhbmNlb2YgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICBjb25zdCByYWRpdXMgPSBgY2FsYygke3dpZHRofXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7aGVpZ2h0fXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuYm9yZGVyU3R5bGUuc3R5bGUpIHtcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuREFTSEVEOlxuICAgICAgICAgIHN0eWxlLmJvcmRlclN0eWxlID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkJFVkVMRUQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBiZXZlbGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgd2FybihcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICBzdHlsZS5ib3JkZXJCb3R0b21TdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gZGF0YS5ib3JkZXJDb2xvciB8fCBudWxsO1xuICAgICAgaWYgKGJvcmRlckNvbG9yKSB7XG4gICAgICAgIHRoaXMuI2hhc0JvcmRlciA9IHRydWU7XG4gICAgICAgIHN0eWxlLmJvcmRlckNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW2RhdGEucmVjdFswXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzFdICsgcGFnZS52aWV3WzFdLCBkYXRhLnJlY3RbMl0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFszXSArIHBhZ2Uudmlld1sxXV0pO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICBwYWdlWCxcbiAgICAgIHBhZ2VZXG4gICAgfSA9IHZpZXdwb3J0LnJhd0RpbXM7XG4gICAgc3R5bGUubGVmdCA9IGAkezEwMCAqIChyZWN0WzBdIC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChyZWN0WzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChkYXRhLmhhc093bkNhbnZhcyB8fCByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aH0lYDtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24sIGNvbnRhaW5lcik7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucmVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJhd0RpbXM7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXModGhpcy5kYXRhLnJlY3QpO1xuICAgIGxldCBlbGVtZW50V2lkdGgsIGVsZW1lbnRIZWlnaHQ7XG4gICAgaWYgKGFuZ2xlICUgMTgwID09PSAwKSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgPSAxMDAgKiBoZWlnaHQgLyBwYWdlSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50V2lkdGggPSAxMDAgKiBoZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogd2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50V2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2VsZW1lbnRIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0Lm1hcCh4ID0+IE1hdGguZnJvdW5kKHgpKTtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IFt0clgsIHRyWSwgYmxYLCBibFldID0gcXVhZFBvaW50cy5zdWJhcnJheSgyLCA2KTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgY29uc3QgZGVmcyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGNvbnN0IGlkID0gYGNsaXBwYXRoXyR7dGhpcy5kYXRhLmlkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgZm9yIChsZXQgaSA9IDIsIGlpID0gcXVhZFBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSA4KSB7XG4gICAgICBjb25zdCB0clggPSBxdWFkUG9pbnRzW2ldO1xuICAgICAgY29uc3QgdHJZID0gcXVhZFBvaW50c1tpICsgMV07XG4gICAgICBjb25zdCBibFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgIGNvbnN0IGJsWSA9IHF1YWRQb2ludHNbaSArIDNdO1xuICAgICAgY29uc3QgcmVjdCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInJlY3RcIik7XG4gICAgICBjb25zdCB4ID0gKGJsWCAtIHJlY3RCbFgpIC8gd2lkdGg7XG4gICAgICBjb25zdCB5ID0gKHJlY3RUclkgLSB0clkpIC8gaGVpZ2h0O1xuICAgICAgY29uc3QgcmVjdFdpZHRoID0gKHRyWCAtIGJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHJlY3RIZWlnaHQgPSAodHJZIC0gYmxZKSAvIGhlaWdodDtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgcmVjdFdpZHRoKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJlY3RIZWlnaHQpO1xuICAgICAgY2xpcFBhdGguYXBwZW5kKHJlY3QpO1xuICAgICAgc3ZnQnVmZmVyPy5wdXNoKGA8cmVjdCB2ZWN0b3ItZWZmZWN0PVwibm9uLXNjYWxpbmctc3Ryb2tlXCIgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHtyZWN0V2lkdGh9XCIgaGVpZ2h0PVwiJHtyZWN0SGVpZ2h0fVwiLz5gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhc0JvcmRlcikge1xuICAgICAgc3ZnQnVmZmVyLnB1c2goYDwvZz48L3N2Zz4nKWApO1xuICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3ZnQnVmZmVyLmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmNsaXBQYXRoID0gYHVybCgjJHtpZH0pYDtcbiAgfVxuICBfY3JlYXRlUG9wdXAoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBvcHVwID0gdGhpcy4jcG9wdXBFbGVtZW50ID0gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQoe1xuICAgICAgZGF0YToge1xuICAgICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGVPYmo6IGRhdGEudGl0bGVPYmosXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IGRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgICAgY29udGVudHNPYmo6IGRhdGEuY29udGVudHNPYmosXG4gICAgICAgIHJpY2hUZXh0OiBkYXRhLnJpY2hUZXh0LFxuICAgICAgICBwYXJlbnRSZWN0OiBkYXRhLnJlY3QsXG4gICAgICAgIGJvcmRlclN0eWxlOiAwLFxuICAgICAgICBpZDogYHBvcHVwXyR7ZGF0YS5pZH1gLFxuICAgICAgICByb3RhdGlvbjogZGF0YS5yb3RhdGlvblxuICAgICAgfSxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogW3RoaXNdXG4gICAgfSk7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmFwcGVuZChwb3B1cC5yZW5kZXIoKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHdhcm4oYF9nZXRFbGVtZW50c0J5TmFtZSAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIGRvbUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICB9ID0gZG9tRWxlbWVudDtcbiAgICAgIGNvbnN0IGlkID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIik7XG4gICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgIGRvbUVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8ubWF5YmVTaG93KCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/LmZvcmNlSGlkZSgpO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmlnZ2VycykpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2Vycykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2Vycy5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICB9XG4gIH1cbiAgX2VkaXRPbkRvdWJsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5faXNFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0SWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbik7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0YWNobWVudCkge1xuICAgICAgdGhpcy4jYmluZEF0dGFjaG1lbnQobGluaywgZGF0YS5hdHRhY2htZW50LCBkYXRhLmF0dGFjaG1lbnREZXN0KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zZXRPQ0dTdGF0ZSkge1xuICAgICAgdGhpcy4jYmluZFNldE9DR1N0YXRlKGxpbmssIGRhdGEuc2V0T0NHU3RhdGUpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEuYWN0aW9ucyAmJiAoZGF0YS5hY3Rpb25zLkFjdGlvbiB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBVcFwiXSB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICB0aGlzLl9iaW5kSlNBY3Rpb24obGluaywgZGF0YSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucmVzZXRGb3JtKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgZGF0YS5yZXNldEZvcm0pO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Rvb2x0aXBPbmx5ICYmICFpc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmtBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50LCBkZXN0ID0gbnVsbCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGlmIChhdHRhY2htZW50LmRlc2NyaXB0aW9uKSB7XG4gICAgICBsaW5rLnRpdGxlID0gYXR0YWNobWVudC5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YShhdHRhY2htZW50LmNvbnRlbnQsIGF0dGFjaG1lbnQuZmlsZW5hbWUsIGRlc3QpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBhY3Rpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVTZXRPQ0dTdGF0ZShhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcChbW1wiQWN0aW9uXCIsIFwib25jbGlja1wiXSwgW1wiTW91c2UgVXBcIiwgXCJvbm1vdXNldXBcIl0sIFtcIk1vdXNlIERvd25cIiwgXCJvbm1vdXNlZG93blwiXV0pO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkYXRhLmFjdGlvbnMpKSB7XG4gICAgICBjb25zdCBqc05hbWUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCFqc05hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsaW5rW2pzTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFsaW5rLm9uY2xpY2spIHtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgfVxuICBfYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCByZXNldEZvcm0pIHtcbiAgICBjb25zdCBvdGhlckNsaWNrQWN0aW9uID0gbGluay5vbmNsaWNrO1xuICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICAgIGlmICghdGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIFwicmVzZXRGb3JtXCIgYWN0aW9uIG5vdCBzdXBwb3J0ZWQsIGAgKyBcImVuc3VyZSB0aGF0IHRoZSBgZmllbGRPYmplY3RzYCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvdGhlckNsaWNrQWN0aW9uPy4oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmllbGRzOiByZXNldEZvcm1GaWVsZHMsXG4gICAgICAgIHJlZnM6IHJlc2V0Rm9ybVJlZnMsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH0gPSByZXNldEZvcm07XG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBbXTtcbiAgICAgIGlmIChyZXNldEZvcm1GaWVsZHMubGVuZ3RoICE9PSAwIHx8IHJlc2V0Rm9ybVJlZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWRzID0gbmV3IFNldChyZXNldEZvcm1SZWZzKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZElkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkSWRzLmhhcyhmaWVsZC5pZCkgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgYWxsRmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgYWxsRmllbGRzLnB1c2goLi4uZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgYWxsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZmllbGQ7XG4gICAgICAgIGFsbElkcy5wdXNoKGlkKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICBjYXNlIFwicmFkaW9idXR0b25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgPT09IGZpZWxkLmV4cG9ydFZhbHVlcztcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29tYm9ib3hcIjpcbiAgICAgICAgICBjYXNlIFwibGlzdGJveFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICB3YXJuKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogXCJhcHBcIixcbiAgICAgICAgICAgIGlkczogYWxsSWRzLFxuICAgICAgICAgICAgbmFtZTogXCJSZXNldEZvcm1cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtdGV4dC1hbm5vdGF0aW9uLXR5cGVcIik7XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KSk7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChpbWFnZSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBzaG93RWxlbWVudEFuZEhpZGVDYW52YXMoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICBpZiAoZWxlbWVudC5wcmV2aW91c1NpYmxpbmc/Lm5vZGVOYW1lID09PSBcIkNBTlZBU1wiKSB7XG4gICAgICAgIGVsZW1lbnQucHJldmlvdXNTaWJsaW5nLmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBfZ2V0S2V5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICByZXR1cm4gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc01hYyA/IGV2ZW50Lm1ldGFLZXkgOiBldmVudC5jdHJsS2V5O1xuICB9XG4gIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KSxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyOiB0aGlzLl9nZXRLZXlNb2RpZmllcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoYmFzZU5hbWUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZUdldHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIG5hbWVzLCBnZXR0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtiYXNlTmFtZSwgZXZlbnROYW1lXSBvZiBuYW1lcykge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJBY3Rpb25cIiB8fCB0aGlzLmRhdGEuYWN0aW9ucz8uW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiIHx8IGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIpIHtcbiAgICAgICAgICBlbGVtZW50RGF0YSB8fD0ge1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIGdldHRlcik7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImJsdXJcIiwgXCJCbHVyXCIsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiZm9jdXNcIiwgXCJGb2N1c1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbDtcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID09PSBudWxsID8gXCJ0cmFuc3BhcmVudFwiIDogVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cbiAgX3NldFRleHRTdHlsZShlbGVtZW50KSB7XG4gICAgY29uc3QgVEVYVF9BTElHTk1FTlQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XG4gICAgY29uc3Qge1xuICAgICAgZm9udENvbG9yXG4gICAgfSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplIHx8IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkU7XG4gICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGxldCBjb21wdXRlZEZvbnRTaXplO1xuICAgIGNvbnN0IEJPUkRFUl9TSVpFID0gMjtcbiAgICBjb25zdCByb3VuZFRvT25lRGVjaW1hbCA9IHggPT4gTWF0aC5yb3VuZCgxMCAqIHgpIC8gMTA7XG4gICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5yb3VuZChoZWlnaHQgLyAoTElORV9GQUNUT1IgKiBmb250U2l6ZSkpIHx8IDE7XG4gICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaGVpZ2h0IC8gbnVtYmVyT2ZMaW5lcztcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwobGluZUhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0gLSBCT1JERVJfU0laRSk7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGhlaWdodCAvIExJTkVfRkFDVE9SKSk7XG4gICAgfVxuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtjb21wdXRlZEZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoZm9udENvbG9yWzBdLCBmb250Q29sb3JbMV0sIGZvbnRDb2xvclsyXSk7XG4gICAgaWYgKHRoaXMuZGF0YS50ZXh0QWxpZ25tZW50ICE9PSBudWxsKSB7XG4gICAgICBzdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgfVxuICB9XG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1yZXF1aXJlZFwiLCBpc1JlcXVpcmVkKTtcbiAgfVxufVxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCBwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzIHx8ICFwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZSAmJiAhIXBhcmFtZXRlcnMuZGF0YS5maWVsZFZhbHVlO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoYmFzZS5uYW1lLCBiYXNlLmlkKSkge1xuICAgICAgaWYgKGVsZW1lbnQuZG9tRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LmRvbUVsZW1lbnRba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShlbGVtZW50LmlkLCB7XG4gICAgICAgIFtrZXlJblN0b3JhZ2VdOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dFdpZGdldEFubm90YXRpb25cIik7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlbmRlckZvcm1zKSB7XG4gICAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICAgIH0pO1xuICAgICAgbGV0IHRleHRDb250ZW50ID0gc3RvcmVkRGF0YS52YWx1ZSB8fCBcIlwiO1xuICAgICAgY29uc3QgbWF4TGVuID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgICBjaGFyTGltaXQ6IHRoaXMuZGF0YS5tYXhMZW5cbiAgICAgIH0pLmNoYXJMaW1pdDtcbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cbiAgICAgIGxldCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IHN0b3JlZERhdGEuZm9ybWF0dGVkVmFsdWUgfHwgdGhpcy5kYXRhLnRleHRDb250ZW50Py5qb2luKFwiXFxuXCIpIHx8IG51bGw7XG4gICAgICBpZiAoZmllbGRGb3JtYXR0ZWRWYWx1ZXMgJiYgdGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPSBmaWVsZEZvcm1hdHRlZFZhbHVlcy5yZXBsYWNlQWxsKC9cXHMrL2csIFwiXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBmaWVsZEZvcm1hdHRlZFZhbHVlcyxcbiAgICAgICAgbGFzdENvbW1pdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgIGZvY3VzZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50O1xuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBmaWVsZEZvcm1hdHRlZFZhbHVlcyA/PyB0ZXh0Q29udGVudCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzT3duQ2FudmFzKSB7XG4gICAgICAgIGVsZW1lbnQuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICAgIGlmIChtYXhMZW4pIHtcbiAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSBtYXhMZW47XG4gICAgICB9XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5T25TaWJsaW5ncyhlbGVtZW50LCBcInZhbHVlXCIsIGV2ZW50LnRhcmdldC52YWx1ZSwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSB0aGlzLmRhdGEuZGVmYXVsdEZpZWxkVmFsdWUgPz8gXCJcIjtcbiAgICAgICAgZWxlbWVudC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBsZXQgYmx1ckxpc3RlbmVyID0gZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgfSA9IGVsZW1lbnREYXRhO1xuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnRhcmdldC5zY3JvbGxMZWZ0ID0gMDtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS5mb2N1c2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAxO1xuICAgICAgICAgIGlmICghdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgICAgIGlmIChjaGVja2JveC5kb21FbGVtZW50KSB7XG4gICAgICAgICAgY2hlY2tib3guZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGNoZWNrYm94LmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBldmVudC5kZXRhaWwudmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInJhZGlvQnV0dG9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShkYXRhLmZpZWxkTmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGlkKTtcbiAgICBlbGVtZW50LmRpc2FibGVkID0gZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIGVsZW1lbnQudHlwZSA9IFwicmFkaW9cIjtcbiAgICBlbGVtZW50Lm5hbWUgPSBkYXRhLmZpZWxkTmFtZTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY2hlY2tlZFwiLCB0cnVlKTtcbiAgICB9XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZTogY2hlY2tlZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGRhdGEuZGVmYXVsdEZpZWxkVmFsdWU7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGV2ZW50LnRhcmdldC5uYW1lKSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiByYWRpby5pZCA9PT0gaWQ7XG4gICAgICAgICAgICAgIGlmIChyYWRpby5kb21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmFkaW8uZG9tRWxlbWVudC5jaGVja2VkID0gY3VyQ2hlY2tlZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKGVsZW1lbnQsIG51bGwsIFtbXCJjaGFuZ2VcIiwgXCJWYWxpZGF0ZVwiXSwgW1wiY2hhbmdlXCIsIFwiQWN0aW9uXCJdLCBbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgTGlua0Fubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlnbm9yZUJvcmRlcjogcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2VcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gc3VwZXIucmVuZGVyKCk7XG4gICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicHVzaEJ1dHRvblwiKTtcbiAgICBjb25zdCBsaW5rRWxlbWVudCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zICYmIGxpbmtFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhsaW5rRWxlbWVudCk7XG4gICAgICBsaW5rRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCh7fSwganNFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNob2ljZVdpZGdldEFubm90YXRpb25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChzZWxlY3RFbGVtZW50KTtcbiAgICBzZWxlY3RFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIHNlbGVjdEVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgc2VsZWN0RWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGxldCBhZGRBbkVtcHR5RW50cnkgPSB0aGlzLmRhdGEuY29tYm8gJiYgdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgc2VsZWN0RWxlbWVudC5zaXplID0gdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24udmFsdWUgPT09IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG4gICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZS5pbmNsdWRlcyhvcHRpb24uZXhwb3J0VmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgIGFkZEFuRW1wdHlFbnRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICBpZiAoYWRkQW5FbXB0eUVudHJ5KSB7XG4gICAgICBjb25zdCBub25lT3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC52YWx1ZSA9IFwiIFwiO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICBzZWxlY3RFbGVtZW50LnByZXBlbmQobm9uZU9wdGlvbkVsZW1lbnQpO1xuICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9ICgpID0+IHtcbiAgICAgICAgbm9uZU9wdGlvbkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgICAgICByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0VmFsdWUgPSBpc0V4cG9ydCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKS5tYXAob3B0aW9uID0+IG9wdGlvbltuYW1lXSk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiAoe1xuICAgICAgICBkaXNwbGF5VmFsdWU6IG9wdGlvbi50ZXh0Q29udGVudCxcbiAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgfSkpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXhwb3J0VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgY2hhbmdlRXg6IGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKHNlbGVjdEVsZW1lbnQsIG51bGwsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdLCBbXCJpbnB1dFwiLCBcIkFjdGlvblwiXSwgW1wiaW5wdXRcIiwgXCJWYWxpZGF0ZVwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge31cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHNlbGVjdEVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBwYXJhbWV0ZXJzO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMucG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHQsXG4gICAgICByZWN0OiB0aGlzLmRhdGEucmVjdCxcbiAgICAgIHBhcmVudFJlY3Q6IHRoaXMuZGF0YS5wYXJlbnRSZWN0IHx8IG51bGwsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IHRoaXMuZWxlbWVudHMsXG4gICAgICBvcGVuOiB0aGlzLmRhdGEub3BlblxuICAgIH0pO1xuICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgZWxlbWVudC5jb250YWluZXIuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgIGVsZW1lbnRJZHMucHVzaChlbGVtZW50LmRhdGEuaWQpO1xuICAgICAgZWxlbWVudC5hZGRIaWdobGlnaHRBcmVhKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtY29udHJvbHNcIiwgZWxlbWVudElkcy5tYXAoaWQgPT4gYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWApLmpvaW4oXCIsXCIpKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFBvcHVwRWxlbWVudCB7XG4gICNib3VuZEtleURvd24gPSB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyk7XG4gICNib3VuZEhpZGUgPSB0aGlzLiNoaWRlLmJpbmQodGhpcyk7XG4gICNib3VuZFNob3cgPSB0aGlzLiNzaG93LmJpbmQodGhpcyk7XG4gICNib3VuZFRvZ2dsZSA9IHRoaXMuI3RvZ2dsZS5iaW5kKHRoaXMpO1xuICAjY29sb3IgPSBudWxsO1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgI2NvbnRlbnRzT2JqID0gbnVsbDtcbiAgI2RhdGVPYmogPSBudWxsO1xuICAjZWxlbWVudHMgPSBudWxsO1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI3BhcmVudFJlY3QgPSBudWxsO1xuICAjcGlubmVkID0gZmFsc2U7XG4gICNwb3B1cCA9IG51bGw7XG4gICNwb3NpdGlvbiA9IG51bGw7XG4gICNyZWN0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RpdGxlT2JqID0gbnVsbDtcbiAgI3VwZGF0ZXMgPSBudWxsO1xuICAjd2FzVmlzaWJsZSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGFpbmVyLFxuICAgIGNvbG9yLFxuICAgIGVsZW1lbnRzLFxuICAgIHRpdGxlT2JqLFxuICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgY29udGVudHNPYmosXG4gICAgcmljaFRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlY3QsXG4gICAgcGFyZW50UmVjdCxcbiAgICBvcGVuXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdGl0bGVPYmogPSB0aXRsZU9iajtcbiAgICB0aGlzLiNjb250ZW50c09iaiA9IGNvbnRlbnRzT2JqO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuI2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy4jcmVjdCA9IHJlY3Q7XG4gICAgdGhpcy4jcGFyZW50UmVjdCA9IHBhcmVudFJlY3Q7XG4gICAgdGhpcy4jZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgdGhpcy50cmlnZ2VyID0gZWxlbWVudHMuZmxhdE1hcChlID0+IGUuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuI2JvdW5kU2hvdyk7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuI2JvdW5kSGlkZSk7XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJwb3B1cFRyaWdnZXJBcmVhXCIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnQuY29udGFpbmVyPy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24pO1xuICAgIH1cbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICBpZiAob3Blbikge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgaWYgKENTUy5zdXBwb3J0cyhcImJhY2tncm91bmQtY29sb3JcIiwgXCJjb2xvci1taXgoaW4gc3JnYiwgcmVkIDMwJSwgd2hpdGUpXCIpKSB7XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGBjb2xvci1taXgoaW4gc3JnYiwgJHtiYXNlQ29sb3J9IDMwJSwgd2hpdGUpYDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IEJBQ0tHUk9VTkRfRU5MSUdIVCA9IDAuNztcbiAgICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IubWFwKGMgPT4gTWF0aC5mbG9vcihCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gYykgKyBjKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgICBoZWFkZXIuYXBwZW5kKHRpdGxlKTtcbiAgICAoe1xuICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICBzdHI6IHRpdGxlLnRleHRDb250ZW50XG4gICAgfSA9IHRoaXMuI3RpdGxlT2JqKTtcbiAgICBwb3B1cC5hcHBlbmQoaGVhZGVyKTtcbiAgICBpZiAodGhpcy4jZGF0ZU9iaikge1xuICAgICAgY29uc3QgbW9kaWZpY2F0aW9uRGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5jbGFzc0xpc3QuYWRkKFwicG9wdXBEYXRlXCIpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1hbm5vdGF0aW9uLWRhdGUtdGltZS1zdHJpbmdcIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0ZU9iajogdGhpcy4jZGF0ZU9iai52YWx1ZU9mKClcbiAgICAgIH0pKTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSB0aGlzLiNodG1sO1xuICAgIGlmIChodG1sKSB7XG4gICAgICBYZmFMYXllci5yZW5kZXIoe1xuICAgICAgICB4ZmFIdG1sOiBodG1sLFxuICAgICAgICBpbnRlbnQ6IFwicmljaFRleHRcIixcbiAgICAgICAgZGl2OiBwb3B1cFxuICAgICAgfSk7XG4gICAgICBwb3B1cC5sYXN0Q2hpbGQuY2xhc3NMaXN0LmFkZChcInJpY2hUZXh0XCIsIFwicG9wdXBDb250ZW50XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuX2Zvcm1hdENvbnRlbnRzKHRoaXMuI2NvbnRlbnRzT2JqKTtcbiAgICAgIHBvcHVwLmFwcGVuZChjb250ZW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIGdldCAjaHRtbCgpIHtcbiAgICBjb25zdCByaWNoVGV4dCA9IHRoaXMuI3JpY2hUZXh0O1xuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3JpY2hUZXh0Lmh0bWwgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0ICNmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmZvbnRTaXplIHx8IDA7XG4gIH1cbiAgZ2V0ICNmb250Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5jb2xvciB8fCBudWxsO1xuICB9XG4gICNtYWtlUG9wdXBDb250ZW50KHRleHQpIHtcbiAgICBjb25zdCBwb3B1cExpbmVzID0gW107XG4gICAgY29uc3QgcG9wdXBDb250ZW50ID0ge1xuICAgICAgc3RyOiB0ZXh0LFxuICAgICAgaHRtbDoge1xuICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgZGlyOiBcImF1dG9cIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgICBjaGlsZHJlbjogcG9wdXBMaW5lc1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGluZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogdGhpcy4jZm9udENvbG9yLFxuICAgICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUgPyBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgIDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIHBvcHVwTGluZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IFwic3BhblwiLFxuICAgICAgICB2YWx1ZTogbGluZSxcbiAgICAgICAgYXR0cmlidXRlczogbGluZUF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBDb250ZW50O1xuICB9XG4gIF9mb3JtYXRDb250ZW50cyh7XG4gICAgc3RyLFxuICAgIGRpclxuICB9KSB7XG4gICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpO1xuICAgIHAuY2xhc3NMaXN0LmFkZChcInBvcHVwQ29udGVudFwiKTtcbiAgICBwLmRpciA9IGRpcjtcbiAgICBjb25zdCBsaW5lcyA9IHN0ci5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gbGluZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkpO1xuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5IHx8IGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIgfHwgZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiICYmIHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jdG9nZ2xlKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRlZCh7XG4gICAgcmVjdCxcbiAgICBwb3B1cENvbnRlbnRcbiAgfSkge1xuICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgIGNvbnRlbnRzT2JqOiB0aGlzLiNjb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLiNyaWNoVGV4dFxuICAgIH07XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHBvcHVwQ29udGVudCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSB0aGlzLiNtYWtlUG9wdXBDb250ZW50KHBvcHVwQ29udGVudCk7XG4gICAgICB0aGlzLiNjb250ZW50c09iaiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9ID0gdGhpcy4jdXBkYXRlcyk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgI3NldFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIHZpZXdcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICAgICAgcGFnZVgsXG4gICAgICAgICAgcGFnZVlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLiNwYXJlbnQ7XG4gICAgbGV0IHVzZVBhcmVudFJlY3QgPSAhIXRoaXMuI3BhcmVudFJlY3Q7XG4gICAgbGV0IHJlY3QgPSB1c2VQYXJlbnRSZWN0ID8gdGhpcy4jcGFyZW50UmVjdCA6IHRoaXMuI3JlY3Q7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBpZiAoIXJlY3QgfHwgVXRpbC5pbnRlcnNlY3QoZWxlbWVudC5kYXRhLnJlY3QsIHJlY3QpICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3QgPSBlbGVtZW50LmRhdGEucmVjdDtcbiAgICAgICAgdXNlUGFyZW50UmVjdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkUmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgdGhpcy4jcG9zaXRpb24gPSBbMTAwICogKHBvcHVwTGVmdCAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCwgMTAwICogKHBvcHVwVG9wIC0gcGFnZVkpIC8gcGFnZUhlaWdodF07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHt0aGlzLiNwb3NpdGlvblswXX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHt0aGlzLiNwb3NpdGlvblsxXX0lYDtcbiAgfVxuICAjdG9nZ2xlKCkge1xuICAgIHRoaXMuI3Bpbm5lZCA9ICF0aGlzLiNwaW5uZWQ7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGlkZSgpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gIH1cbiAgI3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy4jc2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgfVxuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9PT0gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gcGFyYW1ldGVycy5kYXRhLnRleHRDb250ZW50O1xuICAgIHRoaXMudGV4dFBvc2l0aW9uID0gcGFyYW1ldGVycy5kYXRhLnRleHRQb3NpdGlvbjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEFubm90YXRpb25cIik7XG4gICAgaWYgKHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QuYWRkKFwiYW5ub3RhdGlvblRleHRDb250ZW50XCIpO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGxpbmVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIGxpbmVTcGFuLnRleHRDb250ZW50ID0gbGluZTtcbiAgICAgICAgY29udGVudC5hcHBlbmQobGluZVNwYW4pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGNvbnRlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIExpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2xpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy4jbGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1swXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1sxXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBkYXRhLnJlY3RbMl0gLSBkYXRhLmxpbmVDb29yZGluYXRlc1syXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1szXSk7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQobGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3NxdWFyZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWFyZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IHNxdWFyZSA9IHRoaXMuI3NxdWFyZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInhcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3aWR0aCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCAtIGJvcmRlcldpZHRoKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoc3F1YXJlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBjaXJjbGUgPSB0aGlzLiNjaXJjbGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzplbGxpcHNlXCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCB3aWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnhcIiwgd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFkYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2lyY2xlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgdmVydGljZXMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdmVydGljZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMocmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBsZXQgcG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgY29uc3QgeCA9IHZlcnRpY2VzW2ldIC0gcmVjdFswXTtcbiAgICAgIGNvbnN0IHkgPSByZWN0WzNdIC0gdmVydGljZXNbaSArIDFdO1xuICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xuICAgIH1cbiAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLiNwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxufVxuY2xhc3MgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIElua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjcG9seWxpbmVzID0gW107XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwiaW5rQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSB0aGlzLmRhdGEuaXQgPT09IFwiSW5rSGlnaGxpZ2h0XCIgPyBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQgOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgZm9yIChjb25zdCBpbmtMaXN0IG9mIGlua0xpc3RzKSB7XG4gICAgICBsZXQgcG9pbnRzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0Lmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgeCA9IGlua0xpc3RbaV0gLSByZWN0WzBdO1xuICAgICAgICBjb25zdCB5ID0gcmVjdFszXSAtIGlua0xpc3RbaSArIDFdO1xuICAgICAgICBwb2ludHMucHVzaChgJHt4fSwke3l9YCk7XG4gICAgICB9XG4gICAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy4jcG9seWxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHN2Zy5hcHBlbmQocG9seWxpbmUpO1xuICAgIH1cbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZXM7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInVuZGVybGluZUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdGFtcEFubm90YXRpb25cIik7XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImltZ1wiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN0cmlnZ2VyID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGVcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlLmZpbGVuYW1lO1xuICAgIHRoaXMuY29udGVudCA9IGZpbGUuY29udGVudDtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImZpbGVhdHRhY2htZW50YW5ub3RhdGlvblwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAuLi5maWxlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJmaWxlQXR0YWNobWVudEFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB0cmlnZ2VyO1xuICAgIGlmIChkYXRhLmhhc0FwcGVhcmFuY2UgfHwgZGF0YS5maWxsQWxwaGEgPT09IDApIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICAgIHRyaWdnZXIuc3JjID0gYCR7dGhpcy5pbWFnZVJlc291cmNlc1BhdGh9YW5ub3RhdGlvbi0key9wYXBlcmNsaXAvaS50ZXN0KGRhdGEubmFtZSkgPyBcInBhcGVyY2xpcFwiIDogXCJwdXNocGluXCJ9LnN2Z2A7XG4gICAgICBpZiAoZGF0YS5maWxsQWxwaGEgJiYgZGF0YS5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIHRyaWdnZXIuc3R5bGUgPSBgZmlsdGVyOiBvcGFjaXR5KCR7TWF0aC5yb3VuZChkYXRhLmZpbGxBbHBoYSAqIDEwMCl9JSk7YDtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgdGhpcy4jZG93bmxvYWQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy4jdHJpZ2dlciA9IHRyaWdnZXI7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZ0ID0+IHtcbiAgICAgIGlmIChldnQua2V5ID09PSBcIkVudGVyXCIgJiYgKGlzTWFjID8gZXZ0Lm1ldGFLZXkgOiBldnQuY3RybEtleSkpIHtcbiAgICAgICAgdGhpcy4jZG93bmxvYWQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmlnZ2VyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbiAgI2Rvd25sb2FkKCkge1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25DYW52YXNNYXAgPSBudWxsO1xuICAjZWRpdGFibGVBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgI3N0cnVjdFRyZWVMYXllciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkaXYsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICBhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLFxuICAgIHBhZ2UsXG4gICAgdmlld3BvcnQsXG4gICAgc3RydWN0VHJlZUxheWVyXG4gIH0pIHtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMuI3N0cnVjdFRyZWVMYXllciA9IHN0cnVjdFRyZWVMYXllciB8fCBudWxsO1xuICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuekluZGV4ID0gMDtcbiAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbiAgfVxuICBoYXNFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNpemUgPiAwO1xuICB9XG4gIGFzeW5jICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb25zdCBhbm5vdGF0aW9uSWQgPSBjb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIGNvbnN0IGFyaWFBdHRyaWJ1dGVzID0gYXdhaXQgdGhpcy4jc3RydWN0VHJlZUxheWVyPy5nZXRBcmlhQXR0cmlidXRlcyhhbm5vdGF0aW9uSWQpO1xuICAgIGlmIChhcmlhQXR0cmlidXRlcykge1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29udGVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVsZW1lbnQsIGNvbnRlbnRFbGVtZW50LCBmYWxzZSk7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXIsXG4gICAgICBsaW5rU2VydmljZTogcGFyYW1zLmxpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogcGFyYW1zLmFubm90YXRpb25TdG9yYWdlIHx8IG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpLFxuICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbXMuZW5hYmxlU2NyaXB0aW5nID09PSB0cnVlLFxuICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbXMuaGFzSlNBY3Rpb25zLFxuICAgICAgZmllbGRPYmplY3RzOiBwYXJhbXMuZmllbGRPYmplY3RzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgZWxlbWVudHM6IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEubm9IVE1MKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQb3B1cEFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb25UeXBlID09PSBBbm5vdGF0aW9uVHlwZS5QT1BVUDtcbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFBhcmFtcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgfVxuICAgICAgZWxlbWVudFBhcmFtcy5kYXRhID0gZGF0YTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKGVsZW1lbnRQYXJhbXMpO1xuICAgICAgaWYgKCFlbGVtZW50LmlzUmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24gJiYgZGF0YS5wb3B1cFJlZikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5wb3B1cFJlZik7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBwb3B1cFRvRWxlbWVudHMuc2V0KGRhdGEucG9wdXBSZWYsIFtlbGVtZW50XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgaWYgKGRhdGEuaGlkZGVuKSB7XG4gICAgICAgIHJlbmRlcmVkLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgfVxuICAgICAgYXdhaXQgdGhpcy4jYXBwZW5kRWxlbWVudChyZW5kZXJlZCwgZGF0YS5pZCk7XG4gICAgICBpZiAoZWxlbWVudC5faXNFZGl0YWJsZSkge1xuICAgICAgICB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnNldChlbGVtZW50LmRhdGEuaWQsIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyPy5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICAgIGxheWVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gICNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCkge1xuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgW2lkLCBjYW52YXNdIG9mIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllci5xdWVyeVNlbGVjdG9yKGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpcnN0Q2hpbGRcbiAgICAgIH0gPSBlbGVtZW50O1xuICAgICAgaWYgKCFmaXJzdENoaWxkKSB7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0Q2hpbGQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5yZXBsYWNlV2l0aChjYW52YXMpO1xuICAgICAgfSBlbHNlIGlmICghZmlyc3RDaGlsZC5jbGFzc0xpc3QuY29udGFpbnMoXCJhbm5vdGF0aW9uQ29udGVudFwiKSkge1xuICAgICAgICBmaXJzdENoaWxkLmJlZm9yZShjYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3RDaGlsZC5hZnRlcihjYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwLmNsZWFyKCk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9mcmVldGV4dC5qc1xuXG5cblxuXG5jb25zdCBFT0xfUEFUVEVSTiA9IC9cXHJcXG4/fFxcbi9nO1xuY2xhc3MgRnJlZVRleHRFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2NvbG9yO1xuICAjY29udGVudCA9IFwiXCI7XG4gICNlZGl0b3JEaXZJZCA9IGAke3RoaXMuaWR9LWVkaXRvcmA7XG4gICNlZGl0TW9kZUFDID0gbnVsbDtcbiAgI2ZvbnRTaXplO1xuICBzdGF0aWMgX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQgPSBcIlwiO1xuICBzdGF0aWMgX2ludGVybmFsUGFkZGluZyA9IDA7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Rm9udFNpemUgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gRnJlZVRleHRFZGl0b3IucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi5pc0VtcHR5KCk7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrc1wiLCBcIm1hYyttZXRhK3NcIiwgXCJjdHJsK3BcIiwgXCJtYWMrbWV0YStwXCJdLCBwcm90by5jb21taXRPclJlbW92ZSwge1xuICAgICAgYnViYmxlczogdHJ1ZVxuICAgIH1dLCBbW1wiY3RybCtFbnRlclwiLCBcIm1hYyttZXRhK0VudGVyXCIsIFwiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8uY29tbWl0T3JSZW1vdmVdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBzdGF0aWMgX3R5cGUgPSBcImZyZWV0ZXh0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImZyZWVUZXh0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNjb2xvciA9IHBhcmFtcy5jb2xvciB8fCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgdGhpcy4jZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB0aGlzLl9pbnRlcm5hbFBhZGRpbmcgPSBwYXJzZUZsb2F0KHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCItLWZyZWV0ZXh0LXBhZGRpbmdcIikpO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgdGhpcy4jdXBkYXRlRm9udFNpemUodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIHRoaXMuI2ZvbnRTaXplXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCB0aGlzLiNjb2xvcl1dO1xuICB9XG4gICN1cGRhdGVGb250U2l6ZShmb250U2l6ZSkge1xuICAgIGNvbnN0IHNldEZvbnRzaXplID0gc2l6ZSA9PiB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7c2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgIHRoaXMudHJhbnNsYXRlKDAsIC0oc2l6ZSAtIHRoaXMuI2ZvbnRTaXplKSAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgICAgdGhpcy4jZm9udFNpemUgPSBzaXplO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRGb250c2l6ZSA9IHRoaXMuI2ZvbnRTaXplO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIGZvbnRTaXplKSxcbiAgICAgIHVuZG86IHNldEZvbnRzaXplLmJpbmQodGhpcywgc2F2ZWRGb250c2l6ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSBjb2wgPT4ge1xuICAgICAgdGhpcy4jY29sb3IgPSB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IGNvbDtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3IuYmluZCh0aGlzLCBjb2xvciksXG4gICAgICB1bmRvOiBzZXRDb2xvci5iaW5kKHRoaXMsIHNhdmVkQ29sb3IpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICBfdHJhbnNsYXRlRW1wdHkoeCwgeSkge1xuICAgIHRoaXMuX3VpTWFuYWdlci50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgdHJ1ZSk7XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5wYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gWy1GcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICogc2NhbGUsIC0oRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyArIHRoaXMuI2ZvbnRTaXplKSAqIHNjYWxlXTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcihBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCk7XG4gICAgc3VwZXIuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LnJlbW92ZShcImVuYWJsZWRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNlZGl0TW9kZUFDKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmVkaXRvckRpdktleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuZWRpdG9yRGl2Rm9jdXMuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy5lZGl0b3JEaXZCbHVyLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCB0aGlzLmVkaXRvckRpdklucHV0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLmVkaXRvckRpdlBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgdGhpcy4jZWRpdG9yRGl2SWQpO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLiNlZGl0TW9kZUFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2VkaXRNb2RlQUMgPSBudWxsO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVkaXRvckRpdiB8fCB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQudHJpbSgpID09PSBcIlwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVldGV4dEVkaXRpbmdcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gICNleHRyYWN0VGV4dCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICB0aGlzLmVkaXRvckRpdi5ub3JtYWxpemUoKTtcbiAgICBsZXQgcHJldkNoaWxkID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChwcmV2Q2hpbGQ/Lm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSAmJiBjaGlsZC5ub2RlTmFtZSA9PT0gXCJCUlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICBwcmV2Q2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXFxuXCIpO1xuICB9XG4gICNzZXRFZGl0b3JEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBsZXQgcmVjdDtcbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50TGF5ZXIsXG4gICAgICAgIGRpdlxuICAgICAgfSA9IHRoaXM7XG4gICAgICBjb25zdCBzYXZlZERpc3BsYXkgPSBkaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgIGNvbnN0IHNhdmVkVmlzaWJpbGl0eSA9IGRpdi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gICAgICBkaXYuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGN1cnJlbnRMYXllci5kaXYuYXBwZW5kKHRoaXMuZGl2KTtcbiAgICAgIHJlY3QgPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IHNhdmVkRGlzcGxheTtcbiAgICAgIGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsIHNhdmVkVmlzaWJpbGl0eSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvdGF0aW9uICUgMTgwID09PSB0aGlzLnBhcmVudFJvdGF0aW9uICUgMTgwKSB7XG4gICAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LmhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHJlY3Qud2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzSW5FZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgY29uc3Qgc2F2ZWRUZXh0ID0gdGhpcy4jY29udGVudDtcbiAgICBjb25zdCBuZXdUZXh0ID0gdGhpcy4jY29udGVudCA9IHRoaXMuI2V4dHJhY3RUZXh0KCkudHJpbUVuZCgpO1xuICAgIGlmIChzYXZlZFRleHQgPT09IG5ld1RleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2V0VGV4dCA9IHRleHQgPT4ge1xuICAgICAgdGhpcy4jY29udGVudCA9IHRleHQ7XG4gICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlYnVpbGQodGhpcyk7XG4gICAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBzZXRUZXh0KG5ld1RleHQpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChzYXZlZFRleHQpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cbiAgZGJsY2xpY2soZXZlbnQpIHtcbiAgICB0aGlzLmVudGVySW5FZGl0TW9kZSgpO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRpdiAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVkaXRvckRpdktleWRvd24oZXZlbnQpIHtcbiAgICBGcmVlVGV4dEVkaXRvci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gIGVkaXRvckRpdkZvY3VzKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuICB9XG4gIGVkaXRvckRpdkJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICB9XG4gIGVkaXRvckRpdklucHV0KGV2ZW50KSB7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmcmVldGV4dEVkaXRpbmdcIiwgdGhpcy5pc0VtcHR5KCkpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRleHRib3hcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIiwgdHJ1ZSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmVkaXRvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1mcmVlLXRleHQyXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hdHRyc1wiLCBcImRlZmF1bHQtY29udGVudFwiKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZWRpdG9yRGl2O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmVkaXRvckRpdik7XG4gICAgdGhpcy5vdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcIm92ZXJsYXlcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLm92ZXJsYXlEaXYpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy5kaXYsIFtcImRibGNsaWNrXCIsIFwia2V5ZG93blwiXSk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICAgICAgbGV0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICAgICAgW3R4LCB0eV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHR4LCB0eSk7XG4gICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHBvc1gsIHBvc1k7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIHRoaXMuaGVpZ2h0IC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbdHksIC10eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCAtIHRoaXMud2lkdGggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR4LCAtdHldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCAtIHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyAocG9zaXRpb25bMV0gLSBwYWdlWSAtIHRoaXMud2lkdGggKiBwYWdlV2lkdGgpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eSwgdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdChwb3NYICogcGFyZW50V2lkdGgsIHBvc1kgKiBwYXJlbnRIZWlnaHQsIHR4LCB0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHN0YXRpYyAjZ2V0Tm9kZUNvbnRlbnQobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgPyBub2RlLm5vZGVWYWx1ZSA6IG5vZGUuaW5uZXJUZXh0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKTtcbiAgfVxuICBlZGl0b3JEaXZQYXN0ZShldmVudCkge1xuICAgIGNvbnN0IGNsaXBib2FyZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhIHx8IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVzXG4gICAgfSA9IGNsaXBib2FyZERhdGE7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gXCJ0ZXh0L3BsYWluXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBwYXN0ZSA9IEZyZWVUZXh0RWRpdG9yLiNkZXNlcmlhbGl6ZUNvbnRlbnQoY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dFwiKSB8fCBcIlwiKS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlxcblwiKTtcbiAgICBpZiAoIXBhc3RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbi5yYW5nZUNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgIHNlbGVjdGlvbi5kZWxldGVGcm9tRG9jdW1lbnQoKTtcbiAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIGlmICghcGFzdGUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgIHJhbmdlLmluc2VydE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGFzdGUpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2Lm5vcm1hbGl6ZSgpO1xuICAgICAgc2VsZWN0aW9uLmNvbGxhcHNlVG9TdGFydCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdGFydENvbnRhaW5lcixcbiAgICAgIHN0YXJ0T2Zmc2V0XG4gICAgfSA9IHJhbmdlO1xuICAgIGNvbnN0IGJ1ZmZlckJlZm9yZSA9IFtdO1xuICAgIGNvbnN0IGJ1ZmZlckFmdGVyID0gW107XG4gICAgaWYgKHN0YXJ0Q29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICAgIGJ1ZmZlckFmdGVyLnB1c2goc3RhcnRDb250YWluZXIubm9kZVZhbHVlLnNsaWNlKHN0YXJ0T2Zmc2V0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKSk7XG4gICAgICBpZiAocGFyZW50ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgICBsZXQgYnVmZmVyID0gYnVmZmVyQmVmb3JlO1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyQWZ0ZXI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJ1ZmZlckJlZm9yZS5wdXNoKHN0YXJ0Q29udGFpbmVyLm5vZGVWYWx1ZS5zbGljZSgwLCBzdGFydE9mZnNldCkucmVwbGFjZUFsbChFT0xfUEFUVEVSTiwgXCJcIikpO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRDb250YWluZXIgPT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICBsZXQgYnVmZmVyID0gYnVmZmVyQmVmb3JlO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICAgIGlmIChpKysgPT09IHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1c2goRnJlZVRleHRFZGl0b3IuI2dldE5vZGVDb250ZW50KGNoaWxkKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbnRlbnQgPSBgJHtidWZmZXJCZWZvcmUuam9pbihcIlxcblwiKX0ke3Bhc3RlfSR7YnVmZmVyQWZ0ZXIuam9pbihcIlxcblwiKX1gO1xuICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICBjb25zdCBuZXdSYW5nZSA9IG5ldyBSYW5nZSgpO1xuICAgIGxldCBiZWZvcmVMZW5ndGggPSBidWZmZXJCZWZvcmUucmVkdWNlKChhY2MsIGxpbmUpID0+IGFjYyArIGxpbmUubGVuZ3RoLCAwKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGZpcnN0Q2hpbGRcbiAgICB9IG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChmaXJzdENoaWxkLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBmaXJzdENoaWxkLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChiZWZvcmVMZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRFbmQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVMZW5ndGggLT0gbGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgfVxuICAjc2V0Q29udGVudCgpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBpZiAoIXRoaXMuI2NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQoZGl2KTtcbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRlbnQucmVwbGFjZUFsbChcIlxceGEwXCIsIFwiIFwiKTtcbiAgfVxuICBzdGF0aWMgI2Rlc2VyaWFsaXplQ29udGVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChcIiBcIiwgXCJcXHhhMFwiKTtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXY7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRlZmF1bHRBcHBlYXJhbmNlRGF0YToge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250Q29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcG9wdXBSZWZcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIXRleHRDb250ZW50IHx8IHRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShmb250Q29sb3IpLFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgdmFsdWU6IHRleHRDb250ZW50LmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLiNmb250U2l6ZSA9IGRhdGEuZm9udFNpemU7XG4gICAgZWRpdG9yLiNjb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci4jY29udGVudCA9IEZyZWVUZXh0RWRpdG9yLiNkZXNlcmlhbGl6ZUNvbnRlbnQoZGF0YS52YWx1ZSk7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuaXNBdHRhY2hlZFRvRE9NID8gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVkaXRvckRpdikuY29sb3IgOiB0aGlzLiNjb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgIGNvbG9yLFxuICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplLFxuICAgICAgdmFsdWU6IHRoaXMuI3NlcmlhbGl6ZUNvbnRlbnQoKSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQgJiYgIXRoaXMuI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc2VyaWFsaXplZC5pZCA9IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlLFxuICAgICAgZm9udFNpemUsXG4gICAgICBjb2xvcixcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gdGhpcy5faGFzQmVlbk1vdmVkIHx8IHNlcmlhbGl6ZWQudmFsdWUgIT09IHZhbHVlIHx8IHNlcmlhbGl6ZWQuZm9udFNpemUgIT09IGZvbnRTaXplIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzdXBlci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGVudDtcbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7dGhpcy4jZm9udFNpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICBjb250ZW50LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgY29udGVudC5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKSxcbiAgICAgIHBvcHVwQ29udGVudDogdGhpcy4jY29udGVudFxuICAgIH0pO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIHJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIHN1cGVyLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbik7XG4gICAgYW5ub3RhdGlvbi5yZXNldEVkaXRlZCgpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL291dGxpbmUuanNcblxuY2xhc3MgT3V0bGluZSB7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgdG9TVkdQYXRoYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBib3hgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShfYmJveCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHNlcmlhbGl6ZWAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgZ2V0IGNsYXNzTmFtZXNGb3JEcmF3aW5nKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBjbGFzc05hbWVzRm9yRHJhd2luZ2AgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgZ2V0IGNsYXNzTmFtZXNGb3JPdXRsaW5pbmcoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBnZXR0ZXIgYGNsYXNzTmFtZXNGb3JPdXRsaW5pbmdgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIGdldCBtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3ZXJzL2ZyZWVkcmF3LmpzXG5cblxuY2xhc3MgRnJlZURyYXdPdXRsaW5lciB7XG4gICNib3g7XG4gICNib3R0b20gPSBbXTtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICN0b3AgPSBbXTtcbiAgI2xhc3QgPSBuZXcgRmxvYXQ2NEFycmF5KDE4KTtcbiAgI2xhc3RYO1xuICAjbGFzdFk7XG4gICNtaW47XG4gICNtaW5fZGlzdDtcbiAgI3NjYWxlRmFjdG9yO1xuICAjdGhpY2tuZXNzO1xuICAjcG9pbnRzID0gW107XG4gIHN0YXRpYyAjTUlOX0RJU1QgPSA4O1xuICBzdGF0aWMgI01JTl9ESUZGID0gMjtcbiAgc3RhdGljICNNSU4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCArIEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESUZGO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgeCxcbiAgICB5XG4gIH0sIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3MgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMuI2xhc3Quc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHldLCA2KTtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI21pbl9kaXN0ID0gRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJU1QgKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNtaW4gPSBGcmVlRHJhd091dGxpbmVyLiNNSU4gKiBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNzY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIGlzTmFOKHRoaXMuI2xhc3RbOF0pO1xuICB9XG4gICNnZXRMYXN0Q29vcmRzKCkge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIHJldHVybiBbKHRoaXMuI2xhc3RYICsgKGxhc3RUb3BbMF0gLSBsYXN0Qm90dG9tWzBdKSAvIDIgLSB4KSAvIHdpZHRoLCAodGhpcy4jbGFzdFkgKyAobGFzdFRvcFsxXSAtIGxhc3RCb3R0b21bMV0pIC8gMiAtIHkpIC8gaGVpZ2h0LCAodGhpcy4jbGFzdFggKyAobGFzdEJvdHRvbVswXSAtIGxhc3RUb3BbMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0Qm90dG9tWzFdIC0gbGFzdFRvcFsxXSkgLyAyIC0geSkgLyBoZWlnaHRdO1xuICB9XG4gIGFkZCh7XG4gICAgeCxcbiAgICB5XG4gIH0pIHtcbiAgICB0aGlzLiNsYXN0WCA9IHg7XG4gICAgdGhpcy4jbGFzdFkgPSB5O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSg4LCAxMik7XG4gICAgY29uc3QgZGlmZlggPSB4IC0geDI7XG4gICAgY29uc3QgZGlmZlkgPSB5IC0geTI7XG4gICAgY29uc3QgZCA9IE1hdGguaHlwb3QoZGlmZlgsIGRpZmZZKTtcbiAgICBpZiAoZCA8IHRoaXMuI21pbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBkaWZmRCA9IGQgLSB0aGlzLiNtaW5fZGlzdDtcbiAgICBjb25zdCBLID0gZGlmZkQgLyBkO1xuICAgIGNvbnN0IHNoaWZ0WCA9IEsgKiBkaWZmWDtcbiAgICBjb25zdCBzaGlmdFkgPSBLICogZGlmZlk7XG4gICAgbGV0IHgwID0geDE7XG4gICAgbGV0IHkwID0geTE7XG4gICAgeDEgPSB4MjtcbiAgICB5MSA9IHkyO1xuICAgIHgyICs9IHNoaWZ0WDtcbiAgICB5MiArPSBzaGlmdFk7XG4gICAgdGhpcy4jcG9pbnRzPy5wdXNoKHgsIHkpO1xuICAgIGNvbnN0IG5YID0gLXNoaWZ0WSAvIGRpZmZEO1xuICAgIGNvbnN0IG5ZID0gc2hpZnRYIC8gZGlmZkQ7XG4gICAgY29uc3QgdGhYID0gblggKiB0aGlzLiN0aGlja25lc3M7XG4gICAgY29uc3QgdGhZID0gblkgKiB0aGlzLiN0aGlja25lc3M7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgyLCA4KSwgMCk7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyICsgdGhYLCB5MiArIHRoWV0sIDQpO1xuICAgIHRoaXMuI2xhc3Quc2V0KHRoaXMuI2xhc3Quc3ViYXJyYXkoMTQsIDE4KSwgMTIpO1xuICAgIHRoaXMuI2xhc3Quc2V0KFt4MiAtIHRoWCwgeTIgLSB0aFldLCAxNik7XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbNl0pKSB7XG4gICAgICBpZiAodGhpcy4jdG9wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLiNsYXN0LnNldChbeDEgKyB0aFgsIHkxICsgdGhZXSwgMik7XG4gICAgICAgIHRoaXMuI3RvcC5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxICsgdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSArIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSAtIHRoWCwgeTEgLSB0aFldLCAxNCk7XG4gICAgICAgIHRoaXMuI2JvdHRvbS5wdXNoKE5hTiwgTmFOLCBOYU4sIE5hTiwgKHgxIC0gdGhYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICh5MSAtIHRoWSAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICB9XG4gICAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdLCA2KTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGguYWJzKE1hdGguYXRhbjIoeTAgLSB5MSwgeDAgLSB4MSkgLSBNYXRoLmF0YW4yKHNoaWZ0WSwgc2hpZnRYKSk7XG4gICAgaWYgKGFuZ2xlIDwgTWF0aC5QSSAvIDIpIHtcbiAgICAgIFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDYpO1xuICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICBbeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpO1xuICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoKHgwICsgeDEpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgeTEpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgwLCA2KTtcbiAgICB0aGlzLiN0b3AucHVzaCgoKHgwICsgNSAqIHgxKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MCArIDUgKiB5MSkgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKDUgKiB4MSArIHgyKSAvIDYgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCg1ICogeTEgKyB5MikgLyA2IC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCAoKHgxICsgeDIpIC8gMiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkxICsgeTIpIC8gMiAtIGxheWVyWSkgLyBsYXllckhlaWdodCk7XG4gICAgW3gyLCB5MiwgeDEsIHkxLCB4MCwgeTBdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxMiwgMTgpO1xuICAgIHRoaXMuI2JvdHRvbS5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdG9TVkdQYXRoVHdvUG9pbnRzKCk7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGJ1ZmZlci5wdXNoKGBNJHt0b3BbNF19ICR7dG9wWzVdfWApO1xuICAgIGZvciAobGV0IGkgPSA2OyBpIDwgdG9wLmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBidWZmZXIucHVzaChgTCR7dG9wW2kgKyA0XX0gJHt0b3BbaSArIDVdfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEMke3RvcFtpXX0gJHt0b3BbaSArIDFdfSAke3RvcFtpICsgMl19ICR7dG9wW2kgKyAzXX0gJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3RvU1ZHUGF0aEVuZChidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSBib3R0b20ubGVuZ3RoIC0gNjsgaSA+PSA2OyBpIC09IDYpIHtcbiAgICAgIGlmIChpc05hTihib3R0b21baV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21baSArIDRdfSAke2JvdHRvbVtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7Ym90dG9tW2ldfSAke2JvdHRvbVtpICsgMV19ICR7Ym90dG9tW2kgKyAyXX0gJHtib3R0b21baSArIDNdfSAke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoU3RhcnQoYnVmZmVyKTtcbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gICN0b1NWR1BhdGhUd29Qb2ludHMoKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgcmV0dXJuIGBNJHsodGhpcy4jbGFzdFsyXSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbM10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzVdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KHRoaXMuI2xhc3RbMTZdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxN10gLSB5KSAvIGhlaWdodH0gTCR7KHRoaXMuI2xhc3RbMTRdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFsxNV0gLSB5KSAvIGhlaWdodH0gWmA7XG4gIH1cbiAgI3RvU1ZHUGF0aFN0YXJ0KGJ1ZmZlcikge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBidWZmZXIucHVzaChgTCR7Ym90dG9tWzRdfSAke2JvdHRvbVs1XX0gWmApO1xuICB9XG4gICN0b1NWR1BhdGhFbmQoYnVmZmVyKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBidWZmZXIucHVzaChgTCR7KGxhc3RUb3BbMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0VG9wWzFdIC0geSkgLyBoZWlnaHR9IEwke2xhc3RUb3BYfSAke2xhc3RUb3BZfSBMJHtsYXN0Qm90dG9tWH0gJHtsYXN0Qm90dG9tWX0gTCR7KGxhc3RCb3R0b21bMF0gLSB4KSAvIHdpZHRofSAkeyhsYXN0Qm90dG9tWzFdIC0geSkgLyBoZWlnaHR9YCk7XG4gIH1cbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpO1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIGNvbnN0IHRvcCA9IHRoaXMuI3RvcDtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgY29uc3QgbGFzdCA9IHRoaXMuI2xhc3Q7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgcG9pbnRzID0gbmV3IEZsb2F0NjRBcnJheSgodGhpcy4jcG9pbnRzPy5sZW5ndGggPz8gMCkgKyAyKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoIC0gMjsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIHBvaW50c1tpXSA9ICh0aGlzLiNwb2ludHNbaV0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aDtcbiAgICAgIHBvaW50c1tpICsgMV0gPSAodGhpcy4jcG9pbnRzW2kgKyAxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICB9XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSA9ICh0aGlzLiNsYXN0WCAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gPSAodGhpcy4jbGFzdFkgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQ7XG4gICAgaWYgKGlzTmFOKGxhc3RbNl0pICYmICF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2dldE91dGxpbmVUd29Qb2ludHMocG9pbnRzKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDY0QXJyYXkodGhpcy4jdG9wLmxlbmd0aCArIDI0ICsgdGhpcy4jYm90dG9tLmxlbmd0aCk7XG4gICAgbGV0IE4gPSB0b3AubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSArPSAyKSB7XG4gICAgICBpZiAoaXNOYU4odG9wW2ldKSkge1xuICAgICAgICBvdXRsaW5lW2ldID0gb3V0bGluZVtpICsgMV0gPSBOYU47XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgb3V0bGluZVtpXSA9IHRvcFtpXTtcbiAgICAgIG91dGxpbmVbaSArIDFdID0gdG9wW2kgKyAxXTtcbiAgICB9XG4gICAgTiA9IHRoaXMuI2dldE91dGxpbmVFbmQob3V0bGluZSwgTik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcbiAgICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpICsgal0pKSB7XG4gICAgICAgICAgb3V0bGluZVtOXSA9IG91dGxpbmVbTiArIDFdID0gTmFOO1xuICAgICAgICAgIE4gKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBvdXRsaW5lW05dID0gYm90dG9tW2kgKyBqXTtcbiAgICAgICAgb3V0bGluZVtOICsgMV0gPSBib3R0b21baSArIGogKyAxXTtcbiAgICAgICAgTiArPSAyO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNnZXRPdXRsaW5lU3RhcnQob3V0bGluZSwgTik7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpIHtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGNvbnN0IG91dGxpbmUgPSBuZXcgRmxvYXQ2NEFycmF5KDM2KTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsyXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFszXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFs0XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFs1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzE2XSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFsxN10gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE1XSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIDApO1xuICAgIHJldHVybiB0aGlzLm5ld0ZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIHRoaXMuI2JveCwgdGhpcy4jc2NhbGVGYWN0b3IsIHRoaXMuI2lubmVyTWFyZ2luLCB0aGlzLiNpc0xUUik7XG4gIH1cbiAgI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBib3R0b20gPSB0aGlzLiNib3R0b207XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgYm90dG9tWzRdLCBib3R0b21bNV1dLCBwb3MpO1xuICAgIHJldHVybiBwb3MgKz0gNjtcbiAgfVxuICAjZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBwb3MpIHtcbiAgICBjb25zdCBsYXN0VG9wID0gdGhpcy4jbGFzdC5zdWJhcnJheSg0LCA2KTtcbiAgICBjb25zdCBsYXN0Qm90dG9tID0gdGhpcy4jbGFzdC5zdWJhcnJheSgxNiwgMTgpO1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgb3V0bGluZS5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RUb3BbMF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RUb3BbMV0gLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdFRvcFgsIGxhc3RUb3BZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdEJvdHRvbVswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdEJvdHRvbVsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodF0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSAyNDtcbiAgfVxufVxuY2xhc3MgRnJlZURyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNib3g7XG4gICNiYm94ID0gbnVsbDtcbiAgI2lubmVyTWFyZ2luO1xuICAjaXNMVFI7XG4gICNwb2ludHM7XG4gICNzY2FsZUZhY3RvcjtcbiAgI291dGxpbmU7XG4gIGNvbnN0cnVjdG9yKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lID0gb3V0bGluZTtcbiAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jaW5uZXJNYXJnaW4gPSBpbm5lck1hcmdpbjtcbiAgICB0aGlzLiNpc0xUUiA9IGlzTFRSO1xuICAgIHRoaXMuI2NvbXB1dGVNaW5NYXgoaXNMVFIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jYmJveDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVbaV0gPSAob3V0bGluZVtpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBvdXRsaW5lW2kgKyAxXSA9IChvdXRsaW5lW2kgKyAxXSAtIHkpIC8gaGVpZ2h0O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHBvaW50c1tpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBwb2ludHNbaSArIDFdID0gKHBvaW50c1tpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtgTSR7dGhpcy4jb3V0bGluZVs0XX0gJHt0aGlzLiNvdXRsaW5lWzVdfWBdO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IHRoaXMuI291dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKHRoaXMuI291dGxpbmVbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChgQyR7dGhpcy4jb3V0bGluZVtpXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAxXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAyXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAzXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICB9XG4gICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtibFgsIGJsWSwgdHJYLCB0clldLCByb3RhdGlvbikge1xuICAgIGNvbnN0IHdpZHRoID0gdHJYIC0gYmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyWSAtIGJsWTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICBsZXQgcG9pbnRzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgb3V0bGluZSA9IHRoaXMuI3Jlc2NhbGUodGhpcy4jb3V0bGluZSwgYmxYLCB0clksIHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gdGhpcy4jcmVzY2FsZSh0aGlzLiNwb2ludHMsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgb3V0bGluZSA9IHRoaXMuI3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIGJsWCwgYmxZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gdGhpcy4jcmVzY2FsZUFuZFN3YXAodGhpcy4jcG9pbnRzLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIG91dGxpbmUgPSB0aGlzLiNyZXNjYWxlKHRoaXMuI291dGxpbmUsIHRyWCwgYmxZLCAtd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuI3Jlc2NhbGUodGhpcy4jcG9pbnRzLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBvdXRsaW5lID0gdGhpcy4jcmVzY2FsZUFuZFN3YXAodGhpcy4jb3V0bGluZSwgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IHRoaXMuI3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3V0bGluZTogQXJyYXkuZnJvbShvdXRsaW5lKSxcbiAgICAgIHBvaW50czogW0FycmF5LmZyb20ocG9pbnRzKV1cbiAgICB9O1xuICB9XG4gICNyZXNjYWxlKHNyYywgdHgsIHR5LCBzeCwgc3kpIHtcbiAgICBjb25zdCBkZXN0ID0gbmV3IEZsb2F0NjRBcnJheShzcmMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBzcmMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgZGVzdFtpXSA9IHR4ICsgc3JjW2ldICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXSAqIHN5O1xuICAgIH1cbiAgICByZXR1cm4gZGVzdDtcbiAgfVxuICAjcmVzY2FsZUFuZFN3YXAoc3JjLCB0eCwgdHksIHN4LCBzeSkge1xuICAgIGNvbnN0IGRlc3QgPSBuZXcgRmxvYXQ2NEFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaSArIDFdICogc3g7XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2ldICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gICNjb21wdXRlTWluTWF4KGlzTFRSKSB7XG4gICAgY29uc3Qgb3V0bGluZSA9IHRoaXMuI291dGxpbmU7XG4gICAgbGV0IGxhc3RYID0gb3V0bGluZVs0XTtcbiAgICBsZXQgbGFzdFkgPSBvdXRsaW5lWzVdO1xuICAgIGxldCBtaW5YID0gbGFzdFg7XG4gICAgbGV0IG1pblkgPSBsYXN0WTtcbiAgICBsZXQgbWF4WCA9IGxhc3RYO1xuICAgIGxldCBtYXhZID0gbGFzdFk7XG4gICAgbGV0IGxhc3RQb2ludFggPSBsYXN0WDtcbiAgICBsZXQgbGFzdFBvaW50WSA9IGxhc3RZO1xuICAgIGNvbnN0IGx0ckNhbGxiYWNrID0gaXNMVFIgPyBNYXRoLm1heCA6IE1hdGgubWluO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IG91dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKG91dGxpbmVbaV0pKSB7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBvdXRsaW5lW2kgKyA0XSk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBvdXRsaW5lW2kgKyA1XSk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBvdXRsaW5lW2kgKyA0XSk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBvdXRsaW5lW2kgKyA1XSk7XG4gICAgICAgIGlmIChsYXN0UG9pbnRZIDwgb3V0bGluZVtpICsgNV0pIHtcbiAgICAgICAgICBsYXN0UG9pbnRYID0gb3V0bGluZVtpICsgNF07XG4gICAgICAgICAgbGFzdFBvaW50WSA9IG91dGxpbmVbaSArIDVdO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQb2ludFkgPT09IG91dGxpbmVbaSArIDVdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGx0ckNhbGxiYWNrKGxhc3RQb2ludFgsIG91dGxpbmVbaSArIDRdKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmJveCA9IFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCAuLi5vdXRsaW5lLnNsaWNlKGksIGkgKyA2KSk7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBiYm94WzBdKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIGJib3hbMV0pO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgYmJveFsyXSk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBiYm94WzNdKTtcbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCBiYm94WzNdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGJib3hbMl07XG4gICAgICAgICAgbGFzdFBvaW50WSA9IGJib3hbM107XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0gYmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBiYm94WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFggPSBvdXRsaW5lW2kgKyA0XTtcbiAgICAgIGxhc3RZID0gb3V0bGluZVtpICsgNV07XG4gICAgfVxuICAgIGNvbnN0IHggPSBtaW5YIC0gdGhpcy4jaW5uZXJNYXJnaW4sXG4gICAgICB5ID0gbWluWSAtIHRoaXMuI2lubmVyTWFyZ2luLFxuICAgICAgd2lkdGggPSBtYXhYIC0gbWluWCArIDIgKiB0aGlzLiNpbm5lck1hcmdpbixcbiAgICAgIGhlaWdodCA9IG1heFkgLSBtaW5ZICsgMiAqIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIHRoaXMuI2Jib3ggPSB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgbGFzdFBvaW50OiBbbGFzdFBvaW50WCwgbGFzdFBvaW50WV1cbiAgICB9O1xuICB9XG4gIGdldCBib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3g7XG4gIH1cbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZURyYXdPdXRsaW5lcihwb2ludCwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4pO1xuICB9XG4gIGdldE5ld091dGxpbmUodGhpY2tuZXNzLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBzeCA9IHdpZHRoICogbGF5ZXJXaWR0aDtcbiAgICBjb25zdCBzeSA9IGhlaWdodCAqIGxheWVySGVpZ2h0O1xuICAgIGNvbnN0IHR4ID0geCAqIGxheWVyV2lkdGggKyBsYXllclg7XG4gICAgY29uc3QgdHkgPSB5ICogbGF5ZXJIZWlnaHQgKyBsYXllclk7XG4gICAgY29uc3Qgb3V0bGluZXIgPSB0aGlzLm5ld091dGxpbmVyKHtcbiAgICAgIHg6IHRoaXMuI3BvaW50c1swXSAqIHN4ICsgdHgsXG4gICAgICB5OiB0aGlzLiNwb2ludHNbMV0gKiBzeSArIHR5XG4gICAgfSwgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCB0aGlzLiNpc0xUUiwgaW5uZXJNYXJnaW4gPz8gdGhpcy4jaW5uZXJNYXJnaW4pO1xuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgdGhpcy4jcG9pbnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBvdXRsaW5lci5hZGQoe1xuICAgICAgICB4OiB0aGlzLiNwb2ludHNbaV0gKiBzeCArIHR4LFxuICAgICAgICB5OiB0aGlzLiNwb2ludHNbaSArIDFdICogc3kgKyB0eVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRsaW5lci5nZXRPdXRsaW5lcygpO1xuICB9XG4gIGdldCBtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaGlnaGxpZ2h0LmpzXG5cblxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZXIge1xuICAjYm94O1xuICAjdmVydGljYWxFZGdlcyA9IFtdO1xuICAjaW50ZXJ2YWxzID0gW107XG4gIGNvbnN0cnVjdG9yKGJveGVzLCBib3JkZXJXaWR0aCA9IDAsIGlubmVyTWFyZ2luID0gMCwgaXNMVFIgPSB0cnVlKSB7XG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgIGNvbnN0IE5VTUJFUl9PRl9ESUdJVFMgPSA0O1xuICAgIGNvbnN0IEVQU0lMT04gPSAxMCAqKiAtTlVNQkVSX09GX0RJR0lUUztcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB4MSA9IE1hdGguZmxvb3IoKHggLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgoeCArIHdpZHRoICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTEgPSBNYXRoLmZsb29yKCh5IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLmNlaWwoKHkgKyBoZWlnaHQgKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCBsZWZ0ID0gW3gxLCB5MSwgeTIsIHRydWVdO1xuICAgICAgY29uc3QgcmlnaHQgPSBbeDIsIHkxLCB5MiwgZmFsc2VdO1xuICAgICAgdGhpcy4jdmVydGljYWxFZGdlcy5wdXNoKGxlZnQsIHJpZ2h0KTtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4MSk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeDIpO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIHkxKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5Mik7XG4gICAgfVxuICAgIGNvbnN0IGJib3hXaWR0aCA9IG1heFggLSBtaW5YICsgMiAqIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IGJib3hIZWlnaHQgPSBtYXhZIC0gbWluWSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWCA9IG1pblggLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWSA9IG1pblkgLSBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBsYXN0RWRnZSA9IHRoaXMuI3ZlcnRpY2FsRWRnZXMuYXQoaXNMVFIgPyAtMSA6IC0yKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBbbGFzdEVkZ2VbMF0sIGxhc3RFZGdlWzJdXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgICAgZWRnZVswXSA9ICh4IC0gc2hpZnRlZE1pblgpIC8gYmJveFdpZHRoO1xuICAgICAgZWRnZVsxXSA9ICh5MSAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgICBlZGdlWzJdID0gKHkyIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy4jYm94ID0ge1xuICAgICAgeDogc2hpZnRlZE1pblgsXG4gICAgICB5OiBzaGlmdGVkTWluWSxcbiAgICAgIHdpZHRoOiBiYm94V2lkdGgsXG4gICAgICBoZWlnaHQ6IGJib3hIZWlnaHQsXG4gICAgICBsYXN0UG9pbnRcbiAgICB9O1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIHRoaXMuI3ZlcnRpY2FsRWRnZXMuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0gfHwgYVsyXSAtIGJbMl0pO1xuICAgIGNvbnN0IG91dGxpbmVWZXJ0aWNhbEVkZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuI3ZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGlmIChlZGdlWzNdKSB7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgICAgdGhpcy4jaW5zZXJ0KGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcmVtb3ZlKGVkZ2UpO1xuICAgICAgICBvdXRsaW5lVmVydGljYWxFZGdlcy5wdXNoKC4uLnRoaXMuI2JyZWFrRWRnZShlZGdlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNnZXRPdXRsaW5lcyhvdXRsaW5lVmVydGljYWxFZGdlcyk7XG4gIH1cbiAgI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKSB7XG4gICAgY29uc3QgZWRnZXMgPSBbXTtcbiAgICBjb25zdCBhbGxFZGdlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygb3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICAgIGVkZ2VzLnB1c2goW3gsIHkxLCBlZGdlXSwgW3gsIHkyLCBlZGdlXSk7XG4gICAgfVxuICAgIGVkZ2VzLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdIHx8IGFbMF0gLSBiWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlZGdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBlZGdlMSA9IGVkZ2VzW2ldWzJdO1xuICAgICAgY29uc3QgZWRnZTIgPSBlZGdlc1tpICsgMV1bMl07XG4gICAgICBlZGdlMS5wdXNoKGVkZ2UyKTtcbiAgICAgIGVkZ2UyLnB1c2goZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UxKTtcbiAgICAgIGFsbEVkZ2VzLmFkZChlZGdlMik7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgbGV0IG91dGxpbmU7XG4gICAgd2hpbGUgKGFsbEVkZ2VzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBlZGdlID0gYWxsRWRnZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgbGV0IFt4LCB5MSwgeTIsIGVkZ2UxLCBlZGdlMl0gPSBlZGdlO1xuICAgICAgYWxsRWRnZXMuZGVsZXRlKGVkZ2UpO1xuICAgICAgbGV0IGxhc3RQb2ludFggPSB4O1xuICAgICAgbGV0IGxhc3RQb2ludFkgPSB5MTtcbiAgICAgIG91dGxpbmUgPSBbeCwgeTJdO1xuICAgICAgb3V0bGluZXMucHVzaChvdXRsaW5lKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBpZiAoYWxsRWRnZXMuaGFzKGVkZ2UxKSkge1xuICAgICAgICAgIGUgPSBlZGdlMTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxFZGdlcy5oYXMoZWRnZTIpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFsbEVkZ2VzLmRlbGV0ZShlKTtcbiAgICAgICAgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGU7XG4gICAgICAgIGlmIChsYXN0UG9pbnRYICE9PSB4KSB7XG4gICAgICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFksIHgsIGxhc3RQb2ludFkgPT09IHkxID8geTEgOiB5Mik7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50WSA9IGxhc3RQb2ludFkgPT09IHkxID8geTIgOiB5MTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmUucHVzaChsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIaWdobGlnaHRPdXRsaW5lKG91dGxpbmVzLCB0aGlzLiNib3gpO1xuICB9XG4gICNiaW5hcnlTZWFyY2goeSkge1xuICAgIGNvbnN0IGFycmF5ID0gdGhpcy4jaW50ZXJ2YWxzO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgY29uc3QgbWlkZGxlID0gc3RhcnQgKyBlbmQgPj4gMTtcbiAgICAgIGNvbnN0IHkxID0gYXJyYXlbbWlkZGxlXVswXTtcbiAgICAgIGlmICh5MSA9PT0geSkge1xuICAgICAgICByZXR1cm4gbWlkZGxlO1xuICAgICAgfVxuICAgICAgaWYgKHkxIDwgeSkge1xuICAgICAgICBzdGFydCA9IG1pZGRsZSArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSBtaWRkbGUgLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kICsgMTtcbiAgfVxuICAjaW5zZXJ0KFssIHkxLCB5Ml0pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5MSk7XG4gICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpbmRleCwgMCwgW3kxLCB5Ml0pO1xuICB9XG4gICNyZW1vdmUoWywgeTEsIHkyXSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkxKTtcbiAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLiNpbnRlcnZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGlmIChzdGFydCAhPT0geTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgPT09IHkxICYmIGVuZCA9PT0geTIpIHtcbiAgICAgICAgdGhpcy4jaW50ZXJ2YWxzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgaWYgKHN0YXJ0ICE9PSB5MSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0geTEgJiYgZW5kID09PSB5Mikge1xuICAgICAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNicmVha0VkZ2UoZWRnZSkge1xuICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICBjb25zdCByZXN1bHRzID0gW1t4LCB5MSwgeTJdXTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuI2JpbmFyeVNlYXJjaCh5Mik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBmb3IgKGxldCBqID0gMCwgamogPSByZXN1bHRzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgY29uc3QgWywgeTMsIHk0XSA9IHJlc3VsdHNbal07XG4gICAgICAgIGlmIChlbmQgPD0geTMgfHwgeTQgPD0gc3RhcnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeTMgPj0gc3RhcnQpIHtcbiAgICAgICAgICBpZiAoeTQgPiBlbmQpIHtcbiAgICAgICAgICAgIHJlc3VsdHNbal1bMV0gPSBlbmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChqaiA9PT0gMSkge1xuICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIGpqLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHNbal1bMl0gPSBzdGFydDtcbiAgICAgICAgaWYgKHk0ID4gZW5kKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKFt4LCBlbmQsIHk0XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodE91dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2JveDtcbiAgI291dGxpbmVzO1xuICBjb25zdHJ1Y3RvcihvdXRsaW5lcywgYm94KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNvdXRsaW5lcyA9IG91dGxpbmVzO1xuICAgIHRoaXMuI2JveCA9IGJveDtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBsZXQgW3ByZXZYLCBwcmV2WV0gPSBwb2x5Z29uO1xuICAgICAgYnVmZmVyLnB1c2goYE0ke3ByZXZYfSAke3ByZXZZfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2x5Z29uW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9seWdvbltpICsgMV07XG4gICAgICAgIGlmICh4ID09PSBwcmV2WCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBWJHt5fWApO1xuICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID09PSBwcmV2WSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBIJHt4fWApO1xuICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgX3JvdGF0aW9uKSB7XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IGJsWCArIG91dGxpbmVbaV0gKiB3aWR0aDtcbiAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIG91dGxpbmVbaSArIDFdICogaGVpZ2h0O1xuICAgICAgfVxuICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYm94O1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yRHJhd2luZygpIHtcbiAgICByZXR1cm4gW1wiaGlnaGxpZ2h0XCJdO1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRPdXRsaW5lXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbiAgZ2V0IGNsYXNzTmFtZXNGb3JEcmF3aW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRcIiwgXCJmcmVlXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZSBleHRlbmRzIEZyZWVEcmF3T3V0bGluZSB7XG4gIGdldCBjbGFzc05hbWVzRm9yRHJhd2luZygpIHtcbiAgICByZXR1cm4gW1wiaGlnaGxpZ2h0XCIsIFwiZnJlZVwiXTtcbiAgfVxuICBnZXQgY2xhc3NOYW1lc0Zvck91dGxpbmluZygpIHtcbiAgICByZXR1cm4gW1wiaGlnaGxpZ2h0T3V0bGluZVwiLCBcImZyZWVcIl07XG4gIH1cbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbG9yX3BpY2tlci5qc1xuXG5cblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICAjYnV0dG9uID0gbnVsbDtcbiAgI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICNkZWZhdWx0Q29sb3I7XG4gICNkcm9wZG93biA9IG51bGw7XG4gICNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGZhbHNlO1xuICAjaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNldmVudEJ1cztcbiAgI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gICN0eXBlO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2tleWJvYXJkTWFuYWdlcigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmRdLCBbW1wiIFwiLCBcIm1hYysgXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkXSwgW1tcIkFycm93RG93blwiLCBcIkFycm93UmlnaHRcIiwgXCJtYWMrQXJyb3dEb3duXCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvTmV4dF0sIFtbXCJBcnJvd1VwXCIsIFwiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93VXBcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb1ByZXZpb3VzXSwgW1tcIkhvbWVcIiwgXCJtYWMrSG9tZVwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9CZWdpbm5pbmddLCBbW1wiRW5kXCIsIFwibWFjK0VuZFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9FbmRdXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBlZGl0b3IgPSBudWxsLFxuICAgIHVpTWFuYWdlciA9IG51bGxcbiAgfSkge1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyID0gZmFsc2U7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SO1xuICAgICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNpc01haW5Db2xvclBpY2tlciA9IHRydWU7XG4gICAgICB0aGlzLiN0eXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0RFRkFVTFRfQ09MT1I7XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlciA9IGVkaXRvcj8uX3VpTWFuYWdlciB8fCB1aU1hbmFnZXI7XG4gICAgdGhpcy4jZXZlbnRCdXMgPSB0aGlzLiN1aU1hbmFnZXIuX2V2ZW50QnVzO1xuICAgIHRoaXMuI2RlZmF1bHRDb2xvciA9IGVkaXRvcj8uY29sb3IgfHwgdGhpcy4jdWlNYW5hZ2VyPy5oaWdobGlnaHRDb2xvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI0ZGRkY5OFwiO1xuICAgIENvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgYmx1ZTogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYmx1ZVwiLFxuICAgICAgZ3JlZW46IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWdyZWVuXCIsXG4gICAgICBwaW5rOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1waW5rXCIsXG4gICAgICByZWQ6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLXJlZFwiLFxuICAgICAgeWVsbG93OiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci15ZWxsb3dcIlxuICAgIH0pO1xuICB9XG4gIHJlbmRlckJ1dHRvbigpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImNvbG9yUGlja2VyXCI7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1idXR0b25cIik7XG4gICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgdHJ1ZSk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNvcGVuRHJvcGRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgc3dhdGNoID0gdGhpcy4jYnV0dG9uU3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgc3dhdGNoLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLiNkZWZhdWx0Q29sb3I7XG4gICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgIHJldHVybiBidXR0b247XG4gIH1cbiAgcmVuZGVyTWFpbkRyb3Bkb3duKCkge1xuICAgIGNvbnN0IGRyb3Bkb3duID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLW9yaWVudGF0aW9uXCIsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICBkcm9wZG93bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgXCJoaWdobGlnaHRDb2xvclBpY2tlckxhYmVsXCIpO1xuICAgIHJldHVybiBkcm9wZG93bjtcbiAgfVxuICAjZ2V0RHJvcGRvd25Sb290KCkge1xuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJkcm9wZG93blwiO1xuICAgIGRpdi5yb2xlID0gXCJsaXN0Ym94XCI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCIsIGZhbHNlKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1vcmllbnRhdGlvblwiLCBcInZlcnRpY2FsXCIpO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY29sb3JdIG9mIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBidXR0b24udGFiSW5kZXggPSBcIjBcIjtcbiAgICAgIGJ1dHRvbi5yb2xlID0gXCJvcHRpb25cIjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgIGJ1dHRvbi50aXRsZSA9IG5hbWU7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIENvbG9yUGlja2VyLiNsMTBuQ29sb3JbbmFtZV0pO1xuICAgICAgY29uc3Qgc3dhdGNoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgICBzd2F0Y2guY2xhc3NOYW1lID0gXCJzd2F0Y2hcIjtcbiAgICAgIHN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIGNvbG9yID09PSB0aGlzLiNkZWZhdWx0Q29sb3IpO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNjb2xvclNlbGVjdC5iaW5kKHRoaXMsIGNvbG9yKSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LmFwcGVuZChidXR0b24pO1xuICAgIH1cbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5RG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4gZGl2O1xuICB9XG4gICNjb2xvclNlbGVjdChjb2xvciwgZXZlbnQpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLiNldmVudEJ1cy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3JwYXJhbXNcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgdHlwZTogdGhpcy4jdHlwZSxcbiAgICAgIHZhbHVlOiBjb2xvclxuICAgIH0pO1xuICB9XG4gIF9jb2xvclNlbGVjdEZyb21LZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCk7XG4gIH1cbiAgX21vdmVUb05leHQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0Q2hpbGQ/LmZvY3VzKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZz8uZm9jdXMoKTtcbiAgfVxuICBfbW92ZVRvUHJldmlvdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNkcm9wZG93bj8uZmlyc3RDaGlsZCB8fCBldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQucHJldmlvdXNTaWJsaW5nPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9CZWdpbm5pbmcoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5maXJzdENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5sYXN0Q2hpbGQ/LmZvY3VzKCk7XG4gIH1cbiAgI2tleURvd24oZXZlbnQpIHtcbiAgICBDb2xvclBpY2tlci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNvcGVuRHJvcGRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuaGlkZURyb3Bkb3duKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Ryb3Bkb3duV2FzRnJvbUtleWJvYXJkID0gZXZlbnQuZGV0YWlsID09PSAwO1xuICAgIGlmICghdGhpcy4jb3BlbkRyb3Bkb3duQUMpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNwb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI29wZW5Ecm9wZG93bkFDKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNkcm9wZG93bikge1xuICAgICAgdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2Ryb3Bkb3duID0gdGhpcy4jZ2V0RHJvcGRvd25Sb290KCk7XG4gICAgdGhpcy4jYnV0dG9uLmFwcGVuZChyb290KTtcbiAgfVxuICAjcG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jZHJvcGRvd24/LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBoaWRlRHJvcGRvd24oKSB7XG4gICAgdGhpcy4jZHJvcGRvd24/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jb3BlbkRyb3Bkb3duQUMgPSBudWxsO1xuICB9XG4gIGdldCAjaXNEcm9wZG93blZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Ryb3Bkb3duICYmICF0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoXCJoaWRkZW5cIik7XG4gIH1cbiAgX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZCgpIHtcbiAgICBpZiAodGhpcy4jaXNNYWluQ29sb3JQaWNrZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNpc0Ryb3Bkb3duVmlzaWJsZSkge1xuICAgICAgdGhpcy4jZWRpdG9yPy51bnNlbGVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgIHRoaXMuI2J1dHRvbi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlLFxuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZFxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgaWYgKHRoaXMuI2J1dHRvblN3YXRjaCkge1xuICAgICAgdGhpcy4jYnV0dG9uU3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy4jZHJvcGRvd24uY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShcImFyaWEtc2VsZWN0ZWRcIiwgaS5uZXh0KCkudmFsdWUgPT09IGNvbG9yKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9oaWdobGlnaHQuanNcblxuXG5cblxuXG5cblxuY2xhc3MgSGlnaGxpZ2h0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhbmNob3JOb2RlID0gbnVsbDtcbiAgI2FuY2hvck9mZnNldCA9IDA7XG4gICNib3hlcztcbiAgI2NsaXBQYXRoSWQgPSBudWxsO1xuICAjY29sb3JQaWNrZXIgPSBudWxsO1xuICAjZm9jdXNPdXRsaW5lcyA9IG51bGw7XG4gICNmb2N1c05vZGUgPSBudWxsO1xuICAjZm9jdXNPZmZzZXQgPSAwO1xuICAjaGlnaGxpZ2h0RGl2ID0gbnVsbDtcbiAgI2hpZ2hsaWdodE91dGxpbmVzID0gbnVsbDtcbiAgI2lkID0gbnVsbDtcbiAgI2lzRnJlZUhpZ2hsaWdodCA9IGZhbHNlO1xuICAjbGFzdFBvaW50ID0gbnVsbDtcbiAgI29wYWNpdHk7XG4gICNvdXRsaW5lSWQgPSBudWxsO1xuICAjdGV4dCA9IFwiXCI7XG4gICN0aGlja25lc3M7XG4gICNtZXRob2RPZkNyZWF0aW9uID0gXCJcIjtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTI7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gSGlnaGxpZ2h0RWRpdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsxXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMl1cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFszXVxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgIHRoaXMuI29wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRPcGFjaXR5O1xuICAgIHRoaXMuI2JveGVzID0gcGFyYW1zLmJveGVzIHx8IG51bGw7XG4gICAgdGhpcy4jbWV0aG9kT2ZDcmVhdGlvbiA9IHBhcmFtcy5tZXRob2RPZkNyZWF0aW9uIHx8IFwiXCI7XG4gICAgdGhpcy4jdGV4dCA9IHBhcmFtcy50ZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBpZiAocGFyYW1zLmhpZ2hsaWdodElkID4gLTEpIHtcbiAgICAgIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNib3hlcykge1xuICAgICAgdGhpcy4jYW5jaG9yTm9kZSA9IHBhcmFtcy5hbmNob3JOb2RlO1xuICAgICAgdGhpcy4jYW5jaG9yT2Zmc2V0ID0gcGFyYW1zLmFuY2hvck9mZnNldDtcbiAgICAgIHRoaXMuI2ZvY3VzTm9kZSA9IHBhcmFtcy5mb2N1c05vZGU7XG4gICAgICB0aGlzLiNmb2N1c09mZnNldCA9IHBhcmFtcy5mb2N1c09mZnNldDtcbiAgICAgIHRoaXMuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgfVxuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCIsXG4gICAgICB0eXBlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHQgPyBcImZyZWVfaGlnaGxpZ2h0XCIgOiBcImhpZ2hsaWdodFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvck5hbWVzLmdldCh0aGlzLmNvbG9yKSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogdGhpcy4jbWV0aG9kT2ZDcmVhdGlvblxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQodGhpcy5jb2xvcilcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbnVtYmVyT2ZDb2xvcnM6IGRhdGEuZ2V0KFwiY29sb3JcIikuc2l6ZVxuICAgIH07XG4gIH1cbiAgI2NyZWF0ZU91dGxpbmVzKCkge1xuICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEhpZ2hsaWdodE91dGxpbmVyKHRoaXMuI2JveGVzLCAwLjAwMSk7XG4gICAgdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMgPSBvdXRsaW5lci5nZXRPdXRsaW5lcygpO1xuICAgICh7XG4gICAgICB4OiB0aGlzLngsXG4gICAgICB5OiB0aGlzLnksXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9ID0gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94KTtcbiAgICBjb25zdCBvdXRsaW5lckZvck91dGxpbmUgPSBuZXcgSGlnaGxpZ2h0T3V0bGluZXIodGhpcy4jYm94ZXMsIDAuMDAyNSwgMC4wMDEsIHRoaXMuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBvdXRsaW5lckZvck91dGxpbmUuZ2V0T3V0bGluZXMoKTtcbiAgICBjb25zdCB7XG4gICAgICBsYXN0UG9pbnRcbiAgICB9ID0gdGhpcy4jZm9jdXNPdXRsaW5lcy5ib3g7XG4gICAgdGhpcy4jbGFzdFBvaW50ID0gWyhsYXN0UG9pbnRbMF0gLSB0aGlzLngpIC8gdGhpcy53aWR0aCwgKGxhc3RQb2ludFsxXSAtIHRoaXMueSkgLyB0aGlzLmhlaWdodF07XG4gIH1cbiAgI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgaGlnaGxpZ2h0T3V0bGluZXMsXG4gICAgaGlnaGxpZ2h0SWQsXG4gICAgY2xpcFBhdGhJZFxuICB9KSB7XG4gICAgdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMgPSBoaWdobGlnaHRPdXRsaW5lcztcbiAgICBjb25zdCBleHRyYVRoaWNrbmVzcyA9IDEuNTtcbiAgICB0aGlzLiNmb2N1c091dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlzLiN0aGlja25lc3MgLyAyICsgZXh0cmFUaGlja25lc3MsIDAuMDAyNSk7XG4gICAgaWYgKGhpZ2hsaWdodElkID49IDApIHtcbiAgICAgIHRoaXMuI2lkID0gaGlnaGxpZ2h0SWQ7XG4gICAgICB0aGlzLiNjbGlwUGF0aElkID0gY2xpcFBhdGhJZDtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5maW5hbGl6ZUxpbmUoaGlnaGxpZ2h0SWQsIGhpZ2hsaWdodE91dGxpbmVzKTtcbiAgICAgIHRoaXMuI291dGxpbmVJZCA9IHRoaXMucGFyZW50LmRyYXdMYXllci5kcmF3T3V0bGluZSh0aGlzLiNmb2N1c091dGxpbmVzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25zdCBhbmdsZSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZUxpbmUodGhpcy4jaWQsIGhpZ2hsaWdodE91dGxpbmVzKTtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVCb3godGhpcy4jaWQsIEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsIChhbmdsZSAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwKSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlTGluZSh0aGlzLiNvdXRsaW5lSWQsIHRoaXMuI2ZvY3VzT3V0bGluZXMpO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZUJveCh0aGlzLiNvdXRsaW5lSWQsIEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveCh0aGlzLiNmb2N1c091dGxpbmVzLmJveCwgYW5nbGUpKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMueCA9IHk7XG4gICAgICAgICAgdGhpcy55ID0gMSAtIHg7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcGFnZUhlaWdodCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggPSAxIC0geDtcbiAgICAgICAgdGhpcy55ID0gMSAtIHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSAxIC0geTtcbiAgICAgICAgICB0aGlzLnkgPSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzLmJveDtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbKGxhc3RQb2ludFswXSAtIHgpIC8gd2lkdGgsIChsYXN0UG9pbnRbMV0gLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHw9IHVpTWFuYWdlci5oaWdobGlnaHRDb2xvcnM/LnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNmZmYwNjZcIjtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfREVGQVVMVF9DT0xPUjpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHt9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RQb2ludDtcbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUiwgdGhpcy5jb2xvciB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCB0aGlzLiN0aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9GUkVFLCB0aGlzLiNpc0ZyZWVIaWdobGlnaHRdXTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzZXRDb2xvckFuZE9wYWNpdHkgPSAoY29sLCBvcGEpID0+IHtcbiAgICAgIHRoaXMuY29sb3IgPSBjb2w7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLmNoYW5nZUNvbG9yKHRoaXMuI2lkLCBjb2wpO1xuICAgICAgdGhpcy4jY29sb3JQaWNrZXI/LnVwZGF0ZUNvbG9yKGNvbCk7XG4gICAgICB0aGlzLiNvcGFjaXR5ID0gb3BhO1xuICAgICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci5jaGFuZ2VPcGFjaXR5KHRoaXMuI2lkLCBvcGEpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29uc3Qgc2F2ZWRPcGFjaXR5ID0gdGhpcy4jb3BhY2l0eTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgY29sb3IsIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdE9wYWNpdHkpLFxuICAgICAgdW5kbzogc2V0Q29sb3JBbmRPcGFjaXR5LmJpbmQodGhpcywgc2F2ZWRDb2xvciwgc2F2ZWRPcGFjaXR5KSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiY29sb3JfY2hhbmdlZFwiLFxuICAgICAgY29sb3I6IHRoaXMuX3VpTWFuYWdlci5oaWdobGlnaHRDb2xvck5hbWVzLmdldChjb2xvcilcbiAgICB9LCB0cnVlKTtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IHNhdmVkVGhpY2tuZXNzID0gdGhpcy4jdGhpY2tuZXNzO1xuICAgIGNvbnN0IHNldFRoaWNrbmVzcyA9IHRoID0+IHtcbiAgICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoO1xuICAgICAgdGhpcy4jY2hhbmdlVGhpY2tuZXNzKHRoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCB0aGlja25lc3MpLFxuICAgICAgdW5kbzogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgc2F2ZWRUaGlja25lc3MpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwidGhpY2tuZXNzX2NoYW5nZWRcIixcbiAgICAgIHRoaWNrbmVzc1xuICAgIH0sIHRydWUpO1xuICB9XG4gIGFzeW5jIGFkZEVkaXRUb29sYmFyKCkge1xuICAgIGNvbnN0IHRvb2xiYXIgPSBhd2FpdCBzdXBlci5hZGRFZGl0VG9vbGJhcigpO1xuICAgIGlmICghdG9vbGJhcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICB0aGlzLiNjb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcih7XG4gICAgICAgIGVkaXRvcjogdGhpc1xuICAgICAgfSk7XG4gICAgICB0b29sYmFyLmFkZENvbG9yUGlja2VyKHRoaXMuI2NvbG9yUGlja2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2xiYXI7XG4gIH1cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgdHJ1ZSk7XG4gIH1cbiAgZW5hYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIGZhbHNlKTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gc3VwZXIuZml4QW5kU2V0UG9zaXRpb24odGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0UmVjdCh0eCwgdHkpIHtcbiAgICByZXR1cm4gc3VwZXIuZ2V0UmVjdCh0eCwgdHksIHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIG9uY2VBZGRlZCgpIHtcbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI2NsZWFuRHJhd0xheWVyKCk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJkZWxldGVkXCJcbiAgICB9KTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGxldCBtdXN0QmVTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAhcGFyZW50KSB7XG4gICAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50KSB7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICB0aGlzLnNob3codGhpcy5faXNWaXNpYmxlKTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjaGFuZ2VUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgIGhpZ2hsaWdodE91dGxpbmVzOiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5nZXROZXdPdXRsaW5lKHRoaWNrbmVzcyAvIDIpXG4gICAgfSk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gIH1cbiAgI2NsZWFuRHJhd0xheWVyKCkge1xuICAgIGlmICh0aGlzLiNpZCA9PT0gbnVsbCB8fCAhdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLiNpZCk7XG4gICAgdGhpcy4jaWQgPSBudWxsO1xuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy4jb3V0bGluZUlkKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBudWxsO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLiNpZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoe1xuICAgICAgaWQ6IHRoaXMuI2lkLFxuICAgICAgY2xpcFBhdGhJZDogdGhpcy4jY2xpcFBhdGhJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcodGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMsIHRoaXMuY29sb3IsIHRoaXMuI29wYWNpdHkpKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBwYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHRoaXMuI2ZvY3VzT3V0bGluZXMpO1xuICAgIGlmICh0aGlzLiNoaWdobGlnaHREaXYpIHtcbiAgICAgIHRoaXMuI2hpZ2hsaWdodERpdi5zdHlsZS5jbGlwUGF0aCA9IHRoaXMuI2NsaXBQYXRoSWQ7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjcm90YXRlQmJveCh7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9LCBhbmdsZSkge1xuICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogMSAtIHkgLSBoZWlnaHQsXG4gICAgICAgICAgeTogeCxcbiAgICAgICAgICB3aWR0aDogaGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogd2lkdGhcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IDEgLSB4IC0gd2lkdGgsXG4gICAgICAgICAgeTogMSAtIHkgLSBoZWlnaHQsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB5LFxuICAgICAgICAgIHk6IDEgLSB4IC0gd2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGhlaWdodCxcbiAgICAgICAgICBoZWlnaHQ6IHdpZHRoXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfTtcbiAgfVxuICByb3RhdGUoYW5nbGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkcmF3TGF5ZXJcbiAgICB9ID0gdGhpcy5wYXJlbnQ7XG4gICAgbGV0IGJveDtcbiAgICBpZiAodGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICBhbmdsZSA9IChhbmdsZSAtIHRoaXMucm90YXRpb24gKyAzNjApICUgMzYwO1xuICAgICAgYm94ID0gSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCwgYW5nbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3ggPSBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcywgYW5nbGUpO1xuICAgIH1cbiAgICBkcmF3TGF5ZXIucm90YXRlKHRoaXMuI2lkLCBhbmdsZSk7XG4gICAgZHJhd0xheWVyLnJvdGF0ZSh0aGlzLiNvdXRsaW5lSWQsIGFuZ2xlKTtcbiAgICBkcmF3TGF5ZXIudXBkYXRlQm94KHRoaXMuI2lkLCBib3gpO1xuICAgIGRyYXdMYXllci51cGRhdGVCb3godGhpcy4jb3V0bGluZUlkLCBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jZm9jdXNPdXRsaW5lcy5ib3gsIGFuZ2xlKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy4jdGV4dCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jdGV4dCk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm1hcmtcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoaWdobGlnaHREaXYgPSB0aGlzLiNoaWdobGlnaHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoaGlnaGxpZ2h0RGl2KTtcbiAgICBoaWdobGlnaHREaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGhpZ2hsaWdodERpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIGJpbmRFdmVudHModGhpcywgdGhpcy4jaGlnaGxpZ2h0RGl2LCBbXCJwb2ludGVyb3ZlclwiLCBcInBvaW50ZXJsZWF2ZVwiXSk7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICBwb2ludGVyb3ZlcigpIHtcbiAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmFkZENsYXNzKHRoaXMuI291dGxpbmVJZCwgXCJob3ZlcmVkXCIpO1xuICAgIH1cbiAgfVxuICBwb2ludGVybGVhdmUoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5yZW1vdmVDbGFzcyh0aGlzLiNvdXRsaW5lSWQsIFwiaG92ZXJlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2tleWRvd24oZXZlbnQpIHtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBfbW92ZUNhcmV0KGRpcmVjdGlvbikge1xuICAgIHRoaXMucGFyZW50LnVuc2VsZWN0KHRoaXMpO1xuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuI3NldENhcmV0KHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgdGhpcy4jc2V0Q2FyZXQoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgI3NldENhcmV0KHN0YXJ0KSB7XG4gICAgaWYgKCF0aGlzLiNhbmNob3JOb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLiNhbmNob3JOb2RlLCB0aGlzLiNhbmNob3JPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3Rpb24uc2V0UG9zaXRpb24odGhpcy4jZm9jdXNOb2RlLCB0aGlzLiNmb2N1c09mZnNldCk7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICBzdXBlci5zZWxlY3QoKTtcbiAgICBpZiAoIXRoaXMuI291dGxpbmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnJlbW92ZUNsYXNzKHRoaXMuI291dGxpbmVJZCwgXCJob3ZlcmVkXCIpO1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIuYWRkQ2xhc3ModGhpcy4jb3V0bGluZUlkLCBcInNlbGVjdGVkXCIpO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHN1cGVyLnVuc2VsZWN0KCk7XG4gICAgaWYgKCF0aGlzLiNvdXRsaW5lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci5yZW1vdmVDbGFzcyh0aGlzLiNvdXRsaW5lSWQsIFwic2VsZWN0ZWRcIik7XG4gICAgaWYgKCF0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHRoaXMuI3NldENhcmV0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgZ2V0IF9tdXN0Rml4UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLiNpc0ZyZWVIaWdobGlnaHQ7XG4gIH1cbiAgc2hvdyh2aXNpYmxlID0gdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgc3VwZXIuc2hvdyh2aXNpYmxlKTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5zaG93KHRoaXMuI2lkLCB2aXNpYmxlKTtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci5zaG93KHRoaXMuI291dGxpbmVJZCwgdmlzaWJsZSk7XG4gICAgfVxuICB9XG4gICNnZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNGcmVlSGlnaGxpZ2h0ID8gdGhpcy5yb3RhdGlvbiA6IDA7XG4gIH1cbiAgI3NlcmlhbGl6ZUJveGVzKCkge1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuI2JveGVzO1xuICAgIGNvbnN0IHF1YWRQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGJveGVzLmxlbmd0aCAqIDgpO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCBzeCA9IHggKiBwYWdlV2lkdGggKyBwYWdlWDtcbiAgICAgIGNvbnN0IHN5ID0gKDEgLSB5IC0gaGVpZ2h0KSAqIHBhZ2VIZWlnaHQgKyBwYWdlWTtcbiAgICAgIHF1YWRQb2ludHNbaV0gPSBxdWFkUG9pbnRzW2kgKyA0XSA9IHN4O1xuICAgICAgcXVhZFBvaW50c1tpICsgMV0gPSBxdWFkUG9pbnRzW2kgKyAzXSA9IHN5O1xuICAgICAgcXVhZFBvaW50c1tpICsgMl0gPSBxdWFkUG9pbnRzW2kgKyA2XSA9IHN4ICsgd2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBxdWFkUG9pbnRzW2kgKyA1XSA9IHF1YWRQb2ludHNbaSArIDddID0gc3kgKyBoZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgICAgaSArPSA4O1xuICAgIH1cbiAgICByZXR1cm4gcXVhZFBvaW50cztcbiAgfVxuICAjc2VyaWFsaXplT3V0bGluZXMocmVjdCkge1xuICAgIHJldHVybiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5zZXJpYWxpemUocmVjdCwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgc3RhdGljIHN0YXJ0SGlnaGxpZ2h0aW5nKHBhcmVudCwgaXNMVFIsIHtcbiAgICB0YXJnZXQ6IHRleHRMYXllcixcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IGxheWVyWCxcbiAgICAgIHk6IGxheWVyWSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHRleHRMYXllci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSBwYXJlbnQuY29tYmluZWRTaWduYWwoYWMpO1xuICAgIGNvbnN0IHBvaW50ZXJEb3duID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH07XG4gICAgY29uc3QgcG9pbnRlclVwQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLiNlbmRIaWdobGlnaHQocGFyZW50LCBlKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgcG9pbnRlckRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGV4dExheWVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNoaWdobGlnaHRNb3ZlLmJpbmQodGhpcywgcGFyZW50KSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIoe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9LCBbbGF5ZXJYLCBsYXllclksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdLCBwYXJlbnQuc2NhbGUsIHRoaXMuX2RlZmF1bHRUaGlja25lc3MgLyAyLCBpc0xUUiwgMC4wMDEpO1xuICAgICh7XG4gICAgICBpZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgY2xpcFBhdGhJZDogdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcodGhpcy5fZnJlZUhpZ2hsaWdodCwgdGhpcy5fZGVmYXVsdENvbG9yLCB0aGlzLl9kZWZhdWx0T3BhY2l0eSwgdHJ1ZSkpO1xuICB9XG4gIHN0YXRpYyAjaGlnaGxpZ2h0TW92ZShwYXJlbnQsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2ZyZWVIaWdobGlnaHQuYWRkKGV2ZW50KSkge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQYXRoKHRoaXMuX2ZyZWVIaWdobGlnaHRJZCwgdGhpcy5fZnJlZUhpZ2hsaWdodCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjZW5kSGlnaGxpZ2h0KHBhcmVudCwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZyZWVIaWdobGlnaHQuaXNFbXB0eSgpKSB7XG4gICAgICBwYXJlbnQuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSwge1xuICAgICAgICBoaWdobGlnaHRJZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy5fZnJlZUhpZ2hsaWdodC5nZXRPdXRsaW5lcygpLFxuICAgICAgICBjbGlwUGF0aElkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0Q2xpcElkLFxuICAgICAgICBtZXRob2RPZkNyZWF0aW9uOiBcIm1haW5fdG9vbGJhclwiXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fZnJlZUhpZ2hsaWdodElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodElkID0gLTE7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG51bGw7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCA9IFwiXCI7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oY29sb3IpLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBxdWFkUG9pbnRzLFxuICAgICAgICBib3hlczogbnVsbCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgYm9yZGVyU3R5bGU6IHtcbiAgICAgICAgICAgIHJhd1dpZHRoOiB0aGlja25lc3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBvcHVwUmVmXG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShjb2xvciksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJveGVzOiBudWxsLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICBxdWFkUG9pbnRzLFxuICAgICAgaW5rTGlzdHMsXG4gICAgICBvcGFjaXR5XG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGVkaXRvci5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKTtcbiAgICBlZGl0b3IuI29wYWNpdHkgPSBvcGFjaXR5IHx8IDE7XG4gICAgaWYgKGlua0xpc3RzKSB7XG4gICAgICBlZGl0b3IuI3RoaWNrbmVzcyA9IGRhdGEudGhpY2tuZXNzO1xuICAgIH1cbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSBlZGl0b3IucGFnZVRyYW5zbGF0aW9uO1xuICAgIGlmIChxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCBib3hlcyA9IGVkaXRvci4jYm94ZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBib3hlcy5wdXNoKHtcbiAgICAgICAgICB4OiAocXVhZFBvaW50c1tpXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICB5OiAxIC0gKHF1YWRQb2ludHNbaSArIDFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodCxcbiAgICAgICAgICB3aWR0aDogKHF1YWRQb2ludHNbaSArIDJdIC0gcXVhZFBvaW50c1tpXSkgLyBwYWdlV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiAocXVhZFBvaW50c1tpICsgMV0gLSBxdWFkUG9pbnRzW2kgKyA1XSkgLyBwYWdlSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWRpdG9yLiNjcmVhdGVPdXRsaW5lcygpO1xuICAgICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgZWRpdG9yLnJvdGF0ZShlZGl0b3Iucm90YXRpb24pO1xuICAgIH0gZWxzZSBpZiAoaW5rTGlzdHMpIHtcbiAgICAgIGVkaXRvci4jaXNGcmVlSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGlua0xpc3RzWzBdO1xuICAgICAgY29uc3QgcG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50c1swXSAtIHBhZ2VYLFxuICAgICAgICB5OiBwYWdlSGVpZ2h0IC0gKHBvaW50c1sxXSAtIHBhZ2VZKVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG91dGxpbmVyID0gbmV3IEZyZWVIaWdobGlnaHRPdXRsaW5lcihwb2ludCwgWzAsIDAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIDEsIGVkaXRvci4jdGhpY2tuZXNzIC8gMiwgdHJ1ZSwgMC4wMDEpO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgcG9pbnQueCA9IHBvaW50c1tpXSAtIHBhZ2VYO1xuICAgICAgICBwb2ludC55ID0gcGFnZUhlaWdodCAtIChwb2ludHNbaSArIDFdIC0gcGFnZVkpO1xuICAgICAgICBvdXRsaW5lci5hZGQocG9pbnQpO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyhvdXRsaW5lciwgZWRpdG9yLmNvbG9yLCBlZGl0b3IuX2RlZmF1bHRPcGFjaXR5LCB0cnVlKTtcbiAgICAgIGVkaXRvci4jY3JlYXRlRnJlZU91dGxpbmVzKHtcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IG91dGxpbmVyLmdldE91dGxpbmVzKCksXG4gICAgICAgIGhpZ2hsaWdodElkOiBpZCxcbiAgICAgICAgY2xpcFBhdGhJZFxuICAgICAgfSk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpIHx8IGlzRm9yQ29weWluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY29sb3IpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULFxuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5OiB0aGlzLiNvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiN0aGlja25lc3MsXG4gICAgICBxdWFkUG9pbnRzOiB0aGlzLiNzZXJpYWxpemVCb3hlcygpLFxuICAgICAgb3V0bGluZXM6IHRoaXMuI3NlcmlhbGl6ZU91dGxpbmVzKHJlY3QpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy4jZ2V0Um90YXRpb24oKSxcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBjYW5DcmVhdGVOZXdFbXB0eUVkaXRvcigpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2luay5qc1xuXG5cblxuXG5cbmNsYXNzIElua0VkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICAjYmFzZUhlaWdodCA9IDA7XG4gICNiYXNlV2lkdGggPSAwO1xuICAjY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQgPSBudWxsO1xuICAjY3VycmVudFBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgI2Rpc2FibGVFZGl0aW5nID0gZmFsc2U7XG4gICNkcmF3aW5nQUMgPSBudWxsO1xuICAjaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICNpc0NhbnZhc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICNvYnNlcnZlciA9IG51bGw7XG4gICNwb2ludGVyZG93bkFDID0gbnVsbDtcbiAgI3JlYWxXaWR0aCA9IDA7XG4gICNyZWFsSGVpZ2h0ID0gMDtcbiAgI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTtcbiAgc3RhdGljIF90eXBlID0gXCJpbmtcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtcy5jb2xvciB8fCBudWxsO1xuICAgIHRoaXMudGhpY2tuZXNzID0gcGFyYW1zLnRoaWNrbmVzcyB8fCBudWxsO1xuICAgIHRoaXMub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5IHx8IG51bGw7XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIHRoaXMuYmV6aWVyUGF0aDJEID0gW107XG4gICAgdGhpcy5hbGxSYXdQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gMTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKSB7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5pbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcik7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUzpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdENvbG9yID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSA9IHZhbHVlIC8gMTAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZOlxuICAgICAgICB0aGlzLiN1cGRhdGVPcGFjaXR5KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBNYXRoLnJvdW5kKElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgKiAxMDApXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCB0aGlzLnRoaWNrbmVzcyB8fCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCB0aGlzLmNvbG9yIHx8IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIE1hdGgucm91bmQoMTAwICogKHRoaXMub3BhY2l0eSA/PyBJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5KSldXTtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IHNldFRoaWNrbmVzcyA9IHRoID0+IHtcbiAgICAgIHRoaXMudGhpY2tuZXNzID0gdGg7XG4gICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkVGhpY2tuZXNzID0gdGhpcy50aGlja25lc3M7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldFRoaWNrbmVzcy5iaW5kKHRoaXMsIHRoaWNrbmVzcyksXG4gICAgICB1bmRvOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCBzYXZlZFRoaWNrbmVzcyksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSBjb2wgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6IHNldENvbG9yLmJpbmQodGhpcywgY29sb3IpLFxuICAgICAgdW5kbzogc2V0Q29sb3IuYmluZCh0aGlzLCBzYXZlZENvbG9yKSxcbiAgICAgIHBvc3Q6IHRoaXMuX3VpTWFuYWdlci51cGRhdGVVSS5iaW5kKHRoaXMuX3VpTWFuYWdlciwgdGhpcyksXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICBjb25zdCBzZXRPcGFjaXR5ID0gb3AgPT4ge1xuICAgICAgdGhpcy5vcGFjaXR5ID0gb3A7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICB9O1xuICAgIG9wYWNpdHkgLz0gMTAwO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0T3BhY2l0eS5iaW5kKHRoaXMsIG9wYWNpdHkpLFxuICAgICAgdW5kbzogc2V0T3BhY2l0eS5iaW5kKHRoaXMsIHNhdmVkT3BhY2l0eSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIH1cbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgaWYgKHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQpO1xuICAgICAgdGhpcy4jY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNvYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCAmJiBwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgcGFyZW50ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nIHx8IHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLiNhZGRQb2ludGVyZG93bkxpc3RlbmVyKCk7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSB8fCB0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9ICF0aGlzLmlzRW1wdHkoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZWRpdGluZ1wiKTtcbiAgICB0aGlzLiNyZW1vdmVQb2ludGVyZG93bkxpc3RlbmVyKCk7XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gIXRoaXMuaXNFbXB0eSgpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aHMubGVuZ3RoID09PSAwIHx8IHRoaXMucGF0aHMubGVuZ3RoID09PSAxICYmIHRoaXMucGF0aHNbMF0ubGVuZ3RoID09PSAwO1xuICB9XG4gICNnZXRJbml0aWFsQkJveCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRSb3RhdGlvbixcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFt3aWR0aCwgaGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocGFyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMCwgaGVpZ2h0LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbd2lkdGgsIDAsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFswLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI3NldFN0cm9rZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHgsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICB0aGlja25lc3MsXG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHNjYWxlRmFjdG9yXG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaWNrbmVzcyAqIHBhcmVudFNjYWxlIC8gc2NhbGVGYWN0b3I7XG4gICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYCR7Y29sb3J9JHtvcGFjaXR5VG9IZXgob3BhY2l0eSl9YDtcbiAgfVxuICAjc3RhcnREcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsOiB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuI3JlbW92ZVBvaW50ZXJkb3duTGlzdGVuZXIoKTtcbiAgICB0aGlzLiNkcmF3aW5nQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2RyYXdpbmdBQyk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLmNhbnZhc1BvaW50ZXJsZWF2ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgdGhpcy5jYW52YXNQb2ludGVybW92ZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuY2FudmFzUG9pbnRlcnVwLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgICAgdGhpcy50aGlja25lc3MgfHw9IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcztcbiAgICAgIHRoaXMuY29sb3IgfHw9IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgICB0aGlzLm9wYWNpdHkgPz89IElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFBhdGgucHVzaChbeCwgeV0pO1xuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFN0cm9rZSgpO1xuICAgIHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy4jZHJhd1BvaW50cygpO1xuICAgICAgaWYgKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayk7XG4gIH1cbiAgI2RyYXcoeCwgeSkge1xuICAgIGNvbnN0IFtsYXN0WCwgbGFzdFldID0gdGhpcy5jdXJyZW50UGF0aC5hdCgtMSk7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoID4gMSAmJiB4ID09PSBsYXN0WCAmJiB5ID09PSBsYXN0WSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgbGV0IHBhdGgyRCA9IHRoaXMuI2N1cnJlbnRQYXRoMkQ7XG4gICAgY3VycmVudFBhdGgucHVzaChbeCwgeV0pO1xuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IHRydWU7XG4gICAgaWYgKGN1cnJlbnRQYXRoLmxlbmd0aCA8PSAyKSB7XG4gICAgICBwYXRoMkQubW92ZVRvKC4uLmN1cnJlbnRQYXRoWzBdKTtcbiAgICAgIHBhdGgyRC5saW5lVG8oeCwgeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGF0aC5sZW5ndGggPT09IDMpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQgPSBwYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoMkQubW92ZVRvKC4uLmN1cnJlbnRQYXRoWzBdKTtcbiAgICB9XG4gICAgdGhpcy4jbWFrZUJlemllckN1cnZlKHBhdGgyRCwgLi4uY3VycmVudFBhdGguYXQoLTMpLCAuLi5jdXJyZW50UGF0aC5hdCgtMiksIHgsIHkpO1xuICB9XG4gICNlbmRQYXRoKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmN1cnJlbnRQYXRoLmF0KC0xKTtcbiAgICB0aGlzLiNjdXJyZW50UGF0aDJELmxpbmVUbyguLi5sYXN0UG9pbnQpO1xuICB9XG4gICNzdG9wRHJhd2luZyh4LCB5KSB7XG4gICAgdGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCh4LCAwKSwgdGhpcy5jYW52YXMud2lkdGgpO1xuICAgIHkgPSBNYXRoLm1pbihNYXRoLm1heCh5LCAwKSwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLiNkcmF3KHgsIHkpO1xuICAgIHRoaXMuI2VuZFBhdGgoKTtcbiAgICBsZXQgYmV6aWVyO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCAhPT0gMSkge1xuICAgICAgYmV6aWVyID0gdGhpcy4jZ2VuZXJhdGVCZXppZXJQb2ludHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeHkgPSBbeCwgeV07XG4gICAgICBiZXppZXIgPSBbW3h5LCB4eS5zbGljZSgpLCB4eS5zbGljZSgpLCB4eV1dO1xuICAgIH1cbiAgICBjb25zdCBwYXRoMkQgPSB0aGlzLiNjdXJyZW50UGF0aDJEO1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gW107XG4gICAgdGhpcy4jY3VycmVudFBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmFsbFJhd1BhdGhzLnB1c2goY3VycmVudFBhdGgpO1xuICAgICAgdGhpcy5wYXRocy5wdXNoKGJlemllcik7XG4gICAgICB0aGlzLmJlemllclBhdGgyRC5wdXNoKHBhdGgyRCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIucmVidWlsZCh0aGlzKTtcbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFsbFJhd1BhdGhzLnBvcCgpO1xuICAgICAgdGhpcy5wYXRocy5wb3AoKTtcbiAgICAgIHRoaXMuYmV6aWVyUGF0aDJELnBvcCgpO1xuICAgICAgaWYgKHRoaXMucGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI2RyYXdQb2ludHMoKSB7XG4gICAgaWYgKCF0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gTWF0aC5jZWlsKHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgY29uc3QgbGFzdFBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2xpY2UoLTMpO1xuICAgIGNvbnN0IHggPSBsYXN0UG9pbnRzLm1hcCh4eSA9PiB4eVswXSk7XG4gICAgY29uc3QgeSA9IGxhc3RQb2ludHMubWFwKHh5ID0+IHh5WzFdKTtcbiAgICBjb25zdCB4TWluID0gTWF0aC5taW4oLi4ueCkgLSB0aGlja25lc3M7XG4gICAgY29uc3QgeE1heCA9IE1hdGgubWF4KC4uLngpICsgdGhpY2tuZXNzO1xuICAgIGNvbnN0IHlNaW4gPSBNYXRoLm1pbiguLi55KSAtIHRoaWNrbmVzcztcbiAgICBjb25zdCB5TWF4ID0gTWF0aC5tYXgoLi4ueSkgKyB0aGlja25lc3M7XG4gICAgY29uc3Qge1xuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLmJlemllclBhdGgyRCkge1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSh0aGlzLiNjdXJyZW50UGF0aDJEKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gICNtYWtlQmV6aWVyQ3VydmUocGF0aDJELCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY29uc3QgcHJldlggPSAoeDAgKyB4MSkgLyAyO1xuICAgIGNvbnN0IHByZXZZID0gKHkwICsgeTEpIC8gMjtcbiAgICBjb25zdCB4MyA9ICh4MSArIHgyKSAvIDI7XG4gICAgY29uc3QgeTMgPSAoeTEgKyB5MikgLyAyO1xuICAgIHBhdGgyRC5iZXppZXJDdXJ2ZVRvKHByZXZYICsgMiAqICh4MSAtIHByZXZYKSAvIDMsIHByZXZZICsgMiAqICh5MSAtIHByZXZZKSAvIDMsIHgzICsgMiAqICh4MSAtIHgzKSAvIDMsIHkzICsgMiAqICh5MSAtIHkzKSAvIDMsIHgzLCB5Myk7XG4gIH1cbiAgI2dlbmVyYXRlQmV6aWVyUG9pbnRzKCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIGlmIChwYXRoLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gW1twYXRoWzBdLCBwYXRoWzBdLCBwYXRoLmF0KC0xKSwgcGF0aC5hdCgtMSldXTtcbiAgICB9XG4gICAgY29uc3QgYmV6aWVyUG9pbnRzID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IFt4MCwgeTBdID0gcGF0aFswXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgcGF0aC5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgIGNvbnN0IFt4MSwgeTFdID0gcGF0aFtpXTtcbiAgICAgIGNvbnN0IFt4MiwgeTJdID0gcGF0aFtpICsgMV07XG4gICAgICBjb25zdCB4MyA9ICh4MSArIHgyKSAvIDI7XG4gICAgICBjb25zdCB5MyA9ICh5MSArIHkyKSAvIDI7XG4gICAgICBjb25zdCBjb250cm9sMSA9IFt4MCArIDIgKiAoeDEgLSB4MCkgLyAzLCB5MCArIDIgKiAoeTEgLSB5MCkgLyAzXTtcbiAgICAgIGNvbnN0IGNvbnRyb2wyID0gW3gzICsgMiAqICh4MSAtIHgzKSAvIDMsIHkzICsgMiAqICh5MSAtIHkzKSAvIDNdO1xuICAgICAgYmV6aWVyUG9pbnRzLnB1c2goW1t4MCwgeTBdLCBjb250cm9sMSwgY29udHJvbDIsIFt4MywgeTNdXSk7XG4gICAgICBbeDAsIHkwXSA9IFt4MywgeTNdO1xuICAgIH1cbiAgICBjb25zdCBbeDEsIHkxXSA9IHBhdGhbaV07XG4gICAgY29uc3QgW3gyLCB5Ml0gPSBwYXRoW2kgKyAxXTtcbiAgICBjb25zdCBjb250cm9sMSA9IFt4MCArIDIgKiAoeDEgLSB4MCkgLyAzLCB5MCArIDIgKiAoeTEgLSB5MCkgLyAzXTtcbiAgICBjb25zdCBjb250cm9sMiA9IFt4MiArIDIgKiAoeDEgLSB4MikgLyAzLCB5MiArIDIgKiAoeTEgLSB5MikgLyAzXTtcbiAgICBiZXppZXJQb2ludHMucHVzaChbW3gwLCB5MF0sIGNvbnRyb2wxLCBjb250cm9sMiwgW3gyLCB5Ml1dKTtcbiAgICByZXR1cm4gYmV6aWVyUG9pbnRzO1xuICB9XG4gICNyZWRyYXcoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2V0U3Ryb2tlKCk7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzLFxuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy4jdXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMuYmV6aWVyUGF0aDJEKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH1cbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuI2Rpc2FibGVFZGl0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIik7XG4gICAgdGhpcy4jZml0VG9Db250ZW50KHRydWUpO1xuICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgdGhpcy5wYXJlbnQuYWRkSW5rRWRpdG9ySWZOZWVkZWQodHJ1ZSk7XG4gICAgdGhpcy5tb3ZlSW5ET00oKTtcbiAgICB0aGlzLmRpdi5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgfVxuICAjYWRkUG9pbnRlcmRvd25MaXN0ZW5lcigpIHtcbiAgICBpZiAodGhpcy4jcG9pbnRlcmRvd25BQykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNwb2ludGVyZG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNwb2ludGVyZG93bkFDKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy5jYW52YXNQb2ludGVyZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICAjcmVtb3ZlUG9pbnRlcmRvd25MaXN0ZW5lcigpIHtcbiAgICB0aGlzLnBvaW50ZXJkb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy5wb2ludGVyZG93bkFDID0gbnVsbDtcbiAgfVxuICBjYW52YXNQb2ludGVyZG93bihldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIXRoaXMuaXNJbkVkaXRNb2RlKCkgfHwgdGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmICghdGhpcy5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI3N0YXJ0RHJhd2luZyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuICBjYW52YXNQb2ludGVybW92ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jZHJhdyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuICBjYW52YXNQb2ludGVydXAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2VuZERyYXdpbmcoZXZlbnQpO1xuICB9XG4gIGNhbnZhc1BvaW50ZXJsZWF2ZShldmVudCkge1xuICAgIHRoaXMuI2VuZERyYXdpbmcoZXZlbnQpO1xuICB9XG4gICNlbmREcmF3aW5nKGV2ZW50KSB7XG4gICAgdGhpcy4jZHJhd2luZ0FDPy5hYm9ydCgpO1xuICAgIHRoaXMuI2RyYXdpbmdBQyA9IG51bGw7XG4gICAgdGhpcy4jYWRkUG9pbnRlcmRvd25MaXN0ZW5lcigpO1xuICAgIGlmICh0aGlzLiNjYW52YXNDb250ZXh0TWVudVRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkKTtcbiAgICB9XG4gICAgdGhpcy4jY2FudmFzQ29udGV4dE1lbnVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI2NhbnZhc0NvbnRleHRNZW51VGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51KTtcbiAgICB9LCAxMCk7XG4gICAgdGhpcy4jc3RvcERyYXdpbmcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKCk7XG4gICAgdGhpcy5zZXRJbkJhY2tncm91bmQoKTtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xhc3NOYW1lID0gXCJpbmtFZGl0b3JDYW52YXNcIjtcbiAgICB0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1pbmstY2FudmFzXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmNhbnZhcyk7XG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIH1cbiAgI2NyZWF0ZU9ic2VydmVyKCkge1xuICAgIHRoaXMuI29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Q7XG4gICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI29ic2VydmVyLm9ic2VydmUodGhpcy5kaXYpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNvYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLiNkaXNhYmxlRWRpdGluZztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWlua1wiKTtcbiAgICBjb25zdCBbeCwgeSwgdywgaF0gPSB0aGlzLiNnZXRJbml0aWFsQkJveCgpO1xuICAgIHRoaXMuc2V0QXQoeCwgeSwgMCwgMCk7XG4gICAgdGhpcy5zZXREaW1zKHcsIGgpO1xuICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICB0aGlzLnNldEFzcGVjdFJhdGlvKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICAgIHRoaXMuc2V0RGltcyh0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImRpc2FibGVkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiZWRpdGluZ1wiKTtcbiAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI3NldENhbnZhc0RpbXMoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh0aGlzLndpZHRoICogcGFyZW50V2lkdGgpO1xuICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbCh0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgdGhpcy4jdXBkYXRlVHJhbnNmb3JtKCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgcm91bmRlZFdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCk7XG4gICAgY29uc3Qgcm91bmRlZEhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcbiAgICBpZiAodGhpcy4jcmVhbFdpZHRoID09PSByb3VuZGVkV2lkdGggJiYgdGhpcy4jcmVhbEhlaWdodCA9PT0gcm91bmRlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZWFsV2lkdGggPSByb3VuZGVkV2lkdGg7XG4gICAgdGhpcy4jcmVhbEhlaWdodCA9IHJvdW5kZWRIZWlnaHQ7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHRoaXMuI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgIHRoaXMuZml4RGltcygpO1xuICB9XG4gICNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKTtcbiAgICBjb25zdCBzY2FsZUZhY3RvclcgPSAod2lkdGggLSBwYWRkaW5nKSAvIHRoaXMuI2Jhc2VXaWR0aDtcbiAgICBjb25zdCBzY2FsZUZhY3RvckggPSAoaGVpZ2h0IC0gcGFkZGluZykgLyB0aGlzLiNiYXNlSGVpZ2h0O1xuICAgIHRoaXMuc2NhbGVGYWN0b3IgPSBNYXRoLm1pbihzY2FsZUZhY3RvclcsIHNjYWxlRmFjdG9ySCk7XG4gIH1cbiAgI3VwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy4jZ2V0UGFkZGluZygpIC8gMjtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0odGhpcy5zY2FsZUZhY3RvciwgMCwgMCwgdGhpcy5zY2FsZUZhY3RvciwgdGhpcy50cmFuc2xhdGlvblggKiB0aGlzLnNjYWxlRmFjdG9yICsgcGFkZGluZywgdGhpcy50cmFuc2xhdGlvblkgKiB0aGlzLnNjYWxlRmFjdG9yICsgcGFkZGluZyk7XG4gIH1cbiAgc3RhdGljICNidWlsZFBhdGgyRChiZXppZXIpIHtcbiAgICBjb25zdCBwYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYmV6aWVyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IFtmaXJzdCwgY29udHJvbDEsIGNvbnRyb2wyLCBzZWNvbmRdID0gYmV6aWVyW2ldO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcGF0aDJELm1vdmVUbyguLi5maXJzdCk7XG4gICAgICB9XG4gICAgICBwYXRoMkQuYmV6aWVyQ3VydmVUbyhjb250cm9sMVswXSwgY29udHJvbDFbMV0sIGNvbnRyb2wyWzBdLCBjb250cm9sMlsxXSwgc2Vjb25kWzBdLCBzZWNvbmRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDJEO1xuICB9XG4gIHN0YXRpYyAjdG9QREZDb29yZGluYXRlcyhwb2ludHMsIHJlY3QsIHJvdGF0aW9uKSB7XG4gICAgY29uc3QgW2JsWCwgYmxZLCB0clgsIHRyWV0gPSByZWN0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gKz0gYmxYO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHBvaW50c1tpICsgMV0gKyBibFg7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHggKyBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clggLSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSArPSBibFk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBjb25zdCB4ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWCAtIHBvaW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIHg7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG4gIHN0YXRpYyAjZnJvbVBERkNvb3JkaW5hdGVzKHBvaW50cywgcmVjdCwgcm90YXRpb24pIHtcbiAgICBjb25zdCBbYmxYLCBibFksIHRyWCwgdHJZXSA9IHJlY3Q7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSAtPSBibFg7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gcG9pbnRzW2kgKyAxXSAtIGJsWTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0geCAtIGJsWDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWCAtIHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdIC09IGJsWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJYIC0geDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgI3NlcmlhbGl6ZVBhdGhzKHMsIHR4LCB0eSwgcmVjdCkge1xuICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMudGhpY2tuZXNzIC8gMjtcbiAgICBjb25zdCBzaGlmdFggPSBzICogdHggKyBwYWRkaW5nO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHMgKiB0eSArIHBhZGRpbmc7XG4gICAgZm9yIChjb25zdCBiZXppZXIgb2YgdGhpcy5wYXRocykge1xuICAgICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IGJlemllci5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgIGNvbnN0IFtmaXJzdCwgY29udHJvbDEsIGNvbnRyb2wyLCBzZWNvbmRdID0gYmV6aWVyW2pdO1xuICAgICAgICBpZiAoZmlyc3RbMF0gPT09IHNlY29uZFswXSAmJiBmaXJzdFsxXSA9PT0gc2Vjb25kWzFdICYmIGpqID09PSAxKSB7XG4gICAgICAgICAgY29uc3QgcDAgPSBzICogZmlyc3RbMF0gKyBzaGlmdFg7XG4gICAgICAgICAgY29uc3QgcDEgPSBzICogZmlyc3RbMV0gKyBzaGlmdFk7XG4gICAgICAgICAgYnVmZmVyLnB1c2gocDAsIHAxKTtcbiAgICAgICAgICBwb2ludHMucHVzaChwMCwgcDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAxMCA9IHMgKiBmaXJzdFswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDExID0gcyAqIGZpcnN0WzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwMjAgPSBzICogY29udHJvbDFbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAyMSA9IHMgKiBjb250cm9sMVsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDMwID0gcyAqIGNvbnRyb2wyWzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMzEgPSBzICogY29udHJvbDJbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHA0MCA9IHMgKiBzZWNvbmRbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHA0MSA9IHMgKiBzZWNvbmRbMV0gKyBzaGlmdFk7XG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2gocDEwLCBwMTEpO1xuICAgICAgICAgIHBvaW50cy5wdXNoKHAxMCwgcDExKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChwMjAsIHAyMSwgcDMwLCBwMzEsIHA0MCwgcDQxKTtcbiAgICAgICAgcG9pbnRzLnB1c2gocDIwLCBwMjEpO1xuICAgICAgICBpZiAoaiA9PT0gamogLSAxKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocDQwLCBwNDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgYmV6aWVyOiBJbmtFZGl0b3IuI3RvUERGQ29vcmRpbmF0ZXMoYnVmZmVyLCByZWN0LCB0aGlzLnJvdGF0aW9uKSxcbiAgICAgICAgcG9pbnRzOiBJbmtFZGl0b3IuI3RvUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCB0aGlzLnJvdGF0aW9uKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbiAgfVxuICAjZ2V0QmJveCgpIHtcbiAgICBsZXQgeE1pbiA9IEluZmluaXR5O1xuICAgIGxldCB4TWF4ID0gLUluZmluaXR5O1xuICAgIGxldCB5TWluID0gSW5maW5pdHk7XG4gICAgbGV0IHlNYXggPSAtSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGZvciAoY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gb2YgcGF0aCkge1xuICAgICAgICBjb25zdCBiYm94ID0gVXRpbC5iZXppZXJCb3VuZGluZ0JveCguLi5maXJzdCwgLi4uY29udHJvbDEsIC4uLmNvbnRyb2wyLCAuLi5zZWNvbmQpO1xuICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbiwgYmJveFswXSk7XG4gICAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCBiYm94WzFdKTtcbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIGJib3hbMl0pO1xuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgYmJveFszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbeE1pbiwgeU1pbiwgeE1heCwgeU1heF07XG4gIH1cbiAgI2dldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rpc2FibGVFZGl0aW5nID8gTWF0aC5jZWlsKHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnRTY2FsZSkgOiAwO1xuICB9XG4gICNmaXRUb0NvbnRlbnQoZmlyc3RUaW1lID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNnZXRCYm94KCk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKTtcbiAgICB0aGlzLiNiYXNlV2lkdGggPSBNYXRoLm1heChBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdGhpcy4jYmFzZUhlaWdodCA9IE1hdGgubWF4KEFubm90YXRpb25FZGl0b3IuTUlOX1NJWkUsIGJib3hbM10gLSBiYm94WzFdKTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChwYWRkaW5nICsgdGhpcy4jYmFzZVdpZHRoICogdGhpcy5zY2FsZUZhY3Rvcik7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5jZWlsKHBhZGRpbmcgKyB0aGlzLiNiYXNlSGVpZ2h0ICogdGhpcy5zY2FsZUZhY3Rvcik7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcHJldlRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25YO1xuICAgIGNvbnN0IHByZXZUcmFuc2xhdGlvblkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IC1iYm94WzBdO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gLWJib3hbMV07XG4gICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIHRoaXMuI3JlZHJhdygpO1xuICAgIHRoaXMuI3JlYWxXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuI3JlYWxIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IHVuc2NhbGVkUGFkZGluZyA9IGZpcnN0VGltZSA/IHBhZGRpbmcgLyB0aGlzLnNjYWxlRmFjdG9yIC8gMiA6IDA7XG4gICAgdGhpcy50cmFuc2xhdGUocHJldlRyYW5zbGF0aW9uWCAtIHRoaXMudHJhbnNsYXRpb25YIC0gdW5zY2FsZWRQYWRkaW5nLCBwcmV2VHJhbnNsYXRpb25ZIC0gdGhpcy50cmFuc2xhdGlvblkgLSB1bnNjYWxlZFBhZGRpbmcpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLnRoaWNrbmVzcyA9IGRhdGEudGhpY2tuZXNzO1xuICAgIGVkaXRvci5jb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmRhdGEuY29sb3IpO1xuICAgIGVkaXRvci5vcGFjaXR5ID0gZGF0YS5vcGFjaXR5O1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IHdpZHRoID0gZWRpdG9yLndpZHRoICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVkaXRvci5oZWlnaHQgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gZWRpdG9yLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBkYXRhLnRoaWNrbmVzcyAvIDI7XG4gICAgZWRpdG9yLiNkaXNhYmxlRWRpdGluZyA9IHRydWU7XG4gICAgZWRpdG9yLiNyZWFsV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBlZGl0b3IuI3JlYWxIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aHMsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcbiAgICBmb3IgKGxldCB7XG4gICAgICBiZXppZXJcbiAgICB9IG9mIHBhdGhzKSB7XG4gICAgICBiZXppZXIgPSBJbmtFZGl0b3IuI2Zyb21QREZDb29yZGluYXRlcyhiZXppZXIsIHJlY3QsIHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHBhdGggPSBbXTtcbiAgICAgIGVkaXRvci5wYXRocy5wdXNoKHBhdGgpO1xuICAgICAgbGV0IHAwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyWzBdIC0gcGFkZGluZyk7XG4gICAgICBsZXQgcDEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbMV0gLSBwYWRkaW5nKTtcbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IHAxMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMTEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDFdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgMl0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDIxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAzXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMzAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDRdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAzMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgNV0gLSBwYWRkaW5nKTtcbiAgICAgICAgcGF0aC5wdXNoKFtbcDAsIHAxXSwgW3AxMCwgcDExXSwgW3AyMCwgcDIxXSwgW3AzMCwgcDMxXV0pO1xuICAgICAgICBwMCA9IHAzMDtcbiAgICAgICAgcDEgPSBwMzE7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXRoMkQgPSB0aGlzLiNidWlsZFBhdGgyRChwYXRoKTtcbiAgICAgIGVkaXRvci5iZXppZXJQYXRoMkQucHVzaChwYXRoMkQpO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gZWRpdG9yLiNnZXRCYm94KCk7XG4gICAgZWRpdG9yLiNiYXNlV2lkdGggPSBNYXRoLm1heChBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgZWRpdG9yLiNiYXNlSGVpZ2h0ID0gTWF0aC5tYXgoQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFszXSAtIGJib3hbMV0pO1xuICAgIGVkaXRvci4jc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuY3R4LnN0cm9rZVN0eWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLklOSyxcbiAgICAgIGNvbG9yLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLnRoaWNrbmVzcyxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgIHBhdGhzOiB0aGlzLiNzZXJpYWxpemVQYXRocyh0aGlzLnNjYWxlRmFjdG9yIC8gdGhpcy5wYXJlbnRTY2FsZSwgdGhpcy50cmFuc2xhdGlvblgsIHRoaXMudHJhbnNsYXRpb25ZLCByZWN0KSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICBzdHJ1Y3RUcmVlUGFyZW50SWQ6IHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZFxuICAgIH07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3N0YW1wLmpzXG5cblxuXG5cbmNsYXNzIFN0YW1wRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNiaXRtYXAgPSBudWxsO1xuICAjYml0bWFwSWQgPSBudWxsO1xuICAjYml0bWFwUHJvbWlzZSA9IG51bGw7XG4gICNiaXRtYXBVcmwgPSBudWxsO1xuICAjYml0bWFwRmlsZSA9IG51bGw7XG4gICNiaXRtYXBGaWxlTmFtZSA9IFwiXCI7XG4gICNjYW52YXMgPSBudWxsO1xuICAjb2JzZXJ2ZXIgPSBudWxsO1xuICAjcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgI2lzU3ZnID0gZmFsc2U7XG4gICNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IGZhbHNlO1xuICBzdGF0aWMgX3R5cGUgPSBcInN0YW1wXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcInN0YW1wRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNiaXRtYXBVcmwgPSBwYXJhbXMuYml0bWFwVXJsO1xuICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBwYXJhbXMuYml0bWFwRmlsZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRlZFR5cGVzKCkge1xuICAgIGNvbnN0IHR5cGVzID0gW1wiYXBuZ1wiLCBcImF2aWZcIiwgXCJibXBcIiwgXCJnaWZcIiwgXCJqcGVnXCIsIFwicG5nXCIsIFwic3ZnK3htbFwiLCBcIndlYnBcIiwgXCJ4LWljb25cIl07XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInN1cHBvcnRlZFR5cGVzXCIsIHR5cGVzLm1hcCh0eXBlID0+IGBpbWFnZS8ke3R5cGV9YCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydGVkVHlwZXNTdHIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInN1cHBvcnRlZFR5cGVzU3RyXCIsIHRoaXMuc3VwcG9ydGVkVHlwZXMuam9pbihcIixcIikpO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiB0aGlzLnN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKG1pbWUpO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICBwYXJlbnQucGFzdGVFZGl0b3IoQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsIHtcbiAgICAgIGJpdG1hcEZpbGU6IGl0ZW0uZ2V0QXNGaWxlKClcbiAgICB9KTtcbiAgfVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIGlmICh0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICBzdXBlci5hbHRUZXh0RmluaXNoKCk7XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJzdGFtcFwiLFxuICAgICAgaGFzQWx0VGV4dDogISF0aGlzLmFsdFRleHREYXRhPy5hbHRUZXh0XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaGFzQWx0VGV4dFN0YXRzID0gZGF0YS5nZXQoXCJoYXNBbHRUZXh0XCIpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNBbHRUZXh0OiBoYXNBbHRUZXh0U3RhdHMuZ2V0KHRydWUpID8/IDAsXG4gICAgICBoYXNOb0FsdFRleHQ6IGhhc0FsdFRleHRTdGF0cy5nZXQoZmFsc2UpID8/IDBcbiAgICB9O1xuICB9XG4gICNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIGZyb21JZCA9IGZhbHNlKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNiaXRtYXAgPSBkYXRhLmJpdG1hcDtcbiAgICBpZiAoIWZyb21JZCkge1xuICAgICAgdGhpcy4jYml0bWFwSWQgPSBkYXRhLmlkO1xuICAgICAgdGhpcy4jaXNTdmcgPSBkYXRhLmlzU3ZnO1xuICAgIH1cbiAgICBpZiAoZGF0YS5maWxlKSB7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlTmFtZSA9IGRhdGEuZmlsZS5uYW1lO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgfVxuICAjZ2V0Qml0bWFwRG9uZSgpIHtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyhmYWxzZSk7XG4gICAgaWYgKCF0aGlzLiNjYW52YXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlICYmIHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyAmJiB0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuX2VkaXRUb29sYmFyLmhpZGUoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSAmJiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3cgJiYgdGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuaW1hZ2VfYWRkZWRcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiBmYWxzZSxcbiAgICAgICAgICBhbHRfdGV4dF90eXBlOiBcImVtcHR5XCJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLm1sR3Vlc3NBbHRUZXh0KCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgYXN5bmMgbWxHdWVzc0FsdFRleHQoaW1hZ2VEYXRhID0gbnVsbCwgdXBkYXRlQWx0VGV4dERhdGEgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuaGFzQWx0VGV4dERhdGEoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1sTWFuYWdlclxuICAgIH0gPSB0aGlzLl91aU1hbmFnZXI7XG4gICAgaWYgKCFtbE1hbmFnZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIE1MLlwiKTtcbiAgICB9XG4gICAgaWYgKCEoYXdhaXQgbWxNYW5hZ2VyLmlzRW5hYmxlZEZvcihcImFsdFRleHRcIikpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNTCBpc24ndCBlbmFibGVkIGZvciBhbHQgdGV4dC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWFnZURhdGEgfHwgdGhpcy5jb3B5Q2FudmFzKG51bGwsIG51bGwsIHRydWUpLmltYWdlRGF0YTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG1sTWFuYWdlci5ndWVzcyh7XG4gICAgICBuYW1lOiBcImFsdFRleHRcIixcbiAgICAgIHJlcXVlc3Q6IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgY2hhbm5lbHM6IGRhdGEubGVuZ3RoIC8gKHdpZHRoICogaGVpZ2h0KVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UuY2FuY2VsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vdXRwdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHZhbGlkIHJlc3BvbnNlIGZyb20gdGhlIEFJIHNlcnZpY2UuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbHRUZXh0ID0gcmVzcG9uc2Uub3V0cHV0O1xuICAgIGF3YWl0IHRoaXMuc2V0R3Vlc3NlZEFsdFRleHQoYWx0VGV4dCk7XG4gICAgaWYgKHVwZGF0ZUFsdFRleHREYXRhICYmICF0aGlzLmhhc0FsdFRleHREYXRhKCkpIHtcbiAgICAgIHRoaXMuYWx0VGV4dERhdGEgPSB7XG4gICAgICAgIGFsdDogYWx0VGV4dCxcbiAgICAgICAgZGVjb3JhdGl2ZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhbHRUZXh0O1xuICB9XG4gICNnZXRCaXRtYXAoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUlkKHRoaXMuI2JpdG1hcElkKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhLCB0cnVlKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwVXJsKSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLiNiaXRtYXBVcmw7XG4gICAgICB0aGlzLiNiaXRtYXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tVXJsKHVybCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcEZpbGUpIHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLiNiaXRtYXBGaWxlO1xuICAgICAgdGhpcy4jYml0bWFwRmlsZSA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGZpbGUpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICBpbnB1dC5hY2NlcHQgPSBTdGFtcEVkaXRvci5zdXBwb3J0ZWRUeXBlc1N0cjtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCFpbnB1dC5maWxlcyB8fCBpbnB1dC5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21GaWxlKGlucHV0LmZpbGVzWzBdKTtcbiAgICAgICAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgICAgICAgYWN0aW9uOiBcInBkZmpzLmltYWdlLmltYWdlX3NlbGVjdGVkXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIGFsdF90ZXh0X21vZGFsOiB0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dEZsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgIGlucHV0LmNsaWNrKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jYml0bWFwID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZGVsZXRlSWQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgdGhpcy4jY2FudmFzPy5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI2NhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLiNvYnNlcnZlcj8uZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy4jb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jcmVzaXplVGltZW91dElkKTtcbiAgICAgICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkICYmIHRoaXMuI2NhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICEodGhpcy4jYml0bWFwUHJvbWlzZSB8fCB0aGlzLiNiaXRtYXAgfHwgdGhpcy4jYml0bWFwVXJsIHx8IHRoaXMuI2JpdG1hcEZpbGUgfHwgdGhpcy4jYml0bWFwSWQpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImZpZ3VyZVwiKTtcbiAgICB0aGlzLmFkZEFsdFRleHRCdXR0b24oKTtcbiAgICBpZiAodGhpcy4jYml0bWFwKSB7XG4gICAgICB0aGlzLiNjcmVhdGVDYW52YXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLndpZHRoICYmICF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXZcbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBNQVhfUkFUSU8gPSAwLjc1O1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICB3aWR0aCA9IHRoaXMud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgICBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA+IE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCB8fCBoZWlnaHQgPiBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0KSB7XG4gICAgICBjb25zdCBmYWN0b3IgPSBNYXRoLm1pbihNQVhfUkFUSU8gKiBwYWdlV2lkdGggLyB3aWR0aCwgTUFYX1JBVElPICogcGFnZUhlaWdodCAvIGhlaWdodCk7XG4gICAgICB3aWR0aCAqPSBmYWN0b3I7XG4gICAgICBoZWlnaHQgKj0gZmFjdG9yO1xuICAgIH1cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoICogcGFyZW50V2lkdGggLyBwYWdlV2lkdGgsIGhlaWdodCAqIHBhcmVudEhlaWdodCAvIHBhZ2VIZWlnaHQpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIHRoaXMuYWRkQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIudXNlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSB8fCAhdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93IHx8IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLiNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiaW5zZXJ0ZWRfaW1hZ2VcIlxuICAgIH0pO1xuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlTmFtZSkge1xuICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jYml0bWFwRmlsZU5hbWUpO1xuICAgIH1cbiAgfVxuICBjb3B5Q2FudmFzKG1heERhdGFEaW1lbnNpb24sIG1heFByZXZpZXdEaW1lbnNpb24sIGNyZWF0ZUltYWdlRGF0YSA9IGZhbHNlKSB7XG4gICAgaWYgKCFtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICBtYXhEYXRhRGltZW5zaW9uID0gMjI0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCB3aWR0aCA9IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0ID0gYml0bWFwSGVpZ2h0O1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGlmIChtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICBpZiAoYml0bWFwV2lkdGggPiBtYXhQcmV2aWV3RGltZW5zaW9uIHx8IGJpdG1hcEhlaWdodCA+IG1heFByZXZpZXdEaW1lbnNpb24pIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heFByZXZpZXdEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICB3aWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgfVxuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNvbnN0IHNjYWxlZFdpZHRoID0gY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgICAgbGV0IHdoaXRlID0gXCJ3aGl0ZVwiLFxuICAgICAgICBibGFjayA9IFwiI2NmY2ZkOFwiO1xuICAgICAgaWYgKHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXIgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGJsYWNrID0gXCJibGFja1wiO1xuICAgICAgfSBlbHNlIGlmICh3aW5kb3cubWF0Y2hNZWRpYT8uKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSB7XG4gICAgICAgIHdoaXRlID0gXCIjOGY4ZjlkXCI7XG4gICAgICAgIGJsYWNrID0gXCIjNDI0MTRkXCI7XG4gICAgICB9XG4gICAgICBjb25zdCBib3hEaW0gPSAxNTtcbiAgICAgIGNvbnN0IGJveERpbVdpZHRoID0gYm94RGltICogb3V0cHV0U2NhbGUuc3g7XG4gICAgICBjb25zdCBib3hEaW1IZWlnaHQgPSBib3hEaW0gKiBvdXRwdXRTY2FsZS5zeTtcbiAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGJveERpbVdpZHRoICogMiwgYm94RGltSGVpZ2h0ICogMik7XG4gICAgICBjb25zdCBwYXR0ZXJuQ3R4ID0gcGF0dGVybi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxTdHlsZSA9IHdoaXRlO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdCgwLCAwLCBib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSBibGFjaztcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGgsIGJveERpbUhlaWdodCk7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGN0eC5jcmVhdGVQYXR0ZXJuKHBhdHRlcm4sIFwicmVwZWF0XCIpO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgfVxuICAgIGxldCBpbWFnZURhdGEgPSBudWxsO1xuICAgIGlmIChjcmVhdGVJbWFnZURhdGEpIHtcbiAgICAgIGxldCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQ7XG4gICAgICBpZiAob3V0cHV0U2NhbGUuc3ltbWV0cmljICYmIGJpdG1hcC53aWR0aCA8IG1heERhdGFEaW1lbnNpb24gJiYgYml0bWFwLmhlaWdodCA8IG1heERhdGFEaW1lbnNpb24pIHtcbiAgICAgICAgZGF0YVdpZHRoID0gYml0bWFwLndpZHRoO1xuICAgICAgICBkYXRhSGVpZ2h0ID0gYml0bWFwLmhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4RGF0YURpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwV2lkdGgsIG1heERhdGFEaW1lbnNpb24gLyBiaXRtYXBIZWlnaHQpO1xuICAgICAgICAgIGRhdGFXaWR0aCA9IE1hdGguZmxvb3IoYml0bWFwV2lkdGggKiByYXRpbyk7XG4gICAgICAgICAgZGF0YUhlaWdodCA9IE1hdGguZmxvb3IoYml0bWFwSGVpZ2h0ICogcmF0aW8pO1xuICAgICAgICAgIGlmICghdGhpcy4jaXNTdmcpIHtcbiAgICAgICAgICAgIGJpdG1hcCA9IHRoaXMuI3NjYWxlQml0bWFwKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBjb25zdCBvZmZzY3JlZW5DdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIG9mZnNjcmVlbkN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIGRhdGFXaWR0aCwgZGF0YUhlaWdodCk7XG4gICAgICBpbWFnZURhdGEgPSB7XG4gICAgICAgIHdpZHRoOiBkYXRhV2lkdGgsXG4gICAgICAgIGhlaWdodDogZGF0YUhlaWdodCxcbiAgICAgICAgZGF0YTogb2Zmc2NyZWVuQ3R4LmdldEltYWdlRGF0YSgwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpLmRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGltYWdlRGF0YVxuICAgIH07XG4gIH1cbiAgI3NldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLndpZHRoID0gd2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNyZXNpemVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAyMDA7XG4gICAgdGhpcy4jcmVzaXplVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgdGhpcy4jZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggKiBvdXRwdXRTY2FsZS5zeCk7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIG91dHB1dFNjYWxlLnN5KTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXM7XG4gICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSBzY2FsZWRXaWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBzY2FsZWRIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gc2NhbGVkV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHNjYWxlZEhlaWdodDtcbiAgICBjb25zdCBiaXRtYXAgPSB0aGlzLiNpc1N2ZyA/IHRoaXMuI2JpdG1hcCA6IHRoaXMuI3NjYWxlQml0bWFwKHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY3R4LmZpbHRlciA9IHRoaXMuX3VpTWFuYWdlci5oY21GaWx0ZXI7XG4gICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gIH1cbiAgZ2V0SW1hZ2VGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiNjYW52YXM7XG4gIH1cbiAgI3NlcmlhbGl6ZUJpdG1hcCh0b1VybCkge1xuICAgIGlmICh0b1VybCkge1xuICAgICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0U3ZnVXJsKHRoaXMuI2JpdG1hcElkKTtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAoe1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH0gPSB0aGlzLiNiaXRtYXApO1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwKTtcbiAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLnJvdW5kKHRoaXMud2lkdGggKiBwYWdlV2lkdGggKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCwgdGhpcy4jYml0bWFwLndpZHRoLCB0aGlzLiNiaXRtYXAuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodGhpcy4jYml0bWFwKTtcbiAgfVxuICAjY3JlYXRlT2JzZXJ2ZXIoKSB7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuX3NpZ25hbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0O1xuICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy4jc2V0RGltZW5zaW9ucyhyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRpdik7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgIHRoaXMuI29ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLiNvYnNlcnZlciA9IG51bGw7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBTdGFtcEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIHN0cnVjdFBhcmVudCxcbiAgICAgICAgICBwb3B1cFJlZlxuICAgICAgICB9LFxuICAgICAgICBjb250YWluZXIsXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgY29uc3QgY2FudmFzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoXCJjYW52YXNcIik7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21DYW52YXMoY29udGFpbmVyLmlkLCBjYW52YXMpO1xuICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgY29uc3QgYWx0VGV4dCA9IChhd2FpdCBwYXJlbnQuX3N0cnVjdFRyZWUuZ2V0QXJpYUF0dHJpYnV0ZXMoYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWApKT8uZ2V0KFwiYXJpYS1sYWJlbFwiKSB8fCBcIlwiO1xuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAsXG4gICAgICAgIGJpdG1hcElkOiBpbWFnZURhdGEuaWQsXG4gICAgICAgIGJpdG1hcDogaW1hZ2VEYXRhLmJpdG1hcCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICBhbHRUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3ZnOiBmYWxzZSxcbiAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gYXdhaXQgc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBiaXRtYXAsXG4gICAgICBiaXRtYXBVcmwsXG4gICAgICBiaXRtYXBJZCxcbiAgICAgIGlzU3ZnLFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoYml0bWFwSWQgJiYgdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5pc1ZhbGlkSWQoYml0bWFwSWQpKSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgICBpZiAoYml0bWFwKSB7XG4gICAgICAgIGVkaXRvci4jYml0bWFwID0gYml0bWFwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcFVybCA9IGJpdG1hcFVybDtcbiAgICB9XG4gICAgZWRpdG9yLiNpc1N2ZyA9IGlzU3ZnO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBlZGl0b3Iud2lkdGggPSAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFyZW50V2lkdGg7XG4gICAgZWRpdG9yLmhlaWdodCA9IChyZWN0WzNdIC0gcmVjdFsxXSkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBkYXRhLmlkIHx8IG51bGw7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICBlZGl0b3IuYWx0VGV4dERhdGEgPSBhY2Nlc3NpYmlsaXR5RGF0YTtcbiAgICB9XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGVkaXRvci4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSAhIWluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCxcbiAgICAgIGJpdG1hcElkOiB0aGlzLiNiaXRtYXBJZCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXgsXG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMCksXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIGlzU3ZnOiB0aGlzLiNpc1N2ZyxcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcFVybCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQodHJ1ZSk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KGZhbHNlKTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCk7XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWVBbHRUZXh0KSB7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YS5zdHJ1Y3RQYXJlbnQgPSB0aGlzLl9pbml0aWFsRGF0YS5zdHJ1Y3RQYXJlbnQgPz8gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb250ZXh0LnN0YW1wcyB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLiNpc1N2ZyA/IChzZXJpYWxpemVkLnJlY3RbMl0gLSBzZXJpYWxpemVkLnJlY3RbMF0pICogKHNlcmlhbGl6ZWQucmVjdFszXSAtIHNlcmlhbGl6ZWQucmVjdFsxXSkgOiBudWxsO1xuICAgIGlmICghY29udGV4dC5zdGFtcHMuaGFzKHRoaXMuI2JpdG1hcElkKSkge1xuICAgICAgY29udGV4dC5zdGFtcHMuc2V0KHRoaXMuI2JpdG1hcElkLCB7XG4gICAgICAgIGFyZWEsXG4gICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgIH0pO1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IHByZXZEYXRhID0gY29udGV4dC5zdGFtcHMuZ2V0KHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIGlmIChhcmVhID4gcHJldkRhdGEuYXJlYSkge1xuICAgICAgICBwcmV2RGF0YS5hcmVhID0gYXJlYTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBhY2Nlc3NpYmlsaXR5RGF0YToge1xuICAgICAgICBhbHRUZXh0XG4gICAgICB9XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIGNvbnN0IGlzU2FtZVJlY3QgPSBzZXJpYWxpemVkLnJlY3QuZXZlcnkoKHgsIGkpID0+IE1hdGguYWJzKHggLSByZWN0W2ldKSA8IDEpO1xuICAgIGNvbnN0IGlzU2FtZVBhZ2VJbmRleCA9IHNlcmlhbGl6ZWQucGFnZUluZGV4ID09PSBwYWdlSW5kZXg7XG4gICAgY29uc3QgaXNTYW1lQWx0VGV4dCA9IChzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhPy5hbHQgfHwgXCJcIikgPT09IGFsdFRleHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU2FtZTogaXNTYW1lUmVjdCAmJiBpc1NhbWVQYWdlSW5kZXggJiYgaXNTYW1lQWx0VGV4dCxcbiAgICAgIGlzU2FtZUFsdFRleHRcbiAgICB9O1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFJlY3QoMCwgMClcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIuanNcblxuXG5cblxuXG5cblxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvckxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAjYWxsb3dDbGljayA9IGZhbHNlO1xuICAjYW5ub3RhdGlvbkxheWVyID0gbnVsbDtcbiAgI2NsaWNrQUMgPSBudWxsO1xuICAjZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICN0ZXh0TGF5ZXIgPSBudWxsO1xuICAjdGV4dFNlbGVjdGlvbkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgc3RhdGljIF9pbml0aWFsaXplZCA9IGZhbHNlO1xuICBzdGF0aWMgI2VkaXRvclR5cGVzID0gbmV3IE1hcChbRnJlZVRleHRFZGl0b3IsIElua0VkaXRvciwgU3RhbXBFZGl0b3IsIEhpZ2hsaWdodEVkaXRvcl0ubWFwKHR5cGUgPT4gW3R5cGUuX2VkaXRvclR5cGUsIHR5cGVdKSk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1aU1hbmFnZXIsXG4gICAgcGFnZUluZGV4LFxuICAgIGRpdixcbiAgICBzdHJ1Y3RUcmVlTGF5ZXIsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkxheWVyLFxuICAgIGRyYXdMYXllcixcbiAgICB0ZXh0TGF5ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgbDEwblxuICB9KSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZXMgPSBbLi4uQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKV07XG4gICAgaWYgKCFBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBlZGl0b3JUeXBlcykge1xuICAgICAgICBlZGl0b3JUeXBlLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdWlNYW5hZ2VyLnJlZ2lzdGVyRWRpdG9yVHlwZXMoZWRpdG9yVHlwZXMpO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllciA9IGFubm90YXRpb25MYXllcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy4jdGV4dExheWVyID0gdGV4dExheWVyO1xuICAgIHRoaXMuZHJhd0xheWVyID0gZHJhd0xheWVyO1xuICAgIHRoaXMuX3N0cnVjdFRyZWUgPSBzdHJ1Y3RUcmVlTGF5ZXI7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZExheWVyKHRoaXMpO1xuICB9XG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzLnNpemUgPT09IDA7XG4gIH1cbiAgZ2V0IGlzSW52aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkgJiYgdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgfVxuICB1cGRhdGVUb29sYmFyKG1vZGUpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FOlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTks6XG4gICAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgdGhpcy5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZW5hYmxlQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGFzc0xpc3RcbiAgICB9ID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMudmFsdWVzKCkpIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoYCR7ZWRpdG9yVHlwZS5fdHlwZX1FZGl0aW5nYCwgbW9kZSA9PT0gZWRpdG9yVHlwZS5fZWRpdG9yVHlwZSk7XG4gICAgfVxuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGhhc1RleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICByZXR1cm4gdGV4dExheWVyID09PSB0aGlzLiN0ZXh0TGF5ZXI/LmRpdjtcbiAgfVxuICBhZGRJbmtFZGl0b3JJZk5lZWRlZChpc0NvbW1pdHRpbmcpIHtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNDb21taXR0aW5nKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmNyZWF0ZUFuZEFkZE5ld0VkaXRvcih7XG4gICAgICBvZmZzZXRYOiAwLFxuICAgICAgb2Zmc2V0WTogMFxuICAgIH0sIGZhbHNlKTtcbiAgICBlZGl0b3Iuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICB0b2dnbGVEcmF3aW5nKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkcmF3aW5nXCIsICFlbmFibGVkKTtcbiAgfVxuICB0b2dnbGVQb2ludGVyRXZlbnRzKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gIH1cbiAgdG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyhlbmFibGVkID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI/LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgIWVuYWJsZWQpO1xuICB9XG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IDA7XG4gICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIGNvbnN0IGFubm90YXRpb25FbGVtZW50SWRzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICBlZGl0b3Iuc2hvdyh0cnVlKTtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0YWJsZXMgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICBlZGl0YWJsZS5oaWRlKCk7XG4gICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGFubm90YXRpb25FbGVtZW50SWRzLmhhcyhlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemUoZWRpdGFibGUpO1xuICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB9XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLiNpc0Rpc2FibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIGNvbnN0IGNoYW5nZWRBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCByZXNldEFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5kaXNhYmxlRWRpdGluZygpO1xuICAgICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0b3Iuc2VyaWFsaXplKCkgIT09IG51bGwpIHtcbiAgICAgICAgY2hhbmdlZEFubm90YXRpb25zLnNldChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCwgZWRpdG9yKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEFubm90YXRpb25zLnNldChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCwgZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKT8uc2hvdygpO1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICBjb25zdCBlZGl0YWJsZXMgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBlZGl0YWJsZS5kYXRhO1xuICAgICAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmlzRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlZGl0b3IgPSByZXNldEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICBlZGl0b3IucmVzZXRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSk7XG4gICAgICAgICAgZWRpdG9yLnNob3coZmFsc2UpO1xuICAgICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IgPSBjaGFuZ2VkQW5ub3RhdGlvbnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGRDaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9uKGVkaXRvcik7XG4gICAgICAgICAgaWYgKGVkaXRvci5yZW5kZXJBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2xhc3NMaXN0XG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLnZhbHVlcygpKSB7XG4gICAgICBjbGFzc0xpc3QucmVtb3ZlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2ApO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgdGhpcy50b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB8fCBudWxsO1xuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIGlmIChjdXJyZW50QWN0aXZlID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihlZGl0b3IpO1xuICB9XG4gIGVuYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgIXRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRTZWxlY3Rpb25BQyk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiN0ZXh0TGF5ZXJQb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gIGRpc2FibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gICN0ZXh0TGF5ZXJQb2ludGVyRG93bihldmVudCkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLiN0ZXh0TGF5ZXIuZGl2IHx8ICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJpbWdcIiB8fCB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZW5kT2ZDb250ZW50XCIpKSAmJiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNNYWNcbiAgICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVcIik7XG4gICAgICB0aGlzLnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIEhpZ2hsaWdodEVkaXRvci5zdGFydEhpZ2hsaWdodGluZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiLCB7XG4gICAgICAgIHRhcmdldDogdGhpcy4jdGV4dExheWVyLmRpdixcbiAgICAgICAgeDogZXZlbnQueCxcbiAgICAgICAgeTogZXZlbnQueVxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJmcmVlXCIpO1xuICAgICAgICB0aGlzLnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuI2NsaWNrQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY2xpY2tBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jY2xpY2tBQyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMucG9pbnRlcmRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLnBvaW50ZXJ1cC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlQ2xpY2soKSB7XG4gICAgdGhpcy4jY2xpY2tBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjbGlja0FDID0gbnVsbDtcbiAgfVxuICBhdHRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgICB9ID0gZWRpdG9yO1xuICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkICYmIHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICBpZiAoIXRoaXMuI2lzRGlzYWJsaW5nICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZShlZGl0b3IpIHtcbiAgICB0aGlzLmRldGFjaChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVFZGl0b3IoZWRpdG9yKTtcbiAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuI2lzQ2xlYW5pbmdVcCkge1xuICAgICAgdGhpcy5hZGRJbmtFZGl0b3JJZk5lZWRlZChmYWxzZSk7XG4gICAgfVxuICB9XG4gIGNoYW5nZVBhcmVudChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWRpdG9yLnBhcmVudCAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yLmRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnBhcmVudD8uZGV0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnNldFBhcmVudCh0aGlzKTtcbiAgICBpZiAoZWRpdG9yLmRpdiAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGVkaXRvci5kaXYpO1xuICAgIH1cbiAgfVxuICBhZGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgY29uc3QgZGl2ID0gZWRpdG9yLnJlbmRlcigpO1xuICAgICAgdGhpcy5kaXYuYXBwZW5kKGRpdik7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gdHJ1ZTtcbiAgICB9XG4gICAgZWRpdG9yLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gICAgZWRpdG9yLm9uY2VBZGRlZCgpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgZWRpdG9yLl9yZXBvcnRUZWxlbWV0cnkoZWRpdG9yLnRlbGVtZXRyeUluaXRpYWxEYXRhKTtcbiAgfVxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkgJiYgIXRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkKSB7XG4gICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IGZhbHNlO1xuICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICBpZiAoIWVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICBlZGl0b3IuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsICgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmNlOiB0cnVlLFxuICAgICAgICAgICAgc2lnbmFsOiB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucGFyZW50IHx8PSB0aGlzO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICAgIGVkaXRvci5zaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFkZFVuZG9hYmxlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGNtZCA9ICgpID0+IGVkaXRvci5fdWlNYW5hZ2VyLnJlYnVpbGQoZWRpdG9yKTtcbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICBnZXQgI2N1cnJlbnRFZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLmdldCh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKTtcbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICB9XG4gICNjcmVhdGVOZXdFZGl0b3IocGFyYW1zKSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZSA9IHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlO1xuICAgIHJldHVybiBlZGl0b3JUeXBlID8gbmV3IGVkaXRvclR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcykgOiBudWxsO1xuICB9XG4gIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKTtcbiAgfVxuICBwYXN0ZUVkaXRvcihtb2RlLCBwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihtb2RlKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSB0aGlzLiNnZXRDZW50ZXJQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBvZmZzZXRYLFxuICAgICAgeTogb2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICByZXR1cm4gKGF3YWl0IEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KGRhdGEuYW5ub3RhdGlvblR5cGUgPz8gZGF0YS5hbm5vdGF0aW9uRWRpdG9yVHlwZSk/LmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcikpIHx8IG51bGw7XG4gIH1cbiAgY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBpc0NlbnRlcmVkLCBkYXRhID0ge30pIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogZXZlbnQub2Zmc2V0WCxcbiAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICAjZ2V0Q2VudGVyUG9pbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB0bFggPSBNYXRoLm1heCgwLCB4KTtcbiAgICBjb25zdCB0bFkgPSBNYXRoLm1heCgwLCB5KTtcbiAgICBjb25zdCBiclggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgeCArIHdpZHRoKTtcbiAgICBjb25zdCBiclkgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGNvbnN0IGNlbnRlclggPSAodGxYICsgYnJYKSAvIDIgLSB4O1xuICAgIGNvbnN0IGNlbnRlclkgPSAodGxZICsgYnJZKSAvIDIgLSB5O1xuICAgIGNvbnN0IFtvZmZzZXRYLCBvZmZzZXRZXSA9IHRoaXMudmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDAgPyBbY2VudGVyWCwgY2VudGVyWV0gOiBbY2VudGVyWSwgY2VudGVyWF07XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfTtcbiAgfVxuICBhZGROZXdFZGl0b3IoKSB7XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IodGhpcy4jZ2V0Q2VudGVyUG9pbnQoKSwgdHJ1ZSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnRvZ2dsZVNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0KGVkaXRvcik7XG4gIH1cbiAgcG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIGlmICghdGhpcy4jYWxsb3dDbGljaykge1xuICAgICAgdGhpcy4jYWxsb3dDbGljayA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IHRydWU7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIHRoaXMuI2FsbG93Q2xpY2sgPSAhZWRpdG9yIHx8IGVkaXRvci5pc0VtcHR5KCk7XG4gIH1cbiAgZmluZE5ld1BhcmVudChlZGl0b3IsIHgsIHkpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI3VpTWFuYWdlci5maW5kUGFyZW50KHgsIHkpO1xuICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXllci5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLnNldFBhcmVudChudWxsKTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG4gICNjbGVhbnVwKCkge1xuICAgIHRoaXMuI2lzQ2xlYW5pbmdVcCA9IHRydWU7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgfVxuICByZW5kZXIoe1xuICAgIHZpZXdwb3J0XG4gIH0pIHtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB2aWV3cG9ydCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jdWlNYW5hZ2VyLmdldEVkaXRvcnModGhpcy5wYWdlSW5kZXgpKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGNvbnN0IG9sZFJvdGF0aW9uID0gdGhpcy52aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBjb25zdCByb3RhdGlvbiA9IHZpZXdwb3J0LnJvdGF0aW9uO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBzZXRMYXllckRpbWVuc2lvbnModGhpcy5kaXYsIHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSk7XG4gICAgaWYgKG9sZFJvdGF0aW9uICE9PSByb3RhdGlvbikge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3Iucm90YXRlKHJvdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZGRJbmtFZGl0b3JJZk5lZWRlZChmYWxzZSk7XG4gIH1cbiAgZ2V0IHBhZ2VEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydC5yYXdEaW1zO1xuICAgIHJldHVybiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgfVxuICBnZXQgc2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZHJhd19sYXllci5qc1xuXG5cbmNsYXNzIERyYXdMYXllciB7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjaWQgPSAwO1xuICAjbWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgI3RvVXBkYXRlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFnZUluZGV4XG4gIH0pIHtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLiNwYXJlbnQpIHtcbiAgICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BhcmVudCAhPT0gcGFyZW50KSB7XG4gICAgICBpZiAodGhpcy4jbWFwcGluZy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvb3Qgb2YgdGhpcy4jbWFwcGluZy52YWx1ZXMoKSkge1xuICAgICAgICAgIHJvb3QucmVtb3ZlKCk7XG4gICAgICAgICAgcGFyZW50LmFwcGVuZChyb290KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IF9zdmdGYWN0b3J5KCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfc3ZnRmFjdG9yeVwiLCBuZXcgRE9NU1ZHRmFjdG9yeSgpKTtcbiAgfVxuICBzdGF0aWMgI3NldEJveChlbGVtZW50LCB7XG4gICAgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgd2lkdGggPSAxLFxuICAgIGhlaWdodCA9IDFcbiAgfSA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZWxlbWVudDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiB5fSVgO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiB4fSVgO1xuICAgIHN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGh9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0fSVgO1xuICB9XG4gICNjcmVhdGVTVkcoYm94KSB7XG4gICAgY29uc3Qgc3ZnID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZSgxLCAxLCB0cnVlKTtcbiAgICB0aGlzLiNwYXJlbnQuYXBwZW5kKHN2Zyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICAgIERyYXdMYXllci4jc2V0Qm94KHN2ZywgYm94KTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gICNjcmVhdGVDbGlwUGF0aChkZWZzLCBwYXRoSWQpIHtcbiAgICBjb25zdCBjbGlwUGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGNvbnN0IGNsaXBQYXRoSWQgPSBgY2xpcF8ke3BhdGhJZH1gO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGNsaXBQYXRoSWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBjb25zdCBjbGlwUGF0aFVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwUGF0aFVzZSk7XG4gICAgY2xpcFBhdGhVc2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGNsaXBQYXRoVXNlLmNsYXNzTGlzdC5hZGQoXCJjbGlwXCIpO1xuICAgIHJldHVybiBjbGlwUGF0aElkO1xuICB9XG4gIGRyYXcob3V0bGluZXMsIGNvbG9yLCBvcGFjaXR5LCBpc1BhdGhVcGRhdGFibGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKG91dGxpbmVzLmJveCk7XG4gICAgcm9vdC5jbGFzc0xpc3QuYWRkKC4uLm91dGxpbmVzLmNsYXNzTmFtZXNGb3JEcmF3aW5nKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIG91dGxpbmVzLnRvU1ZHUGF0aCgpKTtcbiAgICBpZiAoaXNQYXRoVXBkYXRhYmxlKSB7XG4gICAgICB0aGlzLiN0b1VwZGF0ZS5zZXQoaWQsIHBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBjbGlwUGF0aElkID0gdGhpcy4jY3JlYXRlQ2xpcFBhdGgoZGVmcywgcGF0aElkKTtcbiAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UpO1xuICAgIHJvb3Quc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBjb2xvcik7XG4gICAgcm9vdC5zZXRBdHRyaWJ1dGUoXCJmaWxsLW9wYWNpdHlcIiwgb3BhY2l0eSk7XG4gICAgdXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICB0aGlzLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgY2xpcFBhdGhJZDogYHVybCgjJHtjbGlwUGF0aElkfSlgXG4gICAgfTtcbiAgfVxuICBkcmF3T3V0bGluZShvdXRsaW5lcykge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jaWQrKztcbiAgICBjb25zdCByb290ID0gdGhpcy4jY3JlYXRlU1ZHKG91dGxpbmVzLmJveCk7XG4gICAgcm9vdC5jbGFzc0xpc3QuYWRkKC4uLm91dGxpbmVzLmNsYXNzTmFtZXNGb3JPdXRsaW5pbmcpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgb3V0bGluZXMudG9TVkdQYXRoKCkpO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwidmVjdG9yLWVmZmVjdFwiLCBcIm5vbi1zY2FsaW5nLXN0cm9rZVwiKTtcbiAgICBsZXQgbWFza0lkO1xuICAgIGlmIChvdXRsaW5lcy5tdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMpIHtcbiAgICAgIGNvbnN0IG1hc2sgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcIm1hc2tcIik7XG4gICAgICBkZWZzLmFwcGVuZChtYXNrKTtcbiAgICAgIG1hc2tJZCA9IGBtYXNrX3Ake3RoaXMucGFnZUluZGV4fV8ke2lkfWA7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcImlkXCIsIG1hc2tJZCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZShcIm1hc2tVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgICAgY29uc3QgcmVjdCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIG1hc2suYXBwZW5kKHJlY3QpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBcIjFcIik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgIGNvbnN0IHVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgICAgbWFzay5hcHBlbmQodXNlKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwibm9uZVwiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwiYmxhY2tcIik7XG4gICAgICB1c2Uuc2V0QXR0cmlidXRlKFwiZmlsbC1ydWxlXCIsIFwibm9uemVyb1wiKTtcbiAgICAgIHVzZS5jbGFzc0xpc3QuYWRkKFwibWFza1wiKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTEpO1xuICAgIHVzZTEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGlmIChtYXNrSWQpIHtcbiAgICAgIHVzZTEuc2V0QXR0cmlidXRlKFwibWFza1wiLCBgdXJsKCMke21hc2tJZH0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHVzZTIgPSB1c2UxLmNsb25lTm9kZSgpO1xuICAgIHJvb3QuYXBwZW5kKHVzZTIpO1xuICAgIHVzZTEuY2xhc3NMaXN0LmFkZChcIm1haW5PdXRsaW5lXCIpO1xuICAgIHVzZTIuY2xhc3NMaXN0LmFkZChcInNlY29uZGFyeU91dGxpbmVcIik7XG4gICAgdGhpcy4jbWFwcGluZy5zZXQoaWQsIHJvb3QpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmaW5hbGl6ZUxpbmUoaWQsIGxpbmUpIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy4jdG9VcGRhdGUuZ2V0KGlkKTtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIHRoaXMudXBkYXRlQm94KGlkLCBsaW5lLmJveCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJkXCIsIGxpbmUudG9TVkdQYXRoKCkpO1xuICB9XG4gIHVwZGF0ZUxpbmUoaWQsIGxpbmUpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy4jbWFwcGluZy5nZXQoaWQpO1xuICAgIGNvbnN0IGRlZnMgPSByb290LmZpcnN0Q2hpbGQ7XG4gICAgY29uc3QgcGF0aCA9IGRlZnMuZmlyc3RDaGlsZDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImRcIiwgbGluZS50b1NWR1BhdGgoKSk7XG4gIH1cbiAgdXBkYXRlUGF0aChpZCwgbGluZSkge1xuICAgIHRoaXMuI3RvVXBkYXRlLmdldChpZCkuc2V0QXR0cmlidXRlKFwiZFwiLCBsaW5lLnRvU1ZHUGF0aCgpKTtcbiAgfVxuICB1cGRhdGVCb3goaWQsIGJveCkge1xuICAgIERyYXdMYXllci4jc2V0Qm94KHRoaXMuI21hcHBpbmcuZ2V0KGlkKSwgYm94KTtcbiAgfVxuICBzaG93KGlkLCB2aXNpYmxlKSB7XG4gICAgdGhpcy4jbWFwcGluZy5nZXQoaWQpLmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2libGUpO1xuICB9XG4gIHJvdGF0ZShpZCwgYW5nbGUpIHtcbiAgICB0aGlzLiNtYXBwaW5nLmdldChpZCkuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIGFuZ2xlKTtcbiAgfVxuICBjaGFuZ2VDb2xvcihpZCwgY29sb3IpIHtcbiAgICB0aGlzLiNtYXBwaW5nLmdldChpZCkuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBjb2xvcik7XG4gIH1cbiAgY2hhbmdlT3BhY2l0eShpZCwgb3BhY2l0eSkge1xuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5zZXRBdHRyaWJ1dGUoXCJmaWxsLW9wYWNpdHlcIiwgb3BhY2l0eSk7XG4gIH1cbiAgYWRkQ2xhc3MoaWQsIGNsYXNzTmFtZSkge1xuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3MoaWQsIGNsYXNzTmFtZSkge1xuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gIH1cbiAgZ2V0U1ZHUm9vdChpZCkge1xuICAgIHJldHVybiB0aGlzLiNtYXBwaW5nLmdldChpZCk7XG4gIH1cbiAgcmVtb3ZlKGlkKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICBpZiAodGhpcy4jcGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5yZW1vdmUoKTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiB0aGlzLiNtYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICByb290LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNtYXBwaW5nLmNsZWFyKCk7XG4gICAgdGhpcy4jdG9VcGRhdGUuY2xlYXIoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvcGRmLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHBkZmpzVmVyc2lvbiA9IFwiNC44LjY5XCI7XG5jb25zdCBwZGZqc0J1aWxkID0gXCIzNjM0ZGFiMTBcIjtcblxudmFyIF9fd2VicGFja19leHBvcnRzX19BYm9ydEV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uQWJvcnRFeGNlcHRpb247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvckxheWVyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JUeXBlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uRWRpdG9yVHlwZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IF9fd2VicGFja19leHBvcnRzX18uQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkxheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uTGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25Nb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Bbm5vdGF0aW9uTW9kZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JQaWNrZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkNvbG9yUGlja2VyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19ET01TVkdGYWN0b3J5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ET01TVkdGYWN0b3J5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19EcmF3TGF5ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkRyYXdMYXllcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRmVhdHVyZVRlc3QgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZlYXR1cmVUZXN0O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HbG9iYWxXb3JrZXJPcHRpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5HbG9iYWxXb3JrZXJPcHRpb25zO1xudmFyIF9fd2VicGFja19leHBvcnRzX19JbWFnZUtpbmQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkltYWdlS2luZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW52YWxpZFBERkV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uSW52YWxpZFBERkV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWlzc2luZ1BERkV4Y2VwdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uTWlzc2luZ1BERkV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fT1BTID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PUFM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX091dHB1dFNjYWxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PdXRwdXRTY2FsZTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGVTdHJpbmcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBERkRhdGVTdHJpbmc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BERldvcmtlciA9IF9fd2VicGFja19leHBvcnRzX18uUERGV29ya2VyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QYXNzd29yZFJlc3BvbnNlcyA9IF9fd2VicGFja19leHBvcnRzX18uUGFzc3dvcmRSZXNwb25zZXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Blcm1pc3Npb25GbGFnID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QZXJtaXNzaW9uRmxhZztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGl4ZWxzUGVySW5jaCA9IF9fd2VicGFja19leHBvcnRzX18uUGl4ZWxzUGVySW5jaDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RleHRMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uVGV4dExheWVyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVXRpbCA9IF9fd2VicGFja19leHBvcnRzX18uVXRpbDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlZlcmJvc2l0eUxldmVsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19YZmFMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uWGZhTGF5ZXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2J1aWxkID0gX193ZWJwYWNrX2V4cG9ydHNfXy5idWlsZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCA9IF9fd2VicGFja19leHBvcnRzX18uY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZmV0Y2hEYXRhID0gX193ZWJwYWNrX2V4cG9ydHNfXy5mZXRjaERhdGE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldERvY3VtZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXREb2N1bWVudDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nZXRGaWxlbmFtZUZyb21Vcmw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCA9IF9fd2VicGFja19leHBvcnRzX18uZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmdldFhmYVBhZ2VWaWV3cG9ydDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pc0RhdGFTY2hlbWU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSA9IF9fd2VicGFja19leHBvcnRzX18uaXNQZGZGaWxlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ub0NvbnRleHRNZW51O1xudmFyIF9fd2VicGFja19leHBvcnRzX19ub3JtYWxpemVVbmljb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ub3JtYWxpemVVbmljb2RlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19zZXRMYXllckRpbWVuc2lvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNldExheWVyRGltZW5zaW9ucztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fc2hhZG93ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zaGFkb3c7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3ZlcnNpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLnZlcnNpb247XG5leHBvcnQgeyBfX3dlYnBhY2tfZXhwb3J0c19fQWJvcnRFeGNlcHRpb24gYXMgQWJvcnRFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIgYXMgQW5ub3RhdGlvbkVkaXRvckxheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgYXMgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVHlwZSBhcyBBbm5vdGF0aW9uRWRpdG9yVHlwZSwgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgYXMgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciwgX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25MYXllciBhcyBBbm5vdGF0aW9uTGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTW9kZSBhcyBBbm5vdGF0aW9uTW9kZSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yUGlja2VyIGFzIENvbG9yUGlja2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fRE9NU1ZHRmFjdG9yeSBhcyBET01TVkdGYWN0b3J5LCBfX3dlYnBhY2tfZXhwb3J0c19fRHJhd0xheWVyIGFzIERyYXdMYXllciwgX193ZWJwYWNrX2V4cG9ydHNfX0ZlYXR1cmVUZXN0IGFzIEZlYXR1cmVUZXN0LCBfX3dlYnBhY2tfZXhwb3J0c19fR2xvYmFsV29ya2VyT3B0aW9ucyBhcyBHbG9iYWxXb3JrZXJPcHRpb25zLCBfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VLaW5kIGFzIEltYWdlS2luZCwgX193ZWJwYWNrX2V4cG9ydHNfX0ludmFsaWRQREZFeGNlcHRpb24gYXMgSW52YWxpZFBERkV4Y2VwdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX01pc3NpbmdQREZFeGNlcHRpb24gYXMgTWlzc2luZ1BERkV4Y2VwdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX09QUyBhcyBPUFMsIF9fd2VicGFja19leHBvcnRzX19PdXRwdXRTY2FsZSBhcyBPdXRwdXRTY2FsZSwgX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGFSYW5nZVRyYW5zcG9ydCBhcyBQREZEYXRhUmFuZ2VUcmFuc3BvcnQsIF9fd2VicGFja19leHBvcnRzX19QREZEYXRlU3RyaW5nIGFzIFBERkRhdGVTdHJpbmcsIF9fd2VicGFja19leHBvcnRzX19QREZXb3JrZXIgYXMgUERGV29ya2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFzc3dvcmRSZXNwb25zZXMgYXMgUGFzc3dvcmRSZXNwb25zZXMsIF9fd2VicGFja19leHBvcnRzX19QZXJtaXNzaW9uRmxhZyBhcyBQZXJtaXNzaW9uRmxhZywgX193ZWJwYWNrX2V4cG9ydHNfX1BpeGVsc1BlckluY2ggYXMgUGl4ZWxzUGVySW5jaCwgX193ZWJwYWNrX2V4cG9ydHNfX1JlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBhcyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24sIF9fd2VicGFja19leHBvcnRzX19UZXh0TGF5ZXIgYXMgVGV4dExheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIGFzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX1V0aWwgYXMgVXRpbCwgX193ZWJwYWNrX2V4cG9ydHNfX1ZlcmJvc2l0eUxldmVsIGFzIFZlcmJvc2l0eUxldmVsLCBfX3dlYnBhY2tfZXhwb3J0c19fWGZhTGF5ZXIgYXMgWGZhTGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19idWlsZCBhcyBidWlsZCwgX193ZWJwYWNrX2V4cG9ydHNfX2NyZWF0ZVZhbGlkQWJzb2x1dGVVcmwgYXMgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCwgX193ZWJwYWNrX2V4cG9ydHNfX2ZldGNoRGF0YSBhcyBmZXRjaERhdGEsIF9fd2VicGFja19leHBvcnRzX19nZXREb2N1bWVudCBhcyBnZXREb2N1bWVudCwgX193ZWJwYWNrX2V4cG9ydHNfX2dldEZpbGVuYW1lRnJvbVVybCBhcyBnZXRGaWxlbmFtZUZyb21VcmwsIF9fd2VicGFja19leHBvcnRzX19nZXRQZGZGaWxlbmFtZUZyb21VcmwgYXMgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLCBfX3dlYnBhY2tfZXhwb3J0c19fZ2V0WGZhUGFnZVZpZXdwb3J0IGFzIGdldFhmYVBhZ2VWaWV3cG9ydCwgX193ZWJwYWNrX2V4cG9ydHNfX2lzRGF0YVNjaGVtZSBhcyBpc0RhdGFTY2hlbWUsIF9fd2VicGFja19leHBvcnRzX19pc1BkZkZpbGUgYXMgaXNQZGZGaWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fbm9Db250ZXh0TWVudSBhcyBub0NvbnRleHRNZW51LCBfX3dlYnBhY2tfZXhwb3J0c19fbm9ybWFsaXplVW5pY29kZSBhcyBub3JtYWxpemVVbmljb2RlLCBfX3dlYnBhY2tfZXhwb3J0c19fc2V0TGF5ZXJEaW1lbnNpb25zIGFzIHNldExheWVyRGltZW5zaW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX3NoYWRvdyBhcyBzaGFkb3csIF9fd2VicGFja19leHBvcnRzX192ZXJzaW9uIGFzIHZlcnNpb24gfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLm1qcy5tYXAiXSwibmFtZXMiOlsiX193ZWJwYWNrX3JlcXVpcmVfXyIsImQiLCJleHBvcnRzIiwiZGVmaW5pdGlvbiIsImtleSIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJvYmoiLCJwcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX193ZWJwYWNrX2V4cG9ydHNfXyIsImdsb2JhbFRoaXMiLCJwZGZqc0xpYiIsIkFib3J0RXhjZXB0aW9uIiwiQW5ub3RhdGlvbkVkaXRvckxheWVyIiwiQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUiLCJBbm5vdGF0aW9uRWRpdG9yVHlwZSIsIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJBbm5vdGF0aW9uTGF5ZXIiLCJBbm5vdGF0aW9uTW9kZSIsIkNvbG9yUGlja2VyIiwiRE9NU1ZHRmFjdG9yeSIsIkRyYXdMYXllciIsIkZlYXR1cmVUZXN0IiwidXRpbF9GZWF0dXJlVGVzdCIsIkdsb2JhbFdvcmtlck9wdGlvbnMiLCJJbWFnZUtpbmQiLCJ1dGlsX0ltYWdlS2luZCIsIkludmFsaWRQREZFeGNlcHRpb24iLCJNaXNzaW5nUERGRXhjZXB0aW9uIiwiT1BTIiwiT3V0cHV0U2NhbGUiLCJQREZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJQREZEYXRlU3RyaW5nIiwiUERGV29ya2VyIiwiUGFzc3dvcmRSZXNwb25zZXMiLCJQZXJtaXNzaW9uRmxhZyIsIlBpeGVsc1BlckluY2giLCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24iLCJUZXh0TGF5ZXIiLCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24iLCJVdGlsIiwiVmVyYm9zaXR5TGV2ZWwiLCJYZmFMYXllciIsImJ1aWxkIiwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsImZldGNoRGF0YSIsImdldERvY3VtZW50IiwiZ2V0RmlsZW5hbWVGcm9tVXJsIiwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsIiwiZ2V0WGZhUGFnZVZpZXdwb3J0IiwiaXNEYXRhU2NoZW1lIiwiaXNQZGZGaWxlIiwibm9Db250ZXh0TWVudSIsIm5vcm1hbGl6ZVVuaWNvZGUiLCJzZXRMYXllckRpbWVuc2lvbnMiLCJzaGFkb3ciLCJ2ZXJzaW9uIiwiaXNOb2RlSlMiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJudyIsImVsZWN0cm9uIiwidHlwZSIsIklERU5USVRZX01BVFJJWCIsIkZPTlRfSURFTlRJVFlfTUFUUklYIiwiTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUiLCJMSU5FX0ZBQ1RPUiIsIkxJTkVfREVTQ0VOVF9GQUNUT1IiLCJCQVNFTElORV9GQUNUT1IiLCJSZW5kZXJpbmdJbnRlbnRGbGFnIiwiQU5ZIiwiRElTUExBWSIsIlBSSU5UIiwiU0FWRSIsIkFOTk9UQVRJT05TX0ZPUk1TIiwiQU5OT1RBVElPTlNfU1RPUkFHRSIsIkFOTk9UQVRJT05TX0RJU0FCTEUiLCJJU19FRElUSU5HIiwiT1BMSVNUIiwiRElTQUJMRSIsIkVOQUJMRSIsIkVOQUJMRV9GT1JNUyIsIkVOQUJMRV9TVE9SQUdFIiwiQW5ub3RhdGlvbkVkaXRvclByZWZpeCIsIk5PTkUiLCJGUkVFVEVYVCIsIkhJR0hMSUdIVCIsIlNUQU1QIiwiSU5LIiwiUkVTSVpFIiwiQ1JFQVRFIiwiRlJFRVRFWFRfU0laRSIsIkZSRUVURVhUX0NPTE9SIiwiRlJFRVRFWFRfT1BBQ0lUWSIsIklOS19DT0xPUiIsIklOS19USElDS05FU1MiLCJJTktfT1BBQ0lUWSIsIkhJR0hMSUdIVF9DT0xPUiIsIkhJR0hMSUdIVF9ERUZBVUxUX0NPTE9SIiwiSElHSExJR0hUX1RISUNLTkVTUyIsIkhJR0hMSUdIVF9GUkVFIiwiSElHSExJR0hUX1NIT1dfQUxMIiwiTU9ESUZZX0NPTlRFTlRTIiwiQ09QWSIsIk1PRElGWV9BTk5PVEFUSU9OUyIsIkZJTExfSU5URVJBQ1RJVkVfRk9STVMiLCJDT1BZX0ZPUl9BQ0NFU1NJQklMSVRZIiwiQVNTRU1CTEUiLCJQUklOVF9ISUdIX1FVQUxJVFkiLCJUZXh0UmVuZGVyaW5nTW9kZSIsIkZJTEwiLCJTVFJPS0UiLCJGSUxMX1NUUk9LRSIsIklOVklTSUJMRSIsIkZJTExfQUREX1RPX1BBVEgiLCJTVFJPS0VfQUREX1RPX1BBVEgiLCJGSUxMX1NUUk9LRV9BRERfVE9fUEFUSCIsIkFERF9UT19QQVRIIiwiRklMTF9TVFJPS0VfTUFTSyIsIkFERF9UT19QQVRIX0ZMQUciLCJHUkFZU0NBTEVfMUJQUCIsIlJHQl8yNEJQUCIsIlJHQkFfMzJCUFAiLCJBbm5vdGF0aW9uVHlwZSIsIlRFWFQiLCJMSU5LIiwiTElORSIsIlNRVUFSRSIsIkNJUkNMRSIsIlBPTFlHT04iLCJQT0xZTElORSIsIlVOREVSTElORSIsIlNRVUlHR0xZIiwiU1RSSUtFT1VUIiwiQ0FSRVQiLCJQT1BVUCIsIkZJTEVBVFRBQ0hNRU5UIiwiU09VTkQiLCJNT1ZJRSIsIldJREdFVCIsIlNDUkVFTiIsIlBSSU5URVJNQVJLIiwiVFJBUE5FVCIsIldBVEVSTUFSSyIsIlRIUkVFRCIsIlJFREFDVCIsIkFubm90YXRpb25SZXBseVR5cGUiLCJHUk9VUCIsIlJFUExZIiwiQW5ub3RhdGlvbkZsYWciLCJISURERU4iLCJOT1pPT00iLCJOT1JPVEFURSIsIk5PVklFVyIsIlJFQURPTkxZIiwiTE9DS0VEIiwiVE9HR0xFTk9WSUVXIiwiTE9DS0VEQ09OVEVOVFMiLCJBbm5vdGF0aW9uRmllbGRGbGFnIiwiUkVRVUlSRUQiLCJOT0VYUE9SVCIsIk1VTFRJTElORSIsIlBBU1NXT1JEIiwiTk9UT0dHTEVUT09GRiIsIlJBRElPIiwiUFVTSEJVVFRPTiIsIkNPTUJPIiwiRURJVCIsIlNPUlQiLCJGSUxFU0VMRUNUIiwiTVVMVElTRUxFQ1QiLCJET05PVFNQRUxMQ0hFQ0siLCJET05PVFNDUk9MTCIsIkNPTUIiLCJSSUNIVEVYVCIsIlJBRElPU0lOVU5JU09OIiwiQ09NTUlUT05TRUxDSEFOR0UiLCJBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlIiwiU09MSUQiLCJEQVNIRUQiLCJCRVZFTEVEIiwiSU5TRVQiLCJBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlIiwiRSIsIlgiLCJEIiwiVSIsIkZvIiwiQmwiLCJQTyIsIlBDIiwiUFYiLCJQSSIsIksiLCJGIiwiViIsIkMiLCJEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSIsIldDIiwiV1MiLCJEUyIsIldQIiwiRFAiLCJQYWdlQWN0aW9uRXZlbnRUeXBlIiwiTyIsIkVSUk9SUyIsIldBUk5JTkdTIiwiSU5GT1MiLCJkZXBlbmRlbmN5Iiwic2V0TGluZVdpZHRoIiwic2V0TGluZUNhcCIsInNldExpbmVKb2luIiwic2V0TWl0ZXJMaW1pdCIsInNldERhc2giLCJzZXRSZW5kZXJpbmdJbnRlbnQiLCJzZXRGbGF0bmVzcyIsInNldEdTdGF0ZSIsInNhdmUiLCJyZXN0b3JlIiwidHJhbnNmb3JtIiwibW92ZVRvIiwibGluZVRvIiwiY3VydmVUbyIsImN1cnZlVG8yIiwiY3VydmVUbzMiLCJjbG9zZVBhdGgiLCJyZWN0YW5nbGUiLCJzdHJva2UiLCJjbG9zZVN0cm9rZSIsImZpbGwiLCJlb0ZpbGwiLCJmaWxsU3Ryb2tlIiwiZW9GaWxsU3Ryb2tlIiwiY2xvc2VGaWxsU3Ryb2tlIiwiY2xvc2VFT0ZpbGxTdHJva2UiLCJlbmRQYXRoIiwiY2xpcCIsImVvQ2xpcCIsImJlZ2luVGV4dCIsImVuZFRleHQiLCJzZXRDaGFyU3BhY2luZyIsInNldFdvcmRTcGFjaW5nIiwic2V0SFNjYWxlIiwic2V0TGVhZGluZyIsInNldEZvbnQiLCJzZXRUZXh0UmVuZGVyaW5nTW9kZSIsInNldFRleHRSaXNlIiwibW92ZVRleHQiLCJzZXRMZWFkaW5nTW92ZVRleHQiLCJzZXRUZXh0TWF0cml4IiwibmV4dExpbmUiLCJzaG93VGV4dCIsInNob3dTcGFjZWRUZXh0IiwibmV4dExpbmVTaG93VGV4dCIsIm5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0Iiwic2V0Q2hhcldpZHRoIiwic2V0Q2hhcldpZHRoQW5kQm91bmRzIiwic2V0U3Ryb2tlQ29sb3JTcGFjZSIsInNldEZpbGxDb2xvclNwYWNlIiwic2V0U3Ryb2tlQ29sb3IiLCJzZXRTdHJva2VDb2xvck4iLCJzZXRGaWxsQ29sb3IiLCJzZXRGaWxsQ29sb3JOIiwic2V0U3Ryb2tlR3JheSIsInNldEZpbGxHcmF5Iiwic2V0U3Ryb2tlUkdCQ29sb3IiLCJzZXRGaWxsUkdCQ29sb3IiLCJzZXRTdHJva2VDTVlLQ29sb3IiLCJzZXRGaWxsQ01ZS0NvbG9yIiwic2hhZGluZ0ZpbGwiLCJiZWdpbklubGluZUltYWdlIiwiYmVnaW5JbWFnZURhdGEiLCJlbmRJbmxpbmVJbWFnZSIsInBhaW50WE9iamVjdCIsIm1hcmtQb2ludCIsIm1hcmtQb2ludFByb3BzIiwiYmVnaW5NYXJrZWRDb250ZW50IiwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHMiLCJlbmRNYXJrZWRDb250ZW50IiwiYmVnaW5Db21wYXQiLCJlbmRDb21wYXQiLCJwYWludEZvcm1YT2JqZWN0QmVnaW4iLCJwYWludEZvcm1YT2JqZWN0RW5kIiwiYmVnaW5Hcm91cCIsImVuZEdyb3VwIiwiYmVnaW5Bbm5vdGF0aW9uIiwiZW5kQW5ub3RhdGlvbiIsInBhaW50SW1hZ2VNYXNrWE9iamVjdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwIiwicGFpbnRJbWFnZVhPYmplY3QiLCJwYWludElubGluZUltYWdlWE9iamVjdCIsInBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAiLCJwYWludEltYWdlWE9iamVjdFJlcGVhdCIsInBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdCIsInBhaW50U29saWRDb2xvckltYWdlTWFzayIsImNvbnN0cnVjdFBhdGgiLCJzZXRTdHJva2VUcmFuc3BhcmVudCIsInNldEZpbGxUcmFuc3BhcmVudCIsIk5FRURfUEFTU1dPUkQiLCJJTkNPUlJFQ1RfUEFTU1dPUkQiLCJ2ZXJib3NpdHkiLCJzZXRWZXJib3NpdHlMZXZlbCIsImxldmVsIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiZ2V0VmVyYm9zaXR5TGV2ZWwiLCJpbmZvIiwibXNnIiwiY29uc29sZSIsImxvZyIsIndhcm4iLCJ1bnJlYWNoYWJsZSIsIkVycm9yIiwiYXNzZXJ0IiwiY29uZCIsIl9pc1ZhbGlkUHJvdG9jb2wiLCJ1cmwiLCJwcm90b2NvbCIsImJhc2VVcmwiLCJvcHRpb25zIiwiYWRkRGVmYXVsdFByb3RvY29sIiwic3RhcnRzV2l0aCIsImRvdHMiLCJtYXRjaCIsImxlbmd0aCIsInRyeUNvbnZlcnRFbmNvZGluZyIsInN0cmluZ1RvVVRGOFN0cmluZyIsImFic29sdXRlVXJsIiwiVVJMIiwidmFsdWUiLCJub25TZXJpYWxpemFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIkJhc2VFeGNlcHRpb24iLCJCYXNlRXhjZXB0aW9uQ2xvc3VyZSIsIm1lc3NhZ2UiLCJuYW1lIiwiY29uc3RydWN0b3IiLCJQYXNzd29yZEV4Y2VwdGlvbiIsImNvZGUiLCJVbmtub3duRXJyb3JFeGNlcHRpb24iLCJkZXRhaWxzIiwic3RhdHVzIiwiRm9ybWF0RXJyb3IiLCJieXRlc1RvU3RyaW5nIiwiYnl0ZXMiLCJ1bmRlZmluZWQiLCJNQVhfQVJHVU1FTlRfQ09VTlQiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJhcHBseSIsInN0ckJ1ZiIsImkiLCJjaHVua0VuZCIsIk1hdGgiLCJtaW4iLCJjaHVuayIsInN1YmFycmF5IiwicHVzaCIsImpvaW4iLCJzdHJpbmdUb0J5dGVzIiwic3RyIiwiVWludDhBcnJheSIsImNoYXJDb2RlQXQiLCJzdHJpbmczMiIsIm9iamVjdFNpemUiLCJrZXlzIiwib2JqZWN0RnJvbU1hcCIsIm1hcCIsImNyZWF0ZSIsImlzTGl0dGxlRW5kaWFuIiwiYnVmZmVyOCIsInZpZXczMiIsIlVpbnQzMkFycmF5IiwiYnVmZmVyIiwiaXNFdmFsU3VwcG9ydGVkIiwiRnVuY3Rpb24iLCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCIsIk9mZnNjcmVlbkNhbnZhcyIsInBsYXRmb3JtIiwibmF2aWdhdG9yIiwiaXNNYWMiLCJpbmNsdWRlcyIsImlzV2luZG93cyIsImlzRmlyZWZveCIsInVzZXJBZ2VudCIsImlzQ1NTUm91bmRTdXBwb3J0ZWQiLCJDU1MiLCJzdXBwb3J0cyIsImhleE51bWJlcnMiLCJBcnJheSIsImZyb20iLCJuIiwidG9TdHJpbmciLCJwYWRTdGFydCIsIm1ha2VIZXhDb2xvciIsInIiLCJnIiwiYiIsInNjYWxlTWluTWF4IiwibWluTWF4IiwidGVtcCIsIm0xIiwibTIiLCJhcHBseVRyYW5zZm9ybSIsInAiLCJtIiwieHQiLCJ5dCIsImFwcGx5SW52ZXJzZVRyYW5zZm9ybSIsImdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94IiwicDEiLCJwMiIsInNsaWNlIiwicDMiLCJwNCIsIm1heCIsImludmVyc2VUcmFuc2Zvcm0iLCJzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSIsInRyYW5zcG9zZSIsImEiLCJjIiwiZmlyc3QiLCJzZWNvbmQiLCJzcXJ0Iiwic3giLCJzeSIsIm5vcm1hbGl6ZVJlY3QiLCJyZWN0IiwiaW50ZXJzZWN0IiwicmVjdDEiLCJyZWN0MiIsInhMb3ciLCJ4SGlnaCIsInlMb3ciLCJ5SGlnaCIsImdldEV4dHJlbXVtT25DdXJ2ZSIsIngwIiwieDEiLCJ4MiIsIngzIiwieTAiLCJ5MSIsInkyIiwieTMiLCJ0IiwibXQiLCJ0dCIsInR0dCIsIngiLCJ5IiwiZ2V0RXh0cmVtdW0iLCJhYnMiLCJkZWx0YSIsInNxcnREZWx0YSIsImEyIiwiYmV6aWVyQm91bmRpbmdCb3giLCJQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSIsInN0cmluZ1RvUERGU3RyaW5nIiwiZW5jb2RpbmciLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJmYXRhbCIsImRlY29kZWQiLCJkZWNvZGUiLCJyZXBsYWNlQWxsIiwiZXgiLCJpaSIsImNoYXJDb2RlIiwiY2hhckF0IiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiZXNjYXBlIiwidXRmOFN0cmluZ1RvU3RyaW5nIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJpc0FycmF5RXF1YWwiLCJhcnIxIiwiYXJyMiIsImdldE1vZGlmaWNhdGlvbkRhdGUiLCJkYXRlIiwiRGF0ZSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsIk5vcm1hbGl6ZVJlZ2V4IiwiTm9ybWFsaXphdGlvbk1hcCIsIk1hcCIsIl8iLCJub3JtYWxpemUiLCJnZXRVdWlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImJ1ZiIsImdldFJhbmRvbVZhbHVlcyIsImZsb29yIiwicmFuZG9tIiwiQW5ub3RhdGlvblByZWZpeCIsIkZvbnRSZW5kZXJPcHMiLCJCRVpJRVJfQ1VSVkVfVE8iLCJNT1ZFX1RPIiwiTElORV9UTyIsIlFVQURSQVRJQ19DVVJWRV9UTyIsIlJFU1RPUkUiLCJTQ0FMRSIsIlRSQU5TRk9STSIsIlRSQU5TTEFURSIsInRvSGV4VXRpbCIsImFyciIsInRvSGV4IiwibnVtIiwidG9CYXNlNjRVdGlsIiwidG9CYXNlNjQiLCJidG9hIiwiZnJvbUJhc2U2NFV0aWwiLCJmcm9tQmFzZTY0IiwiYXRvYiIsIlNWR19OUyIsIlBERiIsIlBERl9UT19DU1NfVU5JVFMiLCJpc1ZhbGlkRmV0Y2hVcmwiLCJkb2N1bWVudCIsImJhc2VVUkkiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJzdGF0dXNUZXh0IiwiYXJyYXlCdWZmZXIiLCJibG9iIiwianNvbiIsInRleHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwiRE9ORSIsInJlc3BvbnNlVGV4dCIsInNlbmQiLCJQYWdlVmlld3BvcnQiLCJ2aWV3Qm94Iiwic2NhbGUiLCJyb3RhdGlvbiIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZG9udEZsaXAiLCJjZW50ZXJYIiwiY2VudGVyWSIsInJvdGF0ZUEiLCJyb3RhdGVCIiwicm90YXRlQyIsInJvdGF0ZUQiLCJvZmZzZXRDYW52YXNYIiwib2Zmc2V0Q2FudmFzWSIsIndpZHRoIiwiaGVpZ2h0IiwicmF3RGltcyIsInBhZ2VXaWR0aCIsInBhZ2VIZWlnaHQiLCJwYWdlWCIsInBhZ2VZIiwiY2xvbmUiLCJjb252ZXJ0VG9WaWV3cG9ydFBvaW50IiwiY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUiLCJ0b3BMZWZ0IiwiYm90dG9tUmlnaHQiLCJjb252ZXJ0VG9QZGZQb2ludCIsImV4dHJhRGVsYXkiLCJ0cmltIiwic3Vic3RyaW5nIiwidG9Mb3dlckNhc2UiLCJmaWxlbmFtZSIsInRlc3QiLCJzcGxpdCIsImxhc3RJbmRleE9mIiwiZGVmYXVsdEZpbGVuYW1lIiwicmVVUkkiLCJyZUZpbGVuYW1lIiwic3BsaXRVUkkiLCJleGVjIiwic3VnZ2VzdGVkRmlsZW5hbWUiLCJTdGF0VGltZXIiLCJ0aW1lIiwic3RhcnRlZCIsIm5vdyIsInRpbWVFbmQiLCJ0aW1lcyIsInN0YXJ0IiwiZW5kIiwib3V0QnVmIiwibG9uZ2VzdCIsInBhZEVuZCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImRlcHJlY2F0ZWQiLCJyZWdleCIsInRvRGF0ZU9iamVjdCIsImlucHV0IiwiUmVnRXhwIiwibWF0Y2hlcyIsInllYXIiLCJwYXJzZUludCIsIm1vbnRoIiwiZGF5IiwiaG91ciIsIm1pbnV0ZSIsInVuaXZlcnNhbFRpbWVSZWxhdGlvbiIsIm9mZnNldEhvdXIiLCJvZmZzZXRNaW51dGUiLCJVVEMiLCJ4ZmFQYWdlIiwiYXR0cmlidXRlcyIsInN0eWxlIiwiZ2V0UkdCIiwiY29sb3IiLCJjb2xvclJHQiIsImdldENvbG9yVmFsdWVzIiwiY29sb3JzIiwic3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJ2aXNpYmlsaXR5IiwiYm9keSIsImFwcGVuZCIsImNvbXB1dGVkQ29sb3IiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwic2V0IiwicmVtb3ZlIiwiZ2V0Q3VycmVudFRyYW5zZm9ybSIsImN0eCIsImYiLCJnZXRUcmFuc2Zvcm0iLCJnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSIsImludmVydFNlbGYiLCJkaXYiLCJ2aWV3cG9ydCIsIm11c3RGbGlwIiwibXVzdFJvdGF0ZSIsInVzZVJvdW5kIiwidyIsImgiLCJ3aWR0aFN0ciIsImhlaWdodFN0ciIsInNldEF0dHJpYnV0ZSIsInBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwic2NhbGVkIiwic3ltbWV0cmljIiwiRWRpdG9yVG9vbGJhciIsInRvb2xiYXIiLCJjb2xvclBpY2tlciIsImVkaXRvciIsImJ1dHRvbnMiLCJhbHRUZXh0IiwibDEwblJlbW92ZSIsImZyZWV6ZSIsImZyZWV0ZXh0IiwiaGlnaGxpZ2h0IiwiaW5rIiwic3RhbXAiLCJyZW5kZXIiLCJlZGl0VG9vbGJhciIsImNsYXNzTGlzdCIsImFkZCIsInNpZ25hbCIsIl91aU1hbmFnZXIiLCJfc2lnbmFsIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBvaW50ZXJEb3duIiwiY2xhc3NOYW1lIiwicG9zaXRpb24iLCJ0b29sYmFyUG9zaXRpb24iLCJkaXJlY3Rpb24iLCJpbnNldElubGluZUVuZCIsInRvcCIsImFkZERlbGV0ZUJ1dHRvbiIsInN0b3BQcm9wYWdhdGlvbiIsImZvY3VzSW4iLCJfZm9jdXNFdmVudHNBbGxvd2VkIiwiZm9jdXNPdXQiLCJhZGRMaXN0ZW5lcnNUb0VsZW1lbnQiLCJlbGVtZW50IiwiYmluZCIsImNhcHR1cmUiLCJoaWRlIiwiaGlkZURyb3Bkb3duIiwic2hvdyIsInNob3duIiwiZWRpdG9yVHlwZSIsImJ1dHRvbiIsInRhYkluZGV4IiwiZGVsZXRlIiwiZGl2aWRlciIsImFkZEFsdFRleHQiLCJwcmVwZW5kIiwiYWRkQ29sb3JQaWNrZXIiLCJyZW5kZXJCdXR0b24iLCJkZXN0cm95IiwiSGlnaGxpZ2h0VG9vbGJhciIsInVpTWFuYWdlciIsImFkZEhpZ2hsaWdodEJ1dHRvbiIsImdldExhc3RQb2ludCIsImJveGVzIiwiaXNMVFIiLCJsYXN0WSIsImxhc3RYIiwiYm94IiwicGFyZW50IiwiaGlnaGxpZ2h0U2VsZWN0aW9uIiwiYmluZEV2ZW50cyIsIm5hbWVzIiwib3BhY2l0eVRvSGV4Iiwib3BhY2l0eSIsInJvdW5kIiwiSWRNYW5hZ2VyIiwiaWQiLCJJbWFnZU1hbmFnZXIiLCJiYXNlSWQiLCJjYWNoZSIsIl9pc1NWR0ZpdHRpbmdDYW52YXMiLCJzdmciLCJjYW52YXMiLCJnZXRDb250ZXh0Iiwid2lsbFJlYWRGcmVxdWVudGx5IiwiaW1hZ2UiLCJJbWFnZSIsInNyYyIsInByb21pc2UiLCJ0aGVuIiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsInJhd0RhdGEiLCJiaXRtYXAiLCJyZWZDb3VudGVyIiwiaXNTdmciLCJGaWxlIiwiZmlsZSIsIkJsb2IiLCJtdXN0UmVtb3ZlQXNwZWN0UmF0aW9Qcm9taXNlIiwiZmlsZVJlYWRlciIsIkZpbGVSZWFkZXIiLCJpbWFnZUVsZW1lbnQiLCJpbWFnZVByb21pc2UiLCJvbmxvYWQiLCJzdmdVcmwiLCJyZXN1bHQiLCJvbmVycm9yIiwicmVhZEFzRGF0YVVSTCIsImNyZWF0ZUltYWdlQml0bWFwIiwiZXJyb3IiLCJnZXRGcm9tRmlsZSIsImxhc3RNb2RpZmllZCIsInNpemUiLCJnZXRGcm9tVXJsIiwiZ2V0RnJvbUJsb2IiLCJibG9iUHJvbWlzZSIsImdldEZyb21JZCIsImdldEZyb21DYW52YXMiLCJvZmZzY3JlZW4iLCJ0cmFuc2ZlclRvSW1hZ2VCaXRtYXAiLCJnZXRTdmdVcmwiLCJkZWxldGVJZCIsInRyYW5zZmVyRnJvbUltYWdlQml0bWFwIiwiY29udmVydFRvQmxvYiIsImNsb3NlIiwiaXNWYWxpZElkIiwiQ29tbWFuZE1hbmFnZXIiLCJjb21tYW5kcyIsImxvY2tlZCIsIm1heFNpemUiLCJjbWQiLCJ1bmRvIiwicG9zdCIsIm11c3RFeGVjIiwiTmFOIiwib3ZlcndyaXRlSWZTYW1lVHlwZSIsImtlZXBVbmRvIiwibmV4dCIsInNwbGljZSIsInJlZG8iLCJoYXNTb21ldGhpbmdUb1VuZG8iLCJoYXNTb21ldGhpbmdUb1JlZG8iLCJLZXlib2FyZE1hbmFnZXIiLCJjYWxsYmFja3MiLCJhbGxLZXlzIiwiU2V0IiwiY2FsbGJhY2siLCJpc01hY0tleSIsImF0Iiwic2VyaWFsaXplIiwiZXZlbnQiLCJhbHRLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5Iiwic2VsZiIsImhhcyIsImJ1YmJsZXMiLCJhcmdzIiwiY2hlY2tlciIsIkNvbG9yTWFuYWdlciIsIl9jb2xvcnNNYXBwaW5nIiwiX2NvbG9ycyIsImNvbnZlcnQiLCJyZ2IiLCJtYXRjaE1lZGlhIiwiUkdCIiwiZXZlcnkiLCJnZXRIZXhDb2RlIiwiYWJvcnRDb250cm9sbGVyIiwiYWN0aXZlRWRpdG9yIiwiYWxsRWRpdG9ycyIsImFsbExheWVycyIsImFsdFRleHRNYW5hZ2VyIiwiYW5ub3RhdGlvblN0b3JhZ2UiLCJjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucyIsImNvbW1hbmRNYW5hZ2VyIiwiY29weVBhc3RlQUMiLCJjdXJyZW50UGFnZUluZGV4IiwiZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyIsImRyYWdnaW5nRWRpdG9ycyIsImVkaXRvclR5cGVzIiwiZWRpdG9yc1RvUmVzY2FsZSIsImVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uIiwiZW5hYmxlVXBkYXRlZEFkZEltYWdlIiwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSIsImZpbHRlckZhY3RvcnkiLCJmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQiLCJmb2N1c01hbmFnZXJBQyIsImhpZ2hsaWdodENvbG9ycyIsImhpZ2hsaWdodFdoZW5TaGlmdFVwIiwiaGlnaGxpZ2h0VG9vbGJhciIsImlkTWFuYWdlciIsImlzRW5hYmxlZCIsImlzV2FpdGluZyIsImtleWJvYXJkTWFuYWdlckFDIiwibGFzdEFjdGl2ZUVsZW1lbnQiLCJtYWluSGlnaGxpZ2h0Q29sb3JQaWNrZXIiLCJtbE1hbmFnZXIiLCJtb2RlIiwic2VsZWN0ZWRFZGl0b3JzIiwic2VsZWN0ZWRUZXh0Tm9kZSIsInBhZ2VDb2xvcnMiLCJzaG93QWxsU3RhdGVzIiwicHJldmlvdXNTdGF0ZXMiLCJ0cmFuc2xhdGlvbiIsInRyYW5zbGF0aW9uVGltZW91dElkIiwiY29udGFpbmVyIiwidmlld2VyIiwidXBkYXRlTW9kZUNhcGFiaWxpdHkiLCJUUkFOU0xBVEVfU01BTEwiLCJUUkFOU0xBVEVfQklHIiwiX2tleWJvYXJkTWFuYWdlciIsInByb3RvIiwiYXJyb3dDaGVja2VyIiwiY29udGFpbnMiLCJhY3RpdmVFbGVtZW50IiwidGFnTmFtZSIsImhhc1NvbWV0aGluZ1RvQ29udHJvbCIsInRleHRJbnB1dENoZWNrZXIiLCJfc2VsZiIsInRhcmdldCIsImVsIiwiSFRNTElucHV0RWxlbWVudCIsInNtYWxsIiwiYmlnIiwic2VsZWN0QWxsIiwiYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkIiwiSFRNTEJ1dHRvbkVsZW1lbnQiLCJpc0VudGVySGFuZGxlZCIsInVuc2VsZWN0QWxsIiwidHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzIiwiZXZlbnRCdXMiLCJwZGZEb2N1bWVudCIsIkFib3J0Q29udHJvbGxlciIsImlzRWRpdGluZyIsImlzRW1wdHkiLCJoYXNTZWxlY3RlZEVkaXRvciIsImhhc1NlbGVjdGVkVGV4dCIsIl9ldmVudEJ1cyIsIl9vbiIsIm9uRWRpdGluZ0FjdGlvbiIsIm9uUGFnZUNoYW5naW5nIiwib25TY2FsZUNoYW5naW5nIiwib25Sb3RhdGlvbkNoYW5naW5nIiwib25TZXRQcmVmZXJlbmNlIiwiZXZ0IiwidXBkYXRlUGFyYW1zIiwiYWRkU2VsZWN0aW9uTGlzdGVuZXIiLCJhZGREcmFnQW5kRHJvcExpc3RlbmVycyIsImFkZEtleWJvYXJkTWFuYWdlciIsInZpZXdQYXJhbWV0ZXJzIiwicmVhbFNjYWxlIiwiaXNTaGlmdEtleURvd24iLCJhYm9ydCIsImxheWVyIiwidmFsdWVzIiwiY2xlYXIiLCJjbGVhclRpbWVvdXQiLCJjb21iaW5lZFNpZ25hbCIsImFjIiwiQWJvcnRTaWduYWwiLCJhbnkiLCJ1c2VOZXdBbHRUZXh0RmxvdyIsInVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UiLCJoY21GaWx0ZXIiLCJhZGRIQ01GaWx0ZXIiLCJmb3JlZ3JvdW5kIiwiYmFja2dyb3VuZCIsInBhaXIiLCJoaWdobGlnaHRDb2xvck5hbWVzIiwicmV2ZXJzZSIsInNldE1haW5IaWdobGlnaHRDb2xvclBpY2tlciIsImVkaXRBbHRUZXh0IiwiZmlyc3RUaW1lIiwic3dpdGNoVG9Nb2RlIiwib24iLCJvbmNlIiwiZGlzcGF0Y2giLCJzb3VyY2UiLCJzZXRQcmVmZXJlbmNlIiwicGFnZU51bWJlciIsImZvY3VzTWFpbkNvbnRhaW5lciIsImZvY3VzIiwiZmluZFBhcmVudCIsImxheWVyWCIsImxheWVyWSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRpc2FibGVVc2VyU2VsZWN0IiwidG9nZ2xlIiwiYWRkU2hvdWxkUmVzY2FsZSIsInJlbW92ZVNob3VsZFJlc2NhbGUiLCJjb21taXRPclJlbW92ZSIsInBhZ2VzUm90YXRpb24iLCJnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIlRFWFRfTk9ERSIsInBhcmVudEVsZW1lbnQiLCJnZXRMYXllckZvclRleHRMYXllciIsInRleHRMYXllciIsImN1cnJlbnRMYXllciIsImhhc1RleHRMYXllciIsIm1ldGhvZE9mQ3JlYXRpb24iLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJpc0NvbGxhcHNlZCIsImFuY2hvck9mZnNldCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwiYW5jaG9yRWxlbWVudCIsImNsb3Nlc3QiLCJnZXRTZWxlY3Rpb25Cb3hlcyIsImVtcHR5IiwiaXNOb25lTW9kZSIsImNyZWF0ZUFuZEFkZE5ld0VkaXRvciIsInNob3dBbGxFZGl0b3JzIiwiZGlzcGxheUhpZ2hsaWdodFRvb2xiYXIiLCJhZGRUb0Fubm90YXRpb25TdG9yYWdlIiwic2V0VmFsdWUiLCJzZWxlY3Rpb25DaGFuZ2UiLCJkaXNwYXRjaFVwZGF0ZVN0YXRlcyIsImFjdGl2ZUxheWVyIiwidG9nZ2xlRHJhd2luZyIsInBvaW50ZXJ1cCIsIm9uU2VsZWN0RW5kIiwiYWRkRm9jdXNNYW5hZ2VyIiwiYmx1ciIsInJlbW92ZUZvY3VzTWFuYWdlciIsImhhc1NlbGVjdGlvbiIsImxhc3RFZGl0b3IiLCJrZXlkb3duIiwia2V5dXAiLCJyZW1vdmVLZXlib2FyZE1hbmFnZXIiLCJhZGRDb3B5UGFzdGVMaXN0ZW5lcnMiLCJjb3B5IiwiY3V0IiwicGFzdGUiLCJyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMiLCJkcmFnT3ZlciIsImRyb3AiLCJhZGRFZGl0TGlzdGVuZXJzIiwicmVtb3ZlRWRpdExpc3RlbmVycyIsImRhdGFUcmFuc2ZlciIsIml0ZW1zIiwiaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nIiwiZHJvcEVmZmVjdCIsIml0ZW0iLCJlZGl0b3JzIiwic2VyaWFsaXplZCIsImNsaXBib2FyZERhdGEiLCJzZXREYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImdldERhdGEiLCJwYXJzZSIsImlzQXJyYXkiLCJuZXdFZGl0b3JzIiwiZGVzZXJpYWxpemVkRWRpdG9yIiwiZGVzZXJpYWxpemUiLCJhZGRFZGl0b3JUb0xheWVyIiwic2VsZWN0RWRpdG9ycyIsImFkZENvbW1hbmRzIiwiaXNFZGl0b3JIYW5kbGluZ0tleWJvYXJkIiwiaGFzQ2hhbmdlZCIsImVudHJpZXMiLCJzb21lIiwiYXNzaWduIiwiZGlzcGF0Y2hVcGRhdGVVSSIsInNldEVkaXRpbmdTdGF0ZSIsInJlZ2lzdGVyRWRpdG9yVHlwZXMiLCJ0eXBlcyIsImRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUiLCJnZXRJZCIsImdldExheWVyIiwicGFnZUluZGV4IiwiYWRkTGF5ZXIiLCJlbmFibGUiLCJkaXNhYmxlIiwicmVtb3ZlTGF5ZXIiLCJ1cGRhdGVNb2RlIiwiZWRpdElkIiwiaXNGcm9tS2V5Ym9hcmQiLCJ3aXRoUmVzb2x2ZXJzIiwiZGlzYWJsZUFsbCIsImVuYWJsZUFsbCIsImFubm90YXRpb25FbGVtZW50SWQiLCJzZXRTZWxlY3RlZCIsImVudGVySW5FZGl0TW9kZSIsInVuc2VsZWN0IiwiY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IiLCJhZGROZXdFZGl0b3IiLCJ1cGRhdGVUb29sYmFyIiwidXBkYXRlQ29sb3IiLCJhY3Rpb24iLCJ1cGRhdGVEZWZhdWx0UGFyYW1zIiwidmlzaWJsZSIsInVwZGF0ZUJ1dHRvbiIsInN0YXRlIiwiZW5hYmxlV2FpdGluZyIsIm11c3RXYWl0IiwiZGlzYWJsZUNsaWNrIiwiZW5hYmxlQ2xpY2siLCJwcm9taXNlcyIsImFsbCIsImdldEVkaXRvcnMiLCJnZXRFZGl0b3IiLCJhZGRFZGl0b3IiLCJyZW1vdmVFZGl0b3IiLCJzZXRUaW1lb3V0IiwiYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50IiwiYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbiIsImRlbGV0ZWQiLCJpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsInJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudCIsInJlbW92ZUNoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24iLCJhZGRPclJlYnVpbGQiLCJzZXRBY3RpdmVFZGl0b3IiLCJwcm9wZXJ0aWVzVG9VcGRhdGUiLCJsYXN0U2VsZWN0ZWRFZGl0b3IiLCJlZCIsInVwZGF0ZVVJIiwidG9nZ2xlU2VsZWN0ZWQiLCJzZWxlY3QiLCJpc1NlbGVjdGVkIiwiZmlyc3RTZWxlY3RlZEVkaXRvciIsInBhcmFtcyIsImNvbW1pdCIsIm5vQ29tbWl0IiwidG90YWxYIiwidG90YWxZIiwiVElNRV9UT19XQUlUIiwidHJhbnNsYXRlSW5QYWdlIiwic2V0VXBEcmFnU2Vzc2lvbiIsInNhdmVkWCIsInNhdmVkWSIsInNhdmVkUGFnZUluZGV4IiwibmV3WCIsIm5ld1kiLCJuZXdQYWdlSW5kZXgiLCJlbmREcmFnU2Vzc2lvbiIsIm11c3RCZUFkZGVkSW5VbmRvU3RhY2siLCJtb3ZlIiwiX3NldFBhcmVudEFuZFBvc2l0aW9uIiwiZHJhZ1NlbGVjdGVkRWRpdG9ycyIsInR4IiwidHkiLCJkcmFnIiwicmVidWlsZCIsImNoYW5nZVBhcmVudCIsImdldEFjdGl2ZSIsInNob3VsZEdldEtleWJvYXJkRXZlbnRzIiwiaXNBY3RpdmUiLCJnZXRNb2RlIiwiaW1hZ2VNYW5hZ2VyIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsInBhcmVudFdpZHRoIiwicGFyZW50SGVpZ2h0Iiwicm90YXRvciIsImdldEF0dHJpYnV0ZSIsInJhbmdlIiwiY29sbGFwc2VkIiwiZ2V0Q2xpZW50UmVjdHMiLCJyZW5kZXJBbm5vdGF0aW9uRWxlbWVudCIsImFubm90YXRpb24iLCJlZGl0b3JJZCIsImdldFJhd1ZhbHVlIiwiaGFzQmVlbk1vZGlmaWVkIiwiQWx0VGV4dCIsImFsdFRleHREZWNvcmF0aXZlIiwiYWx0VGV4dEJ1dHRvbiIsImFsdFRleHRCdXR0b25MYWJlbCIsImFsdFRleHRUb29sdGlwIiwiYWx0VGV4dFRvb2x0aXBUaW1lb3V0IiwiYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCIsImJhZGdlIiwiZ3Vlc3NlZFRleHQiLCJ0ZXh0V2l0aERpc2NsYWltZXIiLCJsMTBuTmV3QnV0dG9uIiwiX2wxMG4iLCJhZGRlZCIsIm1pc3NpbmciLCJyZXZpZXciLCJpbml0aWFsaXplIiwibDEwbiIsImxhYmVsIiwib25DbGljayIsIl9yZXBvcnRUZWxlbWV0cnkiLCJzZXRTdGF0ZSIsImZpbmlzaCIsImZvY3VzVmlzaWJsZSIsImhhc0RhdGEiLCJzZXRHdWVzc2VkVGV4dCIsImdlbmVyYXRlZEFsdFRleHQiLCJ0b2dnbGVBbHRUZXh0QmFkZ2UiLCJpc0ZvckNvcHlpbmciLCJkZWNvcmF0aXZlIiwiY2FuY2VsIiwiZW5hYmxlZCIsImRpc2FibGVkIiwidG9vbHRpcCIsIkRFTEFZX1RPX1NIT1dfVE9PTFRJUCIsInJlbW92ZUF0dHJpYnV0ZSIsInRleHRDb250ZW50IiwicGFyZW50Tm9kZSIsImdldEltYWdlRm9yQWx0VGV4dCIsIkFubm90YXRpb25FZGl0b3IiLCJhY2Nlc3NpYmlsaXR5RGF0YSIsImFsbFJlc2l6ZXJEaXZzIiwia2VlcEFzcGVjdFJhdGlvIiwicmVzaXplcnNEaXYiLCJzYXZlZERpbWVuc2lvbnMiLCJmb2N1c0FDIiwiZm9jdXNlZFJlc2l6ZXJOYW1lIiwiaGFzQmVlbkNsaWNrZWQiLCJpbml0aWFsUG9zaXRpb24iLCJpc0luRWRpdE1vZGUiLCJpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQiLCJtb3ZlSW5ET01UaW1lb3V0IiwicHJldkRyYWdYIiwicHJldkRyYWdZIiwidGVsZW1ldHJ5VGltZW91dHMiLCJfbDEwblJlc2l6ZXIiLCJpc0RyYWdnYWJsZSIsInpJbmRleCIsIl9ib3JkZXJMaW5lV2lkdGgiLCJfY29sb3JNYW5hZ2VyIiwiX3pJbmRleCIsIl90ZWxlbWV0cnlUaW1lb3V0IiwiX3Jlc2l6ZXJLZXlib2FyZE1hbmFnZXIiLCJyZXNpemUiLCJfcmVzaXplV2l0aEtleWJvYXJkIiwiX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZCIsInBhcmFtZXRlcnMiLCJfZWRpdFRvb2xiYXIiLCJfaW5pdGlhbE9wdGlvbnMiLCJfaW5pdGlhbERhdGEiLCJfaXNWaXNpYmxlIiwiX3dpbGxLZWVwQXNwZWN0UmF0aW8iLCJpc0NlbnRlcmVkIiwiX3N0cnVjdFRyZWVQYXJlbnRJZCIsInBhZ2VSb3RhdGlvbiIsInBhZ2VEaW1lbnNpb25zIiwicGFnZVRyYW5zbGF0aW9uIiwicGFyZW50RGltZW5zaW9ucyIsImlzQXR0YWNoZWRUb0RPTSIsImdldFByb3RvdHlwZU9mIiwiX3R5cGUiLCJfZGVmYXVsdExpbmVDb2xvciIsImRlbGV0ZUFubm90YXRpb25FbGVtZW50IiwiZmFrZUVkaXRvciIsIkZha2VFZGl0b3IiLCJnZXROZXh0SWQiLCJ0b3BNaWRkbGUiLCJ0b3BSaWdodCIsIm1pZGRsZVJpZ2h0IiwiYm90dG9tTWlkZGxlIiwiYm90dG9tTGVmdCIsIm1pZGRsZUxlZnQiLCJkb2N1bWVudEVsZW1lbnQiLCJwYXJzZUZsb2F0IiwiZ2V0UHJvcGVydHlWYWx1ZSIsIl92YWx1ZSIsIm1pbWUiLCJfaXNEcmFnZ2FibGUiLCJjZW50ZXIiLCJwYXJlbnRSb3RhdGlvbiIsImZpeEFuZFNldFBvc2l0aW9uIiwic2V0SW5CYWNrZ3JvdW5kIiwic2V0SW5Gb3JlZ3JvdW5kIiwic2V0UGFyZW50Iiwic3RvcFJlc2l6aW5nIiwiZm9jdXNpbiIsImZvY3Vzb3V0IiwicmVsYXRlZFRhcmdldCIsImlzTXVsdGlwbGVTZWxlY3Rpb24iLCJzZXRBdCIsInNjcmVlblRvUGFnZVRyYW5zbGF0aW9uIiwidHJhbnNsYXRlIiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsImZpbmROZXdQYXJlbnQiLCJieCIsImJ5IiwiZ2V0QmFzZVRyYW5zbGF0aW9uIiwibGVmdCIsInRvRml4ZWQiLCJfaGFzQmVlbk1vdmVkIiwiX211c3RGaXhQb3NpdGlvbiIsIm1vdmVJbkRPTSIsInJvdGF0ZVBvaW50IiwiYW5nbGUiLCJwYWdlVHJhbnNsYXRpb25Ub1NjcmVlbiIsImdldFJvdGF0aW9uTWF0cml4IiwicGFyZW50U2NhbGUiLCJzZXREaW1zIiwiZml4RGltcyIsIndpZHRoUGVyY2VudCIsImVuZHNXaXRoIiwiaGVpZ2h0UGVyY2VudCIsImdldEluaXRpYWxUcmFuc2xhdGlvbiIsImNyZWF0ZVJlc2l6ZXJzIiwiY2xhc3NlcyIsInJlc2l6ZXJQb2ludGVyZG93biIsInNhdmVkRHJhZ2dhYmxlIiwidG9nZ2xlUG9pbnRlckV2ZW50cyIsInJlc2l6ZXJQb2ludGVybW92ZSIsInBhc3NpdmUiLCJzYXZlZFdpZHRoIiwic2F2ZWRIZWlnaHQiLCJzYXZlZFBhcmVudEN1cnNvciIsImN1cnNvciIsInNhdmVkQ3Vyc29yIiwicG9pbnRlclVwQ2FsbGJhY2siLCJhZGRSZXNpemVUb1VuZG9TdGFjayIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwibWluV2lkdGgiLCJNSU5fU0laRSIsIm1pbkhlaWdodCIsInJvdGF0aW9uTWF0cml4IiwidHJhbnNmIiwiaW52Um90YXRpb25NYXRyaXgiLCJpbnZUcmFuc2YiLCJnZXRQb2ludCIsImdldE9wcG9zaXRlIiwiaXNEaWFnb25hbCIsImlzSG9yaXpvbnRhbCIsInBvaW50Iiwib3Bwb3NpdGVQb2ludCIsInRyYW5zZk9wcG9zaXRlUG9pbnQiLCJvcHBvc2l0ZVgiLCJvcHBvc2l0ZVkiLCJyYXRpb1giLCJyYXRpb1kiLCJkZWx0YVgiLCJkZWx0YVkiLCJtb3ZlbWVudFgiLCJtb3ZlbWVudFkiLCJvbGREaWFnIiwiaHlwb3QiLCJhbHRUZXh0RmluaXNoIiwiYWRkRWRpdFRvb2xiYXIiLCJyZW1vdmVFZGl0VG9vbGJhciIsImFkZENvbnRhaW5lciIsImVkaXRUb29sYmFyRGl2IiwiYmVmb3JlIiwiZ2V0Q2xpZW50RGltZW5zaW9ucyIsImFkZEFsdFRleHRCdXR0b24iLCJhbHRUZXh0RGF0YSIsImd1ZXNzZWRBbHRUZXh0Iiwic2V0R3Vlc3NlZEFsdFRleHQiLCJzZXJpYWxpemVBbHRUZXh0IiwiaGFzQWx0VGV4dCIsImhhc0FsdFRleHREYXRhIiwiYWRkRm9jdXNMaXN0ZW5lcnMiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInBvaW50ZXJkb3duIiwic2VsZWN0T25Qb2ludGVyRXZlbnQiLCJjbGllbnRYIiwiY2xpZW50WSIsInBvaW50ZXJNb3ZlQ2FsbGJhY2siLCJtb3ZlRWRpdG9ySW5ET00iLCJnZXRSZWN0Iiwic2hpZnRYIiwic2hpZnRZIiwiZ2V0UmVjdEluQ3VycmVudENvb3JkcyIsIm9uY2VBZGRlZCIsImVuYWJsZUVkaXRNb2RlIiwiZGlzYWJsZUVkaXRNb2RlIiwibmVlZHNUb0JlUmVidWlsdCIsInJvdGF0ZSIsIl9hbmdsZSIsInNlcmlhbGl6ZURlbGV0ZWQiLCJwb3B1cFJlZiIsImNvbnRleHQiLCJ0aW1lb3V0IiwiaXNSZXNpemFibGUiLCJtYWtlUmVzaXphYmxlIiwiY2hpbGRyZW4iLCJib3VuZFJlc2l6ZXJLZXlkb3duIiwicmVzaXplcktleWRvd24iLCJib3VuZFJlc2l6ZXJCbHVyIiwicmVzaXplckJsdXIiLCJyZXNpemVyRm9jdXMiLCJmaXJzdFBvc2l0aW9uIiwibmV4dEZpcnN0UG9zaXRpb24iLCJmaXJzdENoaWxkIiwibGFzdENoaWxkIiwiY2hpbGQiLCJzZXRSZXNpemVyVGFiSW5kZXgiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmV2ZW50U2Nyb2xsIiwiZGlzYWJsZUVkaXRpbmciLCJlbmFibGVFZGl0aW5nIiwiY29udGVudERpdiIsInNldEFzcGVjdFJhdGlvIiwiYXNwZWN0UmF0aW8iLCJ0ZWxlbWV0cnlJbml0aWFsRGF0YSIsInRlbGVtZXRyeUZpbmFsRGF0YSIsImNvbnRlbnQiLCJxdWVyeVNlbGVjdG9yIiwibm9kZU5hbWUiLCJyZXNldEFubm90YXRpb25FbGVtZW50IiwiU0VFRCIsIk1BU0tfSElHSCIsIk1BU0tfTE9XIiwiTXVybXVySGFzaDNfNjQiLCJzZWVkIiwiaDEiLCJoMiIsInVwZGF0ZSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnl0ZUxlbmd0aCIsImJsb2NrQ291bnRzIiwidGFpbExlbmd0aCIsImRhdGFVaW50MzIiLCJrMSIsImsyIiwiQzEiLCJDMiIsIkMxX0xPVyIsIkMyX0xPVyIsImhleGRpZ2VzdCIsIlNlcmlhbGl6YWJsZUVtcHR5IiwiaGFzaCIsInRyYW5zZmVyIiwiQW5ub3RhdGlvblN0b3JhZ2UiLCJtb2RpZmllZCIsIm1vZGlmaWVkSWRzIiwic3RvcmFnZSIsIm9uU2V0TW9kaWZpZWQiLCJvblJlc2V0TW9kaWZpZWQiLCJvbkFubm90YXRpb25FZGl0b3IiLCJnZXRWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsInJlc2V0TW9kaWZpZWQiLCJlbnRyeSIsInZhbCIsInNldE1vZGlmaWVkIiwiZ2V0QWxsIiwic2V0QWxsIiwicHJpbnQiLCJQcmludEFubm90YXRpb25TdG9yYWdlIiwic2VyaWFsaXphYmxlIiwiaGFzQml0bWFwIiwiZWRpdG9yU3RhdHMiLCJzdGF0cyIsInR5cGVUb0VkaXRvciIsImNvdW50ZXJzIiwiY291bnQiLCJjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhIiwicmVzZXRNb2RpZmllZElkcyIsImlkcyIsInN0cnVjdHVyZWRDbG9uZSIsIkZvbnRMb2FkZXIiLCJzeXN0ZW1Gb250cyIsIm93bmVyRG9jdW1lbnQiLCJzdHlsZUVsZW1lbnQiLCJfZG9jdW1lbnQiLCJuYXRpdmVGb250RmFjZXMiLCJsb2FkaW5nUmVxdWVzdHMiLCJsb2FkVGVzdEZvbnRJZCIsImFkZE5hdGl2ZUZvbnRGYWNlIiwibmF0aXZlRm9udEZhY2UiLCJmb250cyIsInJlbW92ZU5hdGl2ZUZvbnRGYWNlIiwiaW5zZXJ0UnVsZSIsInJ1bGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlU2hlZXQiLCJzaGVldCIsImNzc1J1bGVzIiwibG9hZFN5c3RlbUZvbnQiLCJzeXN0ZW1Gb250SW5mbyIsIl9pbnNwZWN0Rm9udCIsImxvYWRlZE5hbWUiLCJkaXNhYmxlRm9udEZhY2UiLCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkIiwiZm9udEZhY2UiLCJGb250RmFjZSIsImxvYWQiLCJiYXNlRm9udE5hbWUiLCJmb250IiwiYXR0YWNoZWQiLCJtaXNzaW5nRmlsZSIsImNyZWF0ZU5hdGl2ZUZvbnRGYWNlIiwibG9hZGVkIiwiZmFtaWx5IiwiY3JlYXRlRm9udEZhY2VSdWxlIiwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQiLCJfcXVldWVMb2FkaW5nQ2FsbGJhY2siLCJfcHJlcGFyZUZvbnRMb2FkRXZlbnQiLCJoYXNGb250cyIsInN1cHBvcnRlZCIsImNvbXBsZXRlUmVxdWVzdCIsImRvbmUiLCJvdGhlclJlcXVlc3QiLCJzaGlmdCIsImNvbXBsZXRlIiwiX2xvYWRUZXN0Rm9udCIsInRlc3RGb250IiwiaW50MzIiLCJvZmZzZXQiLCJzcGxpY2VTdHJpbmciLCJzIiwiaW5zZXJ0IiwiY2h1bmsxIiwiY2h1bmsyIiwiY2FsbGVkIiwiaXNGb250UmVhZHkiLCJmaWxsVGV4dCIsImltYWdlRGF0YSIsIkNPTU1FTlRfT0ZGU0VUIiwiQ0ZGX0NIRUNLU1VNX09GRlNFVCIsIlhYWFhfVkFMVUUiLCJjaGVja3N1bSIsImZvbnRGYW1pbHkiLCJGb250RmFjZU9iamVjdCIsInRyYW5zbGF0ZWREYXRhIiwiaW5zcGVjdEZvbnQiLCJjb21waWxlZEdseXBocyIsImNzc0ZvbnRJbmZvIiwiY3NzIiwid2VpZ2h0IiwiZm9udFdlaWdodCIsIml0YWxpY0FuZ2xlIiwibWltZXR5cGUiLCJnZXRQYXRoR2VuZXJhdG9yIiwib2JqcyIsImNoYXJhY3RlciIsImNtZHMiLCJiZXppZXJDdXJ2ZVRvIiwicXVhZHJhdGljQ3VydmVUbyIsImdseXBoRHJhd2VyIiwiQmFzZUNhbnZhc0ZhY3RvcnkiLCJlbmFibGVIV0EiLCJfY3JlYXRlQ2FudmFzIiwicmVzZXQiLCJjYW52YXNBbmRDb250ZXh0IiwiRE9NQ2FudmFzRmFjdG9yeSIsIkJhc2VDTWFwUmVhZGVyRmFjdG9yeSIsImlzQ29tcHJlc3NlZCIsIl9mZXRjaCIsImNNYXBEYXRhIiwiY2F0Y2giLCJyZWFzb24iLCJET01DTWFwUmVhZGVyRmFjdG9yeSIsIkJhc2VGaWx0ZXJGYWN0b3J5IiwiYWRkRmlsdGVyIiwibWFwcyIsImZnQ29sb3IiLCJiZ0NvbG9yIiwiYWRkQWxwaGFGaWx0ZXIiLCJhZGRMdW1pbm9zaXR5RmlsdGVyIiwiYWRkSGlnaGxpZ2h0SENNRmlsdGVyIiwiZmlsdGVyTmFtZSIsIm5ld0ZnQ29sb3IiLCJuZXdCZ0NvbG9yIiwia2VlcEhDTSIsIkRPTUZpbHRlckZhY3RvcnkiLCJfY2FjaGUiLCJfZGVmcyIsImRvY0lkIiwiX2hjbUNhY2hlIiwiaGNtQ2FjaGUiLCJkZWZzIiwiY29udGFpbiIsImNyZWF0ZUVsZW1lbnROUyIsImNyZWF0ZVRhYmxlcyIsIm1hcFIiLCJ0YWJsZSIsIm1hcEciLCJtYXBCIiwiYnVmZmVyUiIsImJ1ZmZlckciLCJidWZmZXJCIiwiY3JlYXRlVXJsIiwidGFibGVSIiwidGFibGVHIiwidGFibGVCIiwiZmlsdGVyIiwiY3JlYXRlRmlsdGVyIiwiYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uIiwiZmdSR0IiLCJiZ1JHQiIsImFkZEdyYXlDb252ZXJzaW9uIiwiZ2V0U3RlcHMiLCJ0YWJsZUEiLCJhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbiIsImFkZEx1bWlub3NpdHlDb252ZXJzaW9uIiwiZmdHcmF5IiwiYmdHcmF5IiwibmV3RmdSR0IiLCJuZXdCZ1JHQiIsImZnIiwiYmciLCJzdGVwIiwibmV3U3RhcnQiLCJuZXdTdGVwIiwicHJldiIsImsiLCJqIiwiZmVDb2xvck1hdHJpeCIsImFwcGVuZEZlRnVuYyIsImZlQ29tcG9uZW50VHJhbnNmZXIiLCJmdW5jIiwiZmVGdW5jIiwiclRhYmxlIiwiZ1RhYmxlIiwiYlRhYmxlIiwiYVRhYmxlIiwiQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJwYWNrYWdlQ2FwYWJpbGl0eSIsInBhY2thZ2VNYXAiLCJsb2FkUGFja2FnZXMiLCJmcyIsImh0dHAiLCJodHRwcyIsInBhdGgyZCIsIk5vZGVQYWNrYWdlcyIsIm5vZGVfdXRpbHNfZmV0Y2hEYXRhIiwicmVhZEZpbGUiLCJOb2RlRmlsdGVyRmFjdG9yeSIsIk5vZGVDYW52YXNGYWN0b3J5IiwiY3JlYXRlQ2FudmFzIiwiTm9kZUNNYXBSZWFkZXJGYWN0b3J5IiwiTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IiwiUGF0aFR5cGUiLCJTSEFESU5HIiwiYXBwbHlCb3VuZGluZ0JveCIsImJib3giLCJyZWdpb24iLCJQYXRoMkQiLCJCYXNlU2hhZGluZ1BhdHRlcm4iLCJnZXRQYXR0ZXJuIiwiUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiIsIklSIiwiX2Jib3giLCJfY29sb3JTdG9wcyIsIl9wMCIsIl9wMSIsIl9yMCIsIl9yMSIsIm1hdHJpeCIsIl9jcmVhdGVHcmFkaWVudCIsImdyYWQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiY29sb3JTdG9wIiwiYWRkQ29sb3JTdG9wIiwib3duZXIiLCJpbnZlcnNlIiwicGF0aFR5cGUiLCJwYXR0ZXJuIiwib3duZXJCQm94IiwiY3VycmVudCIsImdldENsaXBwZWRQYXRoQm91bmRpbmdCb3giLCJjZWlsIiwidG1wQ2FudmFzIiwiY2FjaGVkQ2FudmFzZXMiLCJnZXRDYW52YXMiLCJ0bXBDdHgiLCJjbGVhclJlY3QiLCJiZWdpblBhdGgiLCJiYXNlVHJhbnNmb3JtIiwiZmlsbFN0eWxlIiwiY3JlYXRlUGF0dGVybiIsImRvbU1hdHJpeCIsIkRPTU1hdHJpeCIsInNldFRyYW5zZm9ybSIsImRyYXdUcmlhbmdsZSIsImMxIiwiYzIiLCJjMyIsImNvb3JkcyIsInJvd1NpemUiLCJ0bXAiLCJzY2FsZVgiLCJzY2FsZVkiLCJjMXIiLCJjMWciLCJjMWIiLCJjMnIiLCJjMmciLCJjMmIiLCJjM3IiLCJjM2ciLCJjM2IiLCJtaW5ZIiwibWF4WSIsInhhIiwiY2FyIiwiY2FnIiwiY2FiIiwieGIiLCJjYnIiLCJjYmciLCJjYmIiLCJ4MV8iLCJ4Ml8iLCJkcmF3RmlndXJlIiwiZmlndXJlIiwicHMiLCJjcyIsInZlcnRpY2VzUGVyUm93Iiwicm93cyIsImNvbHMiLCJxIiwiTWVzaFNoYWRpbmdQYXR0ZXJuIiwiX2Nvb3JkcyIsIl9maWd1cmVzIiwiX2JvdW5kcyIsIl9iYWNrZ3JvdW5kIiwiX2NyZWF0ZU1lc2hDYW52YXMiLCJjb21iaW5lZFNjYWxlIiwiYmFja2dyb3VuZENvbG9yIiwiRVhQRUNURURfU0NBTEUiLCJNQVhfUEFUVEVSTl9TSVpFIiwiQk9SREVSX1NJWkUiLCJib3VuZHNXaWR0aCIsImJvdW5kc0hlaWdodCIsInBhZGRlZFdpZHRoIiwicGFkZGVkSGVpZ2h0IiwiY3JlYXRlSW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwibWF0cml4U2NhbGUiLCJ0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzIiwiRHVtbXlTaGFkaW5nUGF0dGVybiIsImdldFNoYWRpbmdQYXR0ZXJuIiwiUGFpbnRUeXBlIiwiQ09MT1JFRCIsIlVOQ09MT1JFRCIsIlRpbGluZ1BhdHRlcm4iLCJjYW52YXNHcmFwaGljc0ZhY3RvcnkiLCJvcGVyYXRvckxpc3QiLCJ4c3RlcCIsInlzdGVwIiwicGFpbnRUeXBlIiwidGlsaW5nVHlwZSIsImNyZWF0ZVBhdHRlcm5DYW52YXMiLCJjdXJNYXRyaXhTY2FsZSIsImNvbWJpbmVkU2NhbGVYIiwiY29tYmluZWRTY2FsZVkiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsInJlZHJhd0hvcml6b250YWxseSIsInJlZHJhd1ZlcnRpY2FsbHkiLCJ4U2NhbGVkU3RlcCIsInlTY2FsZWRTdGVwIiwieFNjYWxlZFdpZHRoIiwieVNjYWxlZEhlaWdodCIsImRpbXgiLCJnZXRTaXplQW5kU2NhbGUiLCJkaW15IiwiZ3JhcGhpY3MiLCJjcmVhdGVDYW52YXNHcmFwaGljcyIsImdyb3VwTGV2ZWwiLCJzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQiLCJjbGlwQmJveCIsImV4ZWN1dGVPcGVyYXRvckxpc3QiLCJlbmREcmF3aW5nIiwiZGlteDIiLCJkaW15MiIsInhTaXplIiwieVNpemUiLCJ0bXBDYW52YXMyIiwidG1wQ3R4MiIsImpqIiwicmVhbE91dHB1dFNpemUiLCJiYm94V2lkdGgiLCJiYm94SGVpZ2h0IiwidXBkYXRlUmVjdE1pbk1heCIsInN0cm9rZVN0eWxlIiwiZmlsbENvbG9yIiwic3Ryb2tlQ29sb3IiLCJjc3NDb2xvciIsImNvbnZlcnRUb1JHQkEiLCJraW5kIiwiY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEiLCJjb252ZXJ0UkdCVG9SR0JBIiwic3JjUG9zIiwiZGVzdCIsIm5vbkJsYWNrQ29sb3IiLCJpbnZlcnNlRGVjb2RlIiwiYmxhY2siLCJ6ZXJvTWFwcGluZyIsIm9uZU1hcHBpbmciLCJ3aWR0aEluU291cmNlIiwid2lkdGhSZW1haW5kZXIiLCJzcmNMZW5ndGgiLCJkZXN0UG9zIiwiZWxlbSIsImxlbjMyIiwic3JjMzIiLCJzMSIsInMyIiwiczMiLCJncmF5VG9SR0JBIiwiTUlOX0ZPTlRfU0laRSIsIk1BWF9GT05UX1NJWkUiLCJFWEVDVVRJT05fVElNRSIsIkVYRUNVVElPTl9TVEVQUyIsIk1BWF9TSVpFX1RPX0NPTVBJTEUiLCJGVUxMX0NIVU5LX0hFSUdIVCIsIm1pcnJvckNvbnRleHRPcGVyYXRpb25zIiwiZGVzdEN0eCIsIl9yZW1vdmVNaXJyb3JpbmciLCJfX29yaWdpbmFsU2F2ZSIsIl9fb3JpZ2luYWxSZXN0b3JlIiwiX19vcmlnaW5hbFJvdGF0ZSIsIl9fb3JpZ2luYWxTY2FsZSIsIl9fb3JpZ2luYWxUcmFuc2xhdGUiLCJfX29yaWdpbmFsVHJhbnNmb3JtIiwiX19vcmlnaW5hbFNldFRyYW5zZm9ybSIsIl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSIsInJlc2V0VHJhbnNmb3JtIiwiX19vcmlnaW5hbENsaXAiLCJfX29yaWdpbmFsTW92ZVRvIiwiX19vcmlnaW5hbExpbmVUbyIsIl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvIiwiX19vcmlnaW5hbFJlY3QiLCJfX29yaWdpbmFsQ2xvc2VQYXRoIiwiX19vcmlnaW5hbEJlZ2luUGF0aCIsImN0eFNhdmUiLCJjdHhSZXN0b3JlIiwiY3R4VHJhbnNsYXRlIiwiY3R4U2NhbGUiLCJjdHhUcmFuc2Zvcm0iLCJjdHhTZXRUcmFuc2Zvcm0iLCJjdHhSZXNldFRyYW5zZm9ybSIsImN0eFJvdGF0ZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJDYWNoZWRDYW52YXNlcyIsImNhbnZhc0ZhY3RvcnkiLCJjYW52YXNFbnRyeSIsImRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyIsInNyY0ltZyIsInNyY1giLCJzcmNZIiwic3JjVyIsInNyY0giLCJkZXN0WCIsImRlc3RZIiwiZGVzdFciLCJkZXN0SCIsInRsWCIsInJUbFgiLCJ0bFkiLCJyVGxZIiwiYnJYIiwicldpZHRoIiwiYnJZIiwickhlaWdodCIsInNpZ24iLCJjb21waWxlVHlwZTNHbHlwaCIsImltZ0RhdGEiLCJQT0lOVF9UT19QUk9DRVNTX0xJTUlUIiwiUE9JTlRfVFlQRVMiLCJ3aWR0aDEiLCJwb2ludHMiLCJqMCIsImxpbmVTaXplIiwicG9zIiwibWFzayIsInN1bSIsInN0ZXBzIiwiSW50MzJBcnJheSIsInBhdGgiLCJwMCIsInBwIiwiZHJhd091dGxpbmUiLCJDYW52YXNFeHRyYVN0YXRlIiwiYWxwaGFJc1NoYXBlIiwiZm9udFNpemUiLCJmb250U2l6ZVNjYWxlIiwidGV4dE1hdHJpeCIsInRleHRNYXRyaXhTY2FsZSIsImZvbnRNYXRyaXgiLCJsZWFkaW5nIiwibGluZVgiLCJsaW5lWSIsImNoYXJTcGFjaW5nIiwid29yZFNwYWNpbmciLCJ0ZXh0SFNjYWxlIiwidGV4dFJlbmRlcmluZ01vZGUiLCJ0ZXh0UmlzZSIsInBhdHRlcm5GaWxsIiwiZmlsbEFscGhhIiwic3Ryb2tlQWxwaGEiLCJsaW5lV2lkdGgiLCJhY3RpdmVTTWFzayIsInRyYW5zZmVyTWFwcyIsInN0YXJ0TmV3UGF0aEFuZENsaXBCb3giLCJjbGlwQm94Iiwic2V0Q3VycmVudFBvaW50IiwidXBkYXRlUGF0aE1pbk1heCIsIm1pblgiLCJtYXhYIiwidXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgiLCJ1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgiLCJnZXRQYXRoQm91bmRpbmdCb3giLCJ4U3Ryb2tlUGFkIiwieVN0cm9rZVBhZCIsInVwZGF0ZUNsaXBGcm9tUGF0aCIsImlzRW1wdHlDbGlwIiwiSW5maW5pdHkiLCJwdXRCaW5hcnlJbWFnZURhdGEiLCJJbWFnZURhdGEiLCJwYXJ0aWFsQ2h1bmtIZWlnaHQiLCJmdWxsQ2h1bmtzIiwidG90YWxDaHVua3MiLCJjaHVua0ltZ0RhdGEiLCJ0aGlzQ2h1bmtIZWlnaHQiLCJlbGVtc0luVGhpc0NodW5rIiwiZGVzdDMyIiwiZGVzdDMyRGF0YUxlbmd0aCIsImZ1bGxTcmNEaWZmIiwid2hpdGUiLCJzcmNEaWZmIiwia0VuZCIsImtFbmRVbnJvbGxlZCIsInNyY0J5dGUiLCJwdXRCaW5hcnlJbWFnZU1hc2siLCJjb3B5Q3R4U3RhdGUiLCJzb3VyY2VDdHgiLCJwcm9wZXJ0aWVzIiwicHJvcGVydHkiLCJzZXRMaW5lRGFzaCIsImdldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJyZXNldEN0eFRvRGVmYXVsdCIsImZpbGxSdWxlIiwiZ2xvYmFsQWxwaGEiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJtaXRlckxpbWl0IiwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIiwiZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkIiwiaW50ZXJwb2xhdGUiLCJmcm91bmQiLCJhY3R1YWxTY2FsZSIsIkxJTkVfQ0FQX1NUWUxFUyIsIkxJTkVfSk9JTl9TVFlMRVMiLCJOT1JNQUxfQ0xJUCIsIkVPX0NMSVAiLCJDYW52YXNHcmFwaGljcyIsImNhbnZhc0N0eCIsImNvbW1vbk9ianMiLCJvcHRpb25hbENvbnRlbnRDb25maWciLCJtYXJrZWRDb250ZW50U3RhY2siLCJhbm5vdGF0aW9uQ2FudmFzTWFwIiwic3RhdGVTdGFjayIsInBlbmRpbmdDbGlwIiwicGVuZGluZ0VPRmlsbCIsInJlcyIsInhvYmpzIiwiZ3JvdXBTdGFjayIsInByb2Nlc3NpbmdUeXBlMyIsImJhc2VUcmFuc2Zvcm1TdGFjayIsInNtYXNrU3RhY2siLCJzbWFza0NvdW50ZXIiLCJ0ZW1wU01hc2siLCJzdXNwZW5kZWRDdHgiLCJjb250ZW50VmlzaWJsZSIsImNhY2hlZFBhdHRlcm5zIiwidmlld3BvcnRTY2FsZSIsIm91dHB1dFNjYWxlWCIsIm91dHB1dFNjYWxlWSIsIl9jYWNoZWRTY2FsZUZvclN0cm9raW5nIiwiX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgiLCJfY2FjaGVkQml0bWFwc01hcCIsImdldE9iamVjdCIsImZhbGxiYWNrIiwiYmVnaW5EcmF3aW5nIiwidHJhbnNwYXJlbmN5Iiwic2F2ZWRGaWxsU3R5bGUiLCJmaWxsUmVjdCIsInRyYW5zcGFyZW50Q2FudmFzIiwiY29tcG9zaXRlQ3R4IiwiZXhlY3V0aW9uU3RhcnRJZHgiLCJjb250aW51ZUNhbGxiYWNrIiwic3RlcHBlciIsImFyZ3NBcnJheSIsImZuQXJyYXkiLCJhcmdzQXJyYXlMZW4iLCJjaHVua09wZXJhdGlvbnMiLCJlbmRUaW1lIiwiZm5JZCIsIm5leHRCcmVha1BvaW50IiwiYnJlYWtJdCIsImRlcE9iaklkIiwib2Jqc1Bvb2wiLCJyZXN0b3JlSW5pdGlhbFN0YXRlIiwiaW5TTWFza01vZGUiLCJIVE1MQ2FudmFzRWxlbWVudCIsImRyYXdGaWx0ZXIiLCJoY21GaWx0ZXJJZCIsInNhdmVkRmlsdGVyIiwiX3NjYWxlSW1hZ2UiLCJpbWciLCJkaXNwbGF5V2lkdGgiLCJkaXNwbGF5SGVpZ2h0Iiwid2lkdGhTY2FsZSIsImhlaWdodFNjYWxlIiwicGFpbnRXaWR0aCIsInBhaW50SGVpZ2h0IiwidG1wQ2FudmFzSWQiLCJfY3JlYXRlTWFza0NhbnZhcyIsImlzUGF0dGVybkZpbGwiLCJjdXJyZW50VHJhbnNmb3JtIiwiY2FjaGVLZXkiLCJtYXNrQ2FudmFzIiwibWFpbktleSIsImNhY2hlZEltYWdlIiwibWFza1RvQ2FudmFzIiwiZHJhd25XaWR0aCIsImRyYXduSGVpZ2h0IiwiZmlsbENhbnZhcyIsImZpbGxDdHgiLCJpbWFnZVNtb290aGluZ0VuYWJsZWQiLCJsaW1pdCIsImRhc2hBcnJheSIsImRhc2hQaGFzZSIsImludGVudCIsImZsYXRuZXNzIiwic3RhdGVzIiwiY2hlY2tTTWFza1N0YXRlIiwiYmVnaW5TTWFza01vZGUiLCJlbmRTTWFza01vZGUiLCJjYWNoZUlkIiwic2NyYXRjaENhbnZhcyIsImNvbXBvc2UiLCJkaXJ0eUJveCIsInNtYXNrIiwiY29tcG9zZVNNYXNrIiwibGF5ZXJDdHgiLCJsYXllckJveCIsImxheWVyT2Zmc2V0WCIsImxheWVyT2Zmc2V0WSIsImxheWVyV2lkdGgiLCJsYXllckhlaWdodCIsImdlbmVyaWNDb21wb3NlU01hc2siLCJzdWJ0eXBlIiwiYmFja2Ryb3AiLCJ0cmFuc2Zlck1hcCIsIm1hc2tDdHgiLCJtYXNrT2Zmc2V0WCIsIm1hc2tPZmZzZXRZIiwibWFza1giLCJtYXNrWSIsImJhY2tkcm9wUkdCIiwib2xkIiwicG9wIiwib3BzIiwic3RhcnRYIiwic3RhcnRZIiwiaXNTY2FsaW5nTWF0cml4IiwibWluTWF4Rm9yQmV6aWVyIiwieHciLCJ5aCIsImNvbnN1bWVQYXRoIiwicmVzY2FsZUFuZFN0cm9rZSIsIm5lZWRSZXN0b3JlIiwicGF0aHMiLCJwZW5kaW5nVGV4dFBhdGhzIiwiYWRkVG9QYXRoIiwic3BhY2luZyIsImZvbnRSZWZOYW1lIiwiZm9udE9iaiIsImZvbnREaXJlY3Rpb24iLCJpc1R5cGUzRm9udCIsInR5cGVmYWNlIiwiZmFsbGJhY2tOYW1lIiwiYm9sZCIsIml0YWxpYyIsImJyb3dzZXJGb250U2l6ZSIsInJpc2UiLCJwYWludENoYXIiLCJwYXR0ZXJuVHJhbnNmb3JtIiwiZmlsbFN0cm9rZU1vZGUiLCJpc0FkZFRvUGF0aFNldCIsInN0cm9rZVRleHQiLCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCIsImdseXBocyIsInNob3dUeXBlM1RleHQiLCJnbHlwaHNMZW5ndGgiLCJ2ZXJ0aWNhbCIsInNwYWNpbmdEaXIiLCJkZWZhdWx0Vk1ldHJpY3MiLCJ3aWR0aEFkdmFuY2VTY2FsZSIsInNpbXBsZUZpbGxUZXh0IiwiZ2V0U2luZ2xlUGl4ZWxXaWR0aCIsImlzSW52YWxpZFBERmpzRm9udCIsImNoYXJzIiwiZ2x5cGgiLCJ1bmljb2RlIiwicmVzdG9yZU5lZWRlZCIsImlzU3BhY2UiLCJmb250Q2hhciIsImFjY2VudCIsInNjYWxlZFgiLCJzY2FsZWRZIiwidm1ldHJpYyIsInZ4IiwidnkiLCJyZW1lYXN1cmUiLCJtZWFzdXJlZFdpZHRoIiwibWVhc3VyZVRleHQiLCJjaGFyYWN0ZXJTY2FsZVgiLCJpc0luRm9udCIsInNjYWxlZEFjY2VudFgiLCJzY2FsZWRBY2NlbnRZIiwiY2hhcldpZHRoIiwiaXNUZXh0SW52aXNpYmxlIiwic3BhY2luZ0xlbmd0aCIsImNoYXJQcm9jT3BlcmF0b3JMaXN0Iiwib3BlcmF0b3JMaXN0SWQiLCJ0cmFuc2Zvcm1lZCIsInhXaWR0aCIsInlXaWR0aCIsImxseCIsImxseSIsInVyeCIsInVyeSIsImdldENvbG9yTl9QYXR0ZXJuIiwiX2dldFBhdHRlcm4iLCJhcmd1bWVudHMiLCJvYmpJZCIsImludiIsImdyb3VwIiwiY3VycmVudEN0eCIsImlzb2xhdGVkIiwia25vY2tvdXQiLCJib3VuZHMiLCJjYW52YXNCb3VuZHMiLCJncm91cEN0eCIsInN0YXJ0VHJhbnNmb3JtSW52ZXJzZSIsImN1cnJlbnRNdHgiLCJoYXNPd25DYW52YXMiLCJhbm5vdGF0aW9uQ2FudmFzIiwic2F2ZWRDdHgiLCJjb21waWxlZCIsInNrZXdYIiwic2tld1kiLCJwb3NpdGlvbnMiLCJ0cmFucyIsImltYWdlcyIsImFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXMiLCJhcHBseVRyYW5zZmVyTWFwc1RvQml0bWFwIiwiaW1nVG9QYWludCIsIkhUTUxFbGVtZW50IiwidGFnIiwiaXNWaXNpYmxlIiwiaXNDb250ZW50VmlzaWJsZSIsImFic0RldCIsIm5vcm1YIiwibm9ybVkiLCJnZXRTY2FsZUZvclN0cm9raW5nIiwic2NhbGVkTGluZVdpZHRoIiwic2NhbGVkWExpbmVXaWR0aCIsInNjYWxlZFlMaW5lV2lkdGgiLCJiYXNlQXJlYSIsInNhdmVSZXN0b3JlIiwiZGFzaGVzIiwib3AiLCJwb3J0Iiwid29ya2VyUG9ydCIsIldvcmtlciIsIndvcmtlclNyYyIsIkNhbGxiYWNrS2luZCIsIlVOS05PV04iLCJEQVRBIiwiRVJST1IiLCJTdHJlYW1LaW5kIiwiQ0FOQ0VMIiwiQ0FOQ0VMX0NPTVBMRVRFIiwiQ0xPU0UiLCJFTlFVRVVFIiwiUFVMTCIsIlBVTExfQ09NUExFVEUiLCJTVEFSVF9DT01QTEVURSIsIndyYXBSZWFzb24iLCJNZXNzYWdlSGFuZGxlciIsIm1lc3NhZ2VBQyIsInNvdXJjZU5hbWUiLCJ0YXJnZXROYW1lIiwiY29tT2JqIiwiY2FsbGJhY2tJZCIsInN0cmVhbUlkIiwic3RyZWFtU2lua3MiLCJzdHJlYW1Db250cm9sbGVycyIsImNhbGxiYWNrQ2FwYWJpbGl0aWVzIiwiYWN0aW9uSGFuZGxlciIsIm9uTWVzc2FnZSIsInN0cmVhbSIsInByb2Nlc3NTdHJlYW1NZXNzYWdlIiwiY2FwYWJpbGl0eSIsInBvc3RNZXNzYWdlIiwiY3JlYXRlU3RyZWFtU2luayIsImFjdGlvbk5hbWUiLCJoYW5kbGVyIiwiYWgiLCJ0cmFuc2ZlcnMiLCJzZW5kV2l0aFByb21pc2UiLCJzZW5kV2l0aFN0cmVhbSIsInF1ZXVlaW5nU3RyYXRlZ3kiLCJSZWFkYWJsZVN0cmVhbSIsImNvbnRyb2xsZXIiLCJzdGFydENhcGFiaWxpdHkiLCJzdGFydENhbGwiLCJwdWxsQ2FsbCIsImNhbmNlbENhbGwiLCJpc0Nsb3NlZCIsImRlc2lyZWRTaXplIiwicHVsbCIsInB1bGxDYXBhYmlsaXR5IiwiY2FuY2VsQ2FwYWJpbGl0eSIsInN0cmVhbVNpbmsiLCJlbnF1ZXVlIiwiaXNDYW5jZWxsZWQiLCJsYXN0RGVzaXJlZFNpemUiLCJzaW5rQ2FwYWJpbGl0eSIsInJlYWR5Iiwib25QdWxsIiwib25DYW5jZWwiLCJzdWNjZXNzIiwic3RyZWFtQ29udHJvbGxlciIsImRlbGV0ZVN0cmVhbUNvbnRyb2xsZXIiLCJhbGxTZXR0bGVkIiwiTWV0YWRhdGEiLCJtZXRhZGF0YU1hcCIsInBhcnNlZERhdGEiLCJnZXRSYXciLCJJTlRFUk5BTCIsIlN5bWJvbCIsIk9wdGlvbmFsQ29udGVudEdyb3VwIiwiaXNEaXNwbGF5IiwiaXNQcmludCIsInVzZXJTZXQiLCJyZW5kZXJpbmdJbnRlbnQiLCJ1c2FnZSIsInJiR3JvdXBzIiwidmlldyIsInZpZXdTdGF0ZSIsInByaW50U3RhdGUiLCJfc2V0VmlzaWJsZSIsImludGVybmFsIiwiT3B0aW9uYWxDb250ZW50Q29uZmlnIiwiY2FjaGVkR2V0SGFzaCIsImdyb3VwcyIsImluaXRpYWxIYXNoIiwib3JkZXIiLCJjcmVhdG9yIiwiYmFzZVN0YXRlIiwib2ZmIiwiZ2V0SGFzaCIsImV2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24iLCJhcnJheSIsIm9wZXJhdG9yIiwiZXhwcmVzc2lvbiIsInBvbGljeSIsInNldFZpc2liaWxpdHkiLCJwcmVzZXJ2ZVJCIiwicmJHcm91cCIsIm90aGVySWQiLCJzZXRPQ0dTdGF0ZSIsImhhc0luaXRpYWxWaXNpYmlsaXR5IiwiZ2V0T3JkZXIiLCJnZXRHcm91cHMiLCJnZXRHcm91cCIsIlBERkRhdGFUcmFuc3BvcnRTdHJlYW0iLCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnQiLCJkaXNhYmxlUmFuZ2UiLCJkaXNhYmxlU3RyZWFtIiwiaW5pdGlhbERhdGEiLCJwcm9ncmVzc2l2ZURvbmUiLCJjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSIsIl9xdWV1ZWRDaHVua3MiLCJfcHJvZ3Jlc3NpdmVEb25lIiwiX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIiwiX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCIsIl9pc1N0cmVhbWluZ1N1cHBvcnRlZCIsIl9pc1JhbmdlU3VwcG9ydGVkIiwiX2NvbnRlbnRMZW5ndGgiLCJfZnVsbFJlcXVlc3RSZWFkZXIiLCJfcmFuZ2VSZWFkZXJzIiwiYWRkUmFuZ2VMaXN0ZW5lciIsImJlZ2luIiwiX29uUmVjZWl2ZURhdGEiLCJhZGRQcm9ncmVzc0xpc3RlbmVyIiwidG90YWwiLCJfb25Qcm9ncmVzcyIsImFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyIiwiYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIiLCJfb25Qcm9ncmVzc2l2ZURvbmUiLCJ0cmFuc3BvcnRSZWFkeSIsIl9lbnF1ZXVlIiwiZm91bmQiLCJyYW5nZVJlYWRlciIsIl9iZWdpbiIsIl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgiLCJfbG9hZGVkIiwib25Qcm9ncmVzcyIsIl9yZW1vdmVSYW5nZVJlYWRlciIsInJlYWRlciIsImluZGV4T2YiLCJnZXRGdWxsUmVhZGVyIiwicXVldWVkQ2h1bmtzIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciIsImdldFJhbmdlUmVhZGVyIiwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIiwicmVxdWVzdERhdGFSYW5nZSIsImNhbmNlbEFsbFJlcXVlc3RzIiwiX3N0cmVhbSIsIl9kb25lIiwiX2ZpbGVuYW1lIiwiX3JlcXVlc3RzIiwiX2hlYWRlcnNSZWFkeSIsInJlcXVlc3RDYXBhYmlsaXR5IiwiaGVhZGVyc1JlYWR5IiwiaXNSYW5nZVN1cHBvcnRlZCIsImlzU3RyZWFtaW5nU3VwcG9ydGVkIiwiY29udGVudExlbmd0aCIsInJlYWQiLCJfZW5kIiwiX3F1ZXVlZENodW5rIiwicmVxdWVzdHNDYXBhYmlsaXR5IiwiZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyIiwiY29udGVudERpc3Bvc2l0aW9uIiwibmVlZHNFbmNvZGluZ0ZpeHVwIiwidG9QYXJhbVJlZ0V4cCIsInJmYzI2MTZ1bnF1b3RlIiwicmZjNTk4N2RlY29kZSIsInJmYzIwNDdkZWNvZGUiLCJmaXh1cEVuY29kaW5nIiwicmZjMjIzMWdldHBhcmFtIiwiYXR0cmlidXRlUGF0dGVybiIsImZsYWdzIiwidGV4dGRlY29kZSIsImNvbnRlbnREaXNwb3NpdGlvblN0ciIsIml0ZXIiLCJxdW90IiwicGFydCIsInBhcnRzIiwicXVvdGluZGV4IiwiZXh0dmFsdWUiLCJlbmNvZGluZ2VuZCIsImxhbmd2YWx1ZSIsInJlcGxhY2UiLCJjaGFyc2V0IiwiaGV4IiwiY3JlYXRlSGVhZGVycyIsImlzSHR0cCIsImh0dHBIZWFkZXJzIiwiaGVhZGVycyIsIkhlYWRlcnMiLCJ2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyIsInJlc3BvbnNlSGVhZGVycyIsInJhbmdlQ2h1bmtTaXplIiwicmV0dXJuVmFsdWVzIiwiYWxsb3dSYW5nZVJlcXVlc3RzIiwic3VnZ2VzdGVkTGVuZ3RoIiwiY29udGVudEVuY29kaW5nIiwiZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciIsImNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IiLCJ2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzIiwiY3JlYXRlRmV0Y2hPcHRpb25zIiwid2l0aENyZWRlbnRpYWxzIiwibWV0aG9kIiwiY3JlZGVudGlhbHMiLCJyZWRpcmVjdCIsImdldEFycmF5QnVmZmVyIiwiUERGRmV0Y2hTdHJlYW0iLCJfcmFuZ2VSZXF1ZXN0UmVhZGVycyIsIlBERkZldGNoU3RyZWFtUmVhZGVyIiwiUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciIsIl9yZWFkZXIiLCJfd2l0aENyZWRlbnRpYWxzIiwiX2hlYWRlcnNDYXBhYmlsaXR5IiwiX2Rpc2FibGVSYW5nZSIsIl9yYW5nZUNodW5rU2l6ZSIsIl9hYm9ydENvbnRyb2xsZXIiLCJnZXRSZWFkZXIiLCJfcmVhZENhcGFiaWxpdHkiLCJPS19SRVNQT05TRSIsIlBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSIsIm5ldHdvcmtfZ2V0QXJyYXlCdWZmZXIiLCJ4aHIiLCJOZXR3b3JrTWFuYWdlciIsImN1cnJYaHJJZCIsInBlbmRpbmdSZXF1ZXN0cyIsInJlcXVlc3RSYW5nZSIsImxpc3RlbmVycyIsInJlcXVlc3RGdWxsIiwieGhySWQiLCJwZW5kaW5nUmVxdWVzdCIsInNldFJlcXVlc3RIZWFkZXIiLCJleHBlY3RlZFN0YXR1cyIsIm9uRXJyb3IiLCJvblN0YXRlQ2hhbmdlIiwib25wcm9ncmVzcyIsIm9uSGVhZGVyc1JlY2VpdmVkIiwib25Eb25lIiwieGhyU3RhdHVzIiwib2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCIsInJhbmdlSGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJnZXRSZXF1ZXN0WGhyIiwiaXNQZW5kaW5nUmVxdWVzdCIsImFib3J0UmVxdWVzdCIsIlBERk5ldHdvcmtTdHJlYW0iLCJfc291cmNlIiwiX21hbmFnZXIiLCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQiLCJQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIiLCJQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIiwib25DbG9zZWQiLCJtYW5hZ2VyIiwiX29uSGVhZGVyc1JlY2VpdmVkIiwiX29uRG9uZSIsIl9vbkVycm9yIiwiX3VybCIsIl9mdWxsUmVxdWVzdElkIiwiX2NhY2hlZENodW5rcyIsIl9zdG9yZWRFcnJvciIsImZ1bGxSZXF1ZXN0WGhySWQiLCJmdWxsUmVxdWVzdFhociIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsImxlbmd0aENvbXB1dGFibGUiLCJfcmVxdWVzdElkIiwiX2Nsb3NlIiwidXJsUmVnZXgiLCJwYXJzZVVybE9yUGF0aCIsInNvdXJjZVVybCIsInBhdGhUb0ZpbGVVUkwiLCJjcmVhdGVSZXF1ZXN0IiwiUERGTm9kZVN0cmVhbSIsImlzRnNVcmwiLCJQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIiwiUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIiLCJQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlciIsIlBERk5vZGVTdHJlYW1SYW5nZVJlYWRlciIsIkJhc2VGdWxsUmVhZGVyIiwiX3JlYWRhYmxlU3RyZWFtIiwiX2Vycm9yIiwiX3NldFJlYWRhYmxlU3RyZWFtIiwicmVhZGFibGVTdHJlYW0iLCJCYXNlUmFuZ2VSZWFkZXIiLCJmcm9tRW50cmllcyIsImhhbmRsZVJlc3BvbnNlIiwic3RhdHVzQ29kZSIsIl9yZXF1ZXN0IiwiUmFuZ2UiLCJsc3RhdCIsInN0YXQiLCJjcmVhdGVSZWFkU3RyZWFtIiwiTUFYX1RFWFRfRElWU19UT19SRU5ERVIiLCJERUZBVUxUX0ZPTlRfU0laRSIsIkRFRkFVTFRfRk9OVF9BU0NFTlQiLCJkaXNhYmxlUHJvY2Vzc0l0ZW1zIiwiZm9udEluc3BlY3RvckVuYWJsZWQiLCJsYW5nIiwibGF5b3V0VGV4dFBhcmFtcyIsInJvb3RDb250YWluZXIiLCJzdHlsZUNhY2hlIiwidGV4dENvbnRlbnRJdGVtc1N0ciIsInRleHRDb250ZW50U291cmNlIiwidGV4dERpdnMiLCJ0ZXh0RGl2UHJvcGVydGllcyIsImFzY2VudENhY2hlIiwiY2FudmFzQ29udGV4dHMiLCJjYW52YXNDdHhGb250cyIsIldlYWtNYXAiLCJtaW5Gb250U2l6ZSIsInBlbmRpbmdUZXh0TGF5ZXJzIiwiRm9udEluc3BlY3RvciIsImVuc3VyZU1pbkZvbnRTaXplQ29tcHV0ZWQiLCJmaW5hbGx5IiwiZm9udEZhbWlseU1hcCIsInB1bXAiLCJzdHlsZXMiLCJwcm9jZXNzSXRlbXMiLCJvbkJlZm9yZSIsImdldEN0eCIsImxheW91dCIsImFib3J0RXgiLCJhcHBlbmRUZXh0IiwiZ2VvbSIsInRleHREaXYiLCJoYXNUZXh0IiwiaGFzRU9MIiwiYXRhbjIiLCJmb250TmFtZSIsImZvbnRTdWJzdGl0dXRpb24iLCJmb250SGVpZ2h0IiwiZm9udEFzY2VudCIsImdldEFzY2VudCIsInNpbiIsImNvcyIsInNjYWxlRmFjdG9yU3RyIiwiZGl2U3R5bGUiLCJkaXIiLCJkYXRhc2V0IiwiZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWUiLCJzaG91bGRTY2FsZVRleHQiLCJhYnNTY2FsZVgiLCJhYnNTY2FsZVkiLCJiciIsImVuc3VyZUN0eEZvbnQiLCJjbGVhbnVwIiwiYWxwaGEiLCJjYWNoZWQiLCJsaW5lSGVpZ2h0IiwiY2FjaGVkQXNjZW50IiwibWV0cmljcyIsImFzY2VudCIsImZvbnRCb3VuZGluZ0JveEFzY2VudCIsImRlc2NlbnQiLCJmb250Qm91bmRpbmdCb3hEZXNjZW50IiwicmF0aW8iLCJwaXhlbHMiLCJYZmFUZXh0IiwieGZhIiwib3V0cHV0Iiwid2FsayIsIm5vZGUiLCJzaG91bGRCdWlsZFRleHQiLCJERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkUiLCJSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQiLCJERUxBWUVEX0NMRUFOVVBfVElNRU9VVCIsIkRlZmF1bHRDYW52YXNGYWN0b3J5IiwiRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5IiwiRGVmYXVsdEZpbHRlckZhY3RvcnkiLCJEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkiLCJ0YXNrIiwiUERGRG9jdW1lbnRMb2FkaW5nVGFzayIsImdldFVybFByb3AiLCJnZXREYXRhUHJvcCIsInBhc3N3b3JkIiwicmFuZ2VUcmFuc3BvcnQiLCJ3b3JrZXIiLCJkb2NCYXNlVXJsIiwiY01hcFVybCIsImNNYXBQYWNrZWQiLCJDTWFwUmVhZGVyRmFjdG9yeSIsInN0YW5kYXJkRm9udERhdGFVcmwiLCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSIsImlnbm9yZUVycm9ycyIsInN0b3BBdEVycm9ycyIsIm1heEltYWdlU2l6ZSIsImlzQ2hyb21lIiwiY2hyb21lIiwiY2FudmFzTWF4QXJlYUluQnl0ZXMiLCJmb250RXh0cmFQcm9wZXJ0aWVzIiwiZW5hYmxlWGZhIiwiZGlzYWJsZUF1dG9GZXRjaCIsInBkZkJ1ZyIsIkNhbnZhc0ZhY3RvcnkiLCJGaWx0ZXJGYWN0b3J5IiwidXNlU3lzdGVtRm9udHMiLCJ1c2VXb3JrZXJGZXRjaCIsInRyYW5zcG9ydEZhY3RvcnkiLCJjTWFwUmVhZGVyRmFjdG9yeSIsInN0YW5kYXJkRm9udERhdGFGYWN0b3J5Iiwid29ya2VyUGFyYW1zIiwiZnJvbVBvcnQiLCJfd29ya2VyIiwiZG9jUGFyYW1zIiwiYXBpVmVyc2lvbiIsImV2YWx1YXRvck9wdGlvbnMiLCJ0cmFuc3BvcnRQYXJhbXMiLCJsb2FkaW5nUGFyYW1zIiwiZGVzdHJveWVkIiwid29ya2VySWRQcm9taXNlIiwibWVzc2FnZUhhbmRsZXIiLCJuZXR3b3JrU3RyZWFtIiwiTmV0d29ya1N0cmVhbSIsImlzRmV0Y2hTdXBwb3J0ZWQiLCJSZXNwb25zZSIsIndvcmtlcklkIiwidHJhbnNwb3J0IiwiV29ya2VyVHJhbnNwb3J0IiwiX3RyYW5zcG9ydCIsIl9jYXBhYmlsaXR5IiwiaHJlZiIsImxvY2F0aW9uIiwiQnVmZmVyIiwiaXNOYU4iLCJpc1JlZlByb3h5IiwicmVmIiwiZ2VuIiwib25QYXNzd29yZCIsIl9wZW5kaW5nRGVzdHJveSIsIl9yYW5nZUxpc3RlbmVycyIsIl9wcm9ncmVzc0xpc3RlbmVycyIsIl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMiLCJfcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzIiwiX3JlYWR5Q2FwYWJpbGl0eSIsImxpc3RlbmVyIiwib25EYXRhUmFuZ2UiLCJvbkRhdGFQcm9ncmVzcyIsIm9uRGF0YVByb2dyZXNzaXZlUmVhZCIsIm9uRGF0YVByb2dyZXNzaXZlRG9uZSIsIlBERkRvY3VtZW50UHJveHkiLCJwZGZJbmZvIiwiX3BkZkluZm8iLCJudW1QYWdlcyIsImZpbmdlcnByaW50cyIsImlzUHVyZVhmYSIsIl9odG1sRm9yWGZhIiwiYWxsWGZhSHRtbCIsImdldFBhZ2UiLCJnZXRQYWdlSW5kZXgiLCJnZXREZXN0aW5hdGlvbnMiLCJnZXREZXN0aW5hdGlvbiIsImdldFBhZ2VMYWJlbHMiLCJnZXRQYWdlTGF5b3V0IiwiZ2V0UGFnZU1vZGUiLCJnZXRWaWV3ZXJQcmVmZXJlbmNlcyIsImdldE9wZW5BY3Rpb24iLCJnZXRBdHRhY2htZW50cyIsImdldEpTQWN0aW9ucyIsImdldERvY0pTQWN0aW9ucyIsImdldE91dGxpbmUiLCJnZXRPcHRpb25hbENvbnRlbnRDb25maWciLCJnZXRSZW5kZXJpbmdJbnRlbnQiLCJnZXRQZXJtaXNzaW9ucyIsImdldE1ldGFkYXRhIiwiZ2V0TWFya0luZm8iLCJzYXZlRG9jdW1lbnQiLCJnZXREb3dubG9hZEluZm8iLCJkb3dubG9hZEluZm9DYXBhYmlsaXR5Iiwia2VlcExvYWRlZEZvbnRzIiwic3RhcnRDbGVhbnVwIiwibG9hZGluZ1Rhc2siLCJjYWNoZWRQYWdlTnVtYmVyIiwiZ2V0RmllbGRPYmplY3RzIiwiaGFzSlNBY3Rpb25zIiwiZ2V0Q2FsY3VsYXRpb25PcmRlcklkcyIsIlBERlBhZ2VQcm94eSIsImRlbGF5ZWRDbGVhbnVwVGltZW91dCIsInBlbmRpbmdDbGVhbnVwIiwicGFnZUluZm8iLCJfcGFnZUluZGV4IiwiX3BhZ2VJbmZvIiwiX3N0YXRzIiwiX3BkZkJ1ZyIsIlBERk9iamVjdHMiLCJfbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIiLCJfaW50ZW50U3RhdGVzIiwidXNlclVuaXQiLCJnZXRWaWV3cG9ydCIsImdldEFubm90YXRpb25zIiwiZ2V0UGFnZUpTQWN0aW9ucyIsImdldFhmYSIsImNhbnZhc0NvbnRleHQiLCJhbm5vdGF0aW9uTW9kZSIsIm9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UiLCJwcmludEFubm90YXRpb25TdG9yYWdlIiwiaW50ZW50QXJncyIsImFib3J0RGVsYXllZENsZWFudXAiLCJpbnRlbnRTdGF0ZSIsInN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQiLCJpbnRlbnRQcmludCIsImRpc3BsYXlSZWFkeUNhcGFiaWxpdHkiLCJsYXN0Q2h1bmsiLCJzZXBhcmF0ZUFubm90cyIsIl9wdW1wT3BlcmF0b3JMaXN0IiwicmVuZGVyVGFza3MiLCJpbnRlcm5hbFJlbmRlclRhc2siLCJ0cnlDbGVhbnVwIiwiX2Fib3J0T3BlcmF0b3JMaXN0IiwiU3RhdHMiLCJJbnRlcm5hbFJlbmRlclRhc2siLCJ1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZW5kZXJUYXNrIiwiaW5pdGlhbGl6ZUdyYXBoaWNzIiwib3BlcmF0b3JMaXN0Q2hhbmdlZCIsImdldE9wZXJhdG9yTGlzdCIsIm9wTGlzdFJlYWRDYXBhYmlsaXR5Iiwib3BMaXN0VGFzayIsInN0cmVhbVRleHRDb250ZW50IiwiaW5jbHVkZU1hcmtlZENvbnRlbnQiLCJkaXNhYmxlTm9ybWFsaXphdGlvbiIsIlRFWFRfQ09OVEVOVF9DSFVOS19TSVpFIiwiaGlnaFdhdGVyTWFyayIsImdldFRleHRDb250ZW50IiwiZ2V0U3RydWN0VHJlZSIsIl9kZXN0cm95Iiwid2FpdE9uIiwiZm9yY2UiLCJjb21wbGV0ZWQiLCJyZXNldFN0YXRzIiwiZGVsYXllZCIsIl9zdGFydFJlbmRlclBhZ2UiLCJfcmVuZGVyUGFnZUNodW5rIiwib3BlcmF0b3JMaXN0Q2h1bmsiLCJhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSIsInN0cmVhbVJlYWRlciIsImRlbGF5IiwiY3VyQ2FjaGVLZXkiLCJjdXJJbnRlbnRTdGF0ZSIsIkxvb3BiYWNrUG9ydCIsImRlZmVycmVkIiwicm1BYm9ydCIsImFib3J0ZWQiLCJvbkFib3J0IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInRlcm1pbmF0ZSIsImZha2VXb3JrZXJJZCIsImlzV29ya2VyRGlzYWJsZWQiLCJ3b3JrZXJQb3J0cyIsIl9pc1NhbWVPcmlnaW4iLCJvdGhlclVybCIsImJhc2UiLCJvcmlnaW4iLCJvdGhlciIsIl9jcmVhdGVDRE5XcmFwcGVyIiwid3JhcHBlciIsImNyZWF0ZU9iamVjdFVSTCIsIl9wb3J0IiwiX3dlYldvcmtlciIsIl9tZXNzYWdlSGFuZGxlciIsIl9pbml0aWFsaXplRnJvbVBvcnQiLCJfaW5pdGlhbGl6ZSIsIm1haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlciIsIl9zZXR1cEZha2VXb3JrZXIiLCJ0ZXJtaW5hdGVFYXJseSIsInNlbmRUZXN0IiwidGVzdE9iaiIsIl9zZXR1cEZha2VXb3JrZXJHbG9iYWwiLCJXb3JrZXJNZXNzYWdlSGFuZGxlciIsIndvcmtlckhhbmRsZXIiLCJzZXR1cCIsImNhY2hlZFBvcnQiLCJwZGZqc1dvcmtlciIsImxvYWRlciIsIm1ldGhvZFByb21pc2VzIiwicGFnZUNhY2hlIiwicGFnZVByb21pc2VzIiwicGFnZVJlZkNhY2hlIiwicGFzc3dvcmRDYXBhYmlsaXR5IiwiZmFjdG9yeSIsImZvbnRMb2FkZXIiLCJfcGFyYW1zIiwiZGVzdHJveUNhcGFiaWxpdHkiLCJfbmV0d29ya1N0cmVhbSIsIl9mdWxsUmVhZGVyIiwiX2xhc3RQcm9ncmVzcyIsInNldHVwTWVzc2FnZUhhbmRsZXIiLCJjYWNoZVNpbXBsZU1ldGhvZCIsImNhY2hlZFByb21pc2UiLCJpc09wTGlzdCIsIm1vZGlmaWVkSWRzSGFzaCIsImNhY2hlS2V5QnVmIiwicGFnZSIsInRlcm1pbmF0ZWQiLCJzaW5rIiwicmVhZHlSZWFzb24iLCJfbnVtUGFnZXMiLCJodG1sRm9yWGZhIiwiZXhjZXB0aW9uIiwidXBkYXRlUGFzc3dvcmQiLCJleHBvcnRlZERhdGEiLCJleHBvcnRlZEVycm9yIiwiZm9udEFkZGVkIiwiaW1hZ2VSZWYiLCJwYWdlUHJveHkiLCJkYXRhTGVuIiwicmVmU3RyIiwicmVzdWx0cyIsIm1ldGFkYXRhIiwiY2xlYW51cFN1Y2Nlc3NmdWwiLCJJTklUSUFMX0RBVEEiLCJlbnN1cmVPYmoiLCJpdGVyYXRvciIsIlJlbmRlclRhc2siLCJvbkNvbnRpbnVlIiwiZm9ybSIsInJBRiIsImNhbnZhc0luVXNlIiwiV2Vha1NldCIsIm9wZXJhdG9yTGlzdElkeCIsInJ1bm5pbmciLCJncmFwaGljc1JlYWR5Q2FsbGJhY2siLCJncmFwaGljc1JlYWR5IiwiX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbGxlZCIsIl9jYW5jZWxCb3VuZCIsIl9jb250aW51ZUJvdW5kIiwiX2NvbnRpbnVlIiwiX3NjaGVkdWxlTmV4dEJvdW5kIiwiX3NjaGVkdWxlTmV4dCIsIl9uZXh0Qm91bmQiLCJfbmV4dCIsIl9jYW52YXMiLCJTdGVwcGVyTWFuYWdlciIsImluaXQiLCJnZXROZXh0QnJlYWtQb2ludCIsImdmeCIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlT3BlcmF0b3JMaXN0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibWFrZUNvbG9yQ29tcCIsInNjYWxlQW5kQ2xhbXAiLCJDb2xvckNvbnZlcnRlcnMiLCJDTVlLX0ciLCJHX0NNWUsiLCJHX1JHQiIsIkdfcmdiIiwiR19IVE1MIiwiRyIsIlJHQl9HIiwiUkdCX3JnYiIsIlJHQl9IVE1MIiwiVF9IVE1MIiwiVF9yZ2IiLCJDTVlLX1JHQiIsIkNNWUtfcmdiIiwiQ01ZS19IVE1MIiwiY29tcG9uZW50cyIsIlJHQl9DTVlLIiwiQmFzZVNWR0ZhY3RvcnkiLCJza2lwRGltZW5zaW9ucyIsIl9jcmVhdGVTVkciLCJzZXR1cFN0b3JhZ2UiLCJodG1sIiwic3RvcmVkRGF0YSIsInhmYU9uIiwieGZhT2ZmIiwiY2hlY2tlZCIsIm9wdGlvbiIsInNlbGVjdGVkIiwic2VsZWN0ZWRJbmRleCIsInNldEF0dHJpYnV0ZXMiLCJsaW5rU2VydmljZSIsImlzSFRNTEFuY2hvckVsZW1lbnQiLCJIVE1MQW5jaG9yRWxlbWVudCIsImFkZExpbmtBdHRyaWJ1dGVzIiwibmV3V2luZG93IiwiZGF0YUlkIiwicm9vdCIsInhmYUh0bWwiLCJyb290SHRtbCIsImlzTm90Rm9yUmljaFRleHQiLCJyb290RGl2IiwiY3JlYXRlVGV4dE5vZGUiLCJzdGFjayIsImNoaWxkSHRtbCIsInhtbG5zIiwicXVlcnlTZWxlY3RvckFsbCIsImhpZGRlbiIsIkRFRkFVTFRfVEFCX0lOREVYIiwiYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRSIsIkdldEVsZW1lbnRzQnlOYW1lU2V0IiwiZ2V0UmVjdERpbXMiLCJBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkiLCJhbm5vdGF0aW9uVHlwZSIsIkxpbmtBbm5vdGF0aW9uRWxlbWVudCIsIlRleHRBbm5vdGF0aW9uRWxlbWVudCIsImZpZWxkVHlwZSIsIlRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsInJhZGlvQnV0dG9uIiwiUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsImNoZWNrQm94IiwiQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIkNob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IiwiU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQiLCJXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCIsIlBvcHVwQW5ub3RhdGlvbkVsZW1lbnQiLCJGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IiwiTGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQiLCJDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCIsIlBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQiLCJDYXJldEFubm90YXRpb25FbGVtZW50IiwiSW5rQW5ub3RhdGlvbkVsZW1lbnQiLCJQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQiLCJIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCIsIlVuZGVybGluZUFubm90YXRpb25FbGVtZW50IiwiU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCIsIlN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IiwiU3RhbXBBbm5vdGF0aW9uRWxlbWVudCIsIkZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQiLCJBbm5vdGF0aW9uRWxlbWVudCIsInVwZGF0ZXMiLCJoYXNCb3JkZXIiLCJwb3B1cEVsZW1lbnQiLCJpc1JlbmRlcmFibGUiLCJpZ25vcmVCb3JkZXIiLCJjcmVhdGVRdWFkcmlsYXRlcmFscyIsImRvd25sb2FkTWFuYWdlciIsImltYWdlUmVzb3VyY2VzUGF0aCIsInJlbmRlckZvcm1zIiwic3ZnRmFjdG9yeSIsImVuYWJsZVNjcmlwdGluZyIsIl9maWVsZE9iamVjdHMiLCJmaWVsZE9iamVjdHMiLCJfY3JlYXRlQ29udGFpbmVyIiwiX2NyZWF0ZVF1YWRyaWxhdGVyYWxzIiwiX2hhc1BvcHVwRGF0YSIsInRpdGxlT2JqIiwiY29udGVudHNPYmoiLCJyaWNoVGV4dCIsIl9pc0VkaXRhYmxlIiwiaXNFZGl0YWJsZSIsImhhc1BvcHVwRGF0YSIsInVwZGF0ZUVkaXRlZCIsInNldFJlY3RFZGl0ZWQiLCJwb3B1cCIsInJlc2V0RWRpdGVkIiwiY3VycmVudFJlY3QiLCJzZXRSb3RhdGlvbiIsImFsdGVybmF0aXZlVGV4dCIsInRpdGxlIiwibm9Sb3RhdGUiLCJib3JkZXJTdHlsZSIsImJvcmRlcldpZHRoIiwiaG9yaXpvbnRhbFJhZGl1cyIsImhvcml6b250YWxDb3JuZXJSYWRpdXMiLCJ2ZXJ0aWNhbFJhZGl1cyIsInZlcnRpY2FsQ29ybmVyUmFkaXVzIiwicmFkaXVzIiwiYm9yZGVyUmFkaXVzIiwiYm9yZGVyQm90dG9tU3R5bGUiLCJib3JkZXJDb2xvciIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJfY29tbW9uQWN0aW9ucyIsInNldENvbG9yIiwianNOYW1lIiwic3R5bGVOYW1lIiwiZGV0YWlsIiwiY29sb3JUeXBlIiwiY29sb3JBcnJheSIsImRpc3BsYXkiLCJub1ZpZXciLCJub1ByaW50IiwidXNlck5hbWUiLCJyZWFkb25seSIsInJlcXVpcmVkIiwiX3NldFJlcXVpcmVkIiwidGV4dENvbG9yIiwiX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCIsImFjdGlvbnMiLCJqc0V2ZW50IiwiY29tbW9uQWN0aW9ucyIsIl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyIsImV2ZW50UHJveHkiLCJxdWFkUG9pbnRzIiwicmVjdEJsWCIsInJlY3RCbFkiLCJyZWN0VHJYIiwicmVjdFRyWSIsInRyWCIsInRyWSIsImJsWCIsImJsWSIsInN2Z0J1ZmZlciIsImNsaXBQYXRoIiwicmVjdFdpZHRoIiwicmVjdEhlaWdodCIsImJhY2tncm91bmRJbWFnZSIsIl9jcmVhdGVQb3B1cCIsIm1vZGlmaWNhdGlvbkRhdGUiLCJwYXJlbnRSZWN0IiwiZWxlbWVudHMiLCJfZ2V0RWxlbWVudHNCeU5hbWUiLCJza2lwSWQiLCJmaWVsZHMiLCJmaWVsZE9iaiIsImV4cG9ydFZhbHVlcyIsImV4cG9ydFZhbHVlIiwiZG9tRWxlbWVudCIsImdldEVsZW1lbnRzQnlOYW1lIiwibWF5YmVTaG93IiwiZm9yY2VIaWRlIiwiZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCIsImFkZEhpZ2hsaWdodEFyZWEiLCJ0cmlnZ2VycyIsIl9lZGl0T25Eb3VibGVDbGljayIsImFubm90YXRpb25FZGl0b3JUeXBlIiwiaXNUb29sdGlwT25seSIsImxpbmsiLCJpc0JvdW5kIiwiX2JpbmROYW1lZEFjdGlvbiIsImF0dGFjaG1lbnQiLCJiaW5kQXR0YWNobWVudCIsImF0dGFjaG1lbnREZXN0IiwiYmluZFNldE9DR1N0YXRlIiwiX2JpbmRMaW5rIiwiQWN0aW9uIiwiX2JpbmRKU0FjdGlvbiIsInJlc2V0Rm9ybSIsIl9iaW5kUmVzZXRGb3JtQWN0aW9uIiwic2V0SW50ZXJuYWxMaW5rIiwiZGVzdGluYXRpb24iLCJnZXREZXN0aW5hdGlvbkhhc2giLCJvbmNsaWNrIiwiZ29Ub0Rlc3RpbmF0aW9uIiwiZ2V0QW5jaG9yVXJsIiwiZXhlY3V0ZU5hbWVkQWN0aW9uIiwiZGVzY3JpcHRpb24iLCJvcGVuT3JEb3dubG9hZERhdGEiLCJleGVjdXRlU2V0T0NHU3RhdGUiLCJvdGhlckNsaWNrQWN0aW9uIiwicmVzZXRGb3JtRmllbGRzIiwicmVmcyIsInJlc2V0Rm9ybVJlZnMiLCJpbmNsdWRlIiwiYWxsRmllbGRzIiwiZmllbGRJZHMiLCJmaWVsZE5hbWUiLCJmaWVsZCIsImFsbElkcyIsImRpc3BhdGNoRXZlbnQiLCJFdmVudCIsInNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyIsInByZXZpb3VzU2libGluZyIsIl9nZXRLZXlNb2RpZmllciIsIl9zZXRFdmVudExpc3RlbmVyIiwiZWxlbWVudERhdGEiLCJiYXNlTmFtZSIsImV2ZW50TmFtZSIsInZhbHVlR2V0dGVyIiwibW9kaWZpZXIiLCJmb2N1c2VkIiwiX3NldEV2ZW50TGlzdGVuZXJzIiwiZ2V0dGVyIiwiQmx1ciIsIkZvY3VzIiwiX3NldEJhY2tncm91bmRDb2xvciIsIl9zZXRUZXh0U3R5bGUiLCJURVhUX0FMSUdOTUVOVCIsImZvbnRDb2xvciIsImRlZmF1bHRBcHBlYXJhbmNlRGF0YSIsImNvbXB1dGVkRm9udFNpemUiLCJyb3VuZFRvT25lRGVjaW1hbCIsIm11bHRpTGluZSIsIm51bWJlck9mTGluZXMiLCJ0ZXh0QWxpZ25tZW50IiwidGV4dEFsaWduIiwiaXNSZXF1aXJlZCIsImhhc0FwcGVhcmFuY2UiLCJmaWVsZFZhbHVlIiwic2V0UHJvcGVydHlPblNpYmxpbmdzIiwia2V5SW5TdG9yYWdlIiwibWF4TGVuIiwiY2hhckxpbWl0IiwiZmllbGRGb3JtYXR0ZWRWYWx1ZXMiLCJmb3JtYXR0ZWRWYWx1ZSIsImNvbWIiLCJ1c2VyVmFsdWUiLCJsYXN0Q29tbWl0dGVkVmFsdWUiLCJjb21taXRLZXkiLCJkb05vdFNjcm9sbCIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsInJlYWRPbmx5IiwibWF4TGVuZ3RoIiwiZGVmYXVsdEZpZWxkVmFsdWUiLCJibHVyTGlzdGVuZXIiLCJzY3JvbGxMZWZ0Iiwic2VsUmFuZ2UiLCJzZXRTZWxlY3Rpb25SYW5nZSIsIndpbGxDb21taXQiLCJzZWxTdGFydCIsInNlbGVjdGlvblN0YXJ0Iiwic2VsRW5kIiwic2VsZWN0aW9uRW5kIiwiX2JsdXJMaXN0ZW5lciIsIktleXN0cm9rZSIsImlucHV0VHlwZSIsImNoYW5nZSIsImZpZWxkV2lkdGgiLCJjb21iV2lkdGgiLCJsZXR0ZXJTcGFjaW5nIiwidmVydGljYWxBbGlnbiIsImNoZWNrYm94IiwiY3VyQ2hlY2tlZCIsImJ1dHRvblZhbHVlIiwicmFkaW8iLCJwZGZCdXR0b25WYWx1ZSIsImxpbmtFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsImFkZEFuRW1wdHlFbnRyeSIsImNvbWJvIiwibXVsdGlTZWxlY3QiLCJtdWx0aXBsZSIsIm9wdGlvbkVsZW1lbnQiLCJkaXNwbGF5VmFsdWUiLCJyZW1vdmVFbXB0eUVudHJ5Iiwibm9uZU9wdGlvbkVsZW1lbnQiLCJpc0V4cG9ydCIsInNlbGVjdGVkVmFsdWVzIiwiZ2V0SXRlbXMiLCJtdWx0aXBsZVNlbGVjdGlvbiIsImluZGV4IiwiZmluZEluZGV4Iiwic2VsZWN0Q2hpbGQiLCJpbmRpY2VzIiwiZWRpdGFibGUiLCJjaGFuZ2VFeCIsImtleURvd24iLCJQb3B1cEVsZW1lbnQiLCJlbGVtZW50SWRzIiwiYXJpYUhhc1BvcHVwIiwiYm91bmRLZXlEb3duIiwiYm91bmRIaWRlIiwiYm91bmRTaG93IiwiYm91bmRUb2dnbGUiLCJkYXRlT2JqIiwicGlubmVkIiwid2FzVmlzaWJsZSIsInRyaWdnZXIiLCJmbGF0TWFwIiwiYmFzZUNvbG9yIiwib3V0bGluZUNvbG9yIiwiQkFDS0dST1VORF9FTkxJR0hUIiwiaGVhZGVyIiwidmFsdWVPZiIsImNvbnRlbnRzIiwiX2Zvcm1hdENvbnRlbnRzIiwibWFrZVBvcHVwQ29udGVudCIsInBvcHVwTGluZXMiLCJwb3B1cENvbnRlbnQiLCJsaW5lQXR0cmlidXRlcyIsImxpbmUiLCJsaW5lcyIsInNldFBvc2l0aW9uIiwidXNlUGFyZW50UmVjdCIsIm5vcm1hbGl6ZWRSZWN0IiwiSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIiwicG9wdXBMZWZ0IiwicG9wdXBUb3AiLCJ0ZXh0UG9zaXRpb24iLCJsaW5lU3BhbiIsImxpbmVDb29yZGluYXRlcyIsInNxdWFyZSIsImNpcmNsZSIsInBvbHlsaW5lIiwiY29udGFpbmVyQ2xhc3NOYW1lIiwic3ZnRWxlbWVudE5hbWUiLCJ2ZXJ0aWNlcyIsInBvbHlsaW5lcyIsIml0IiwiaW5rTGlzdHMiLCJpbmtMaXN0IiwiZG93bmxvYWQiLCJhY2Nlc3NpYmlsaXR5TWFuYWdlciIsImVkaXRhYmxlQW5ub3RhdGlvbnMiLCJzdHJ1Y3RUcmVlTGF5ZXIiLCJhbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwiX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXIiLCJoYXNFZGl0YWJsZUFubm90YXRpb25zIiwiYXBwZW5kRWxlbWVudCIsImNvbnRlbnRFbGVtZW50IiwiYW5ub3RhdGlvbklkIiwiYXJpYUF0dHJpYnV0ZXMiLCJnZXRBcmlhQXR0cmlidXRlcyIsIm1vdmVFbGVtZW50SW5ET00iLCJhbm5vdGF0aW9ucyIsInBvcHVwVG9FbGVtZW50cyIsImVsZW1lbnRQYXJhbXMiLCJub0hUTUwiLCJpc1BvcHVwQW5ub3RhdGlvbiIsInJlbmRlcmVkIiwic2V0QW5ub3RhdGlvbkNhbnZhc01hcCIsInJlcGxhY2VXaXRoIiwiYWZ0ZXIiLCJnZXRFZGl0YWJsZUFubm90YXRpb25zIiwiZ2V0RWRpdGFibGVBbm5vdGF0aW9uIiwiRU9MX1BBVFRFUk4iLCJGcmVlVGV4dEVkaXRvciIsImVkaXRvckRpdklkIiwiZWRpdE1vZGVBQyIsIl9mcmVlVGV4dERlZmF1bHRDb250ZW50IiwiX2ludGVybmFsUGFkZGluZyIsIl9kZWZhdWx0Q29sb3IiLCJfZGVmYXVsdEZvbnRTaXplIiwiX3RyYW5zbGF0ZUVtcHR5IiwiX2VkaXRvclR5cGUiLCJ1cGRhdGVGb250U2l6ZSIsInNldEZvbnRzaXplIiwiZWRpdG9yRGl2Iiwic2V0RWRpdG9yRGltZW5zaW9ucyIsInNhdmVkRm9udHNpemUiLCJjb2wiLCJzYXZlZENvbG9yIiwib3ZlcmxheURpdiIsImNvbnRlbnRFZGl0YWJsZSIsImVkaXRvckRpdktleWRvd24iLCJlZGl0b3JEaXZGb2N1cyIsImVkaXRvckRpdkJsdXIiLCJlZGl0b3JEaXZJbnB1dCIsImVkaXRvckRpdlBhc3RlIiwiaW5uZXJUZXh0IiwiZXh0cmFjdFRleHQiLCJwcmV2Q2hpbGQiLCJjaGlsZE5vZGVzIiwiZ2V0Tm9kZUNvbnRlbnQiLCJzYXZlZERpc3BsYXkiLCJzYXZlZFZpc2liaWxpdHkiLCJzYXZlZFRleHQiLCJuZXdUZXh0IiwidHJpbUVuZCIsInNldFRleHQiLCJzZXRDb250ZW50IiwiZGJsY2xpY2siLCJiYXNlWCIsImJhc2VZIiwicG9zWCIsInBvc1kiLCJub2RlVmFsdWUiLCJkZXNlcmlhbGl6ZUNvbnRlbnQiLCJkZWxldGVGcm9tRG9jdW1lbnQiLCJpbnNlcnROb2RlIiwiY29sbGFwc2VUb1N0YXJ0Iiwic3RhcnRDb250YWluZXIiLCJzdGFydE9mZnNldCIsImJ1ZmZlckJlZm9yZSIsImJ1ZmZlckFmdGVyIiwibmV3UmFuZ2UiLCJiZWZvcmVMZW5ndGgiLCJyZWR1Y2UiLCJhY2MiLCJzZXRTdGFydCIsInNldEVuZCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwicmVwbGFjZUNoaWxkcmVuIiwic2VyaWFsaXplQ29udGVudCIsInBhZGRpbmciLCJzdHJ1Y3RUcmVlUGFyZW50SWQiLCJoYXNFbGVtZW50Q2hhbmdlZCIsIk91dGxpbmUiLCJ0b1NWR1BhdGgiLCJfcm90YXRpb24iLCJjbGFzc05hbWVzRm9yRHJhd2luZyIsImNsYXNzTmFtZXNGb3JPdXRsaW5pbmciLCJtdXN0UmVtb3ZlU2VsZkludGVyc2VjdGlvbnMiLCJGcmVlRHJhd091dGxpbmVyIiwiYm90dG9tIiwiaW5uZXJNYXJnaW4iLCJsYXN0IiwibWluX2Rpc3QiLCJzY2FsZUZhY3RvciIsInRoaWNrbmVzcyIsIk1JTl9ESVNUIiwiTUlOX0RJRkYiLCJNSU4iLCJGbG9hdDY0QXJyYXkiLCJnZXRMYXN0Q29vcmRzIiwibGFzdFRvcCIsImxhc3RCb3R0b20iLCJkaWZmWCIsImRpZmZZIiwiZGlmZkQiLCJuWCIsIm5ZIiwidGhYIiwidGhZIiwidG9TVkdQYXRoVHdvUG9pbnRzIiwidG9TVkdQYXRoRW5kIiwidG9TVkdQYXRoU3RhcnQiLCJsYXN0VG9wWCIsImxhc3RUb3BZIiwibGFzdEJvdHRvbVgiLCJsYXN0Qm90dG9tWSIsIm5ld0ZyZWVEcmF3T3V0bGluZSIsIm91dGxpbmUiLCJGcmVlRHJhd091dGxpbmUiLCJnZXRPdXRsaW5lcyIsImdldE91dGxpbmVUd29Qb2ludHMiLCJOIiwiZ2V0T3V0bGluZUVuZCIsImdldE91dGxpbmVTdGFydCIsImNvbXB1dGVNaW5NYXgiLCJyZXNjYWxlIiwicmVzY2FsZUFuZFN3YXAiLCJsYXN0UG9pbnRYIiwibGFzdFBvaW50WSIsImx0ckNhbGxiYWNrIiwibGFzdFBvaW50IiwibmV3T3V0bGluZXIiLCJnZXROZXdPdXRsaW5lIiwib3V0bGluZXIiLCJIaWdobGlnaHRPdXRsaW5lciIsInZlcnRpY2FsRWRnZXMiLCJpbnRlcnZhbHMiLCJOVU1CRVJfT0ZfRElHSVRTIiwiRVBTSUxPTiIsInJpZ2h0Iiwic2hpZnRlZE1pblgiLCJzaGlmdGVkTWluWSIsImxhc3RFZGdlIiwiZWRnZSIsInNvcnQiLCJvdXRsaW5lVmVydGljYWxFZGdlcyIsImJyZWFrRWRnZSIsImVkZ2VzIiwiYWxsRWRnZXMiLCJlZGdlMSIsImVkZ2UyIiwib3V0bGluZXMiLCJIaWdobGlnaHRPdXRsaW5lIiwiYmluYXJ5U2VhcmNoIiwibWlkZGxlIiwieTQiLCJwb2x5Z29uIiwicHJldlgiLCJwcmV2WSIsIkZyZWVIaWdobGlnaHRPdXRsaW5lciIsIkZyZWVIaWdobGlnaHRPdXRsaW5lIiwiYnV0dG9uU3dhdGNoIiwiZGVmYXVsdENvbG9yIiwiZHJvcGRvd24iLCJkcm9wZG93bldhc0Zyb21LZXlib2FyZCIsImlzTWFpbkNvbG9yUGlja2VyIiwib3BlbkRyb3Bkb3duQUMiLCJsMTBuQ29sb3IiLCJfaGlkZURyb3Bkb3duRnJvbUtleWJvYXJkIiwiX2NvbG9yU2VsZWN0RnJvbUtleWJvYXJkIiwiX21vdmVUb05leHQiLCJfbW92ZVRvUHJldmlvdXMiLCJfbW92ZVRvQmVnaW5uaW5nIiwiX21vdmVUb0VuZCIsImJsdWUiLCJncmVlbiIsInBpbmsiLCJyZWQiLCJ5ZWxsb3ciLCJvcGVuRHJvcGRvd24iLCJzd2F0Y2giLCJyZW5kZXJNYWluRHJvcGRvd24iLCJnZXREcm9wZG93blJvb3QiLCJyb2xlIiwiY29sb3JTZWxlY3QiLCJpc0Ryb3Bkb3duVmlzaWJsZSIsIm5leHRTaWJsaW5nIiwiSGlnaGxpZ2h0RWRpdG9yIiwiY2xpcFBhdGhJZCIsImZvY3VzT3V0bGluZXMiLCJoaWdobGlnaHREaXYiLCJoaWdobGlnaHRPdXRsaW5lcyIsImlzRnJlZUhpZ2hsaWdodCIsIm91dGxpbmVJZCIsIl9kZWZhdWx0T3BhY2l0eSIsIl9kZWZhdWx0VGhpY2tuZXNzIiwiX2ZyZWVIaWdobGlnaHRJZCIsIl9mcmVlSGlnaGxpZ2h0IiwiX2ZyZWVIaWdobGlnaHRDbGlwSWQiLCJfbW92ZUNhcmV0IiwiaGlnaGxpZ2h0SWQiLCJjcmVhdGVGcmVlT3V0bGluZXMiLCJhZGRUb0RyYXdMYXllciIsImNyZWF0ZU91dGxpbmVzIiwibnVtYmVyT2ZDb2xvcnMiLCJvdXRsaW5lckZvck91dGxpbmUiLCJleHRyYVRoaWNrbmVzcyIsImRyYXdMYXllciIsImZpbmFsaXplTGluZSIsInVwZGF0ZUxpbmUiLCJ1cGRhdGVCb3giLCJyb3RhdGVCYm94IiwidXBkYXRlVGhpY2tuZXNzIiwic2V0Q29sb3JBbmRPcGFjaXR5Iiwib3BhIiwiY2hhbmdlQ29sb3IiLCJjaGFuZ2VPcGFjaXR5Iiwic2F2ZWRPcGFjaXR5Iiwic2F2ZWRUaGlja25lc3MiLCJzZXRUaGlja25lc3MiLCJ0aCIsImNoYW5nZVRoaWNrbmVzcyIsImdldFJvdGF0aW9uIiwiYWRkVW5kb2FibGVFZGl0b3IiLCJjbGVhbkRyYXdMYXllciIsIm11c3RCZVNlbGVjdGVkIiwiZHJhdyIsInBvaW50ZXJvdmVyIiwiYWRkQ2xhc3MiLCJwb2ludGVybGVhdmUiLCJyZW1vdmVDbGFzcyIsInNldENhcmV0Iiwic2VyaWFsaXplQm94ZXMiLCJGbG9hdDMyQXJyYXkiLCJzZXJpYWxpemVPdXRsaW5lcyIsInN0YXJ0SGlnaGxpZ2h0aW5nIiwiZW5kSGlnaGxpZ2h0IiwiaGlnaGxpZ2h0TW92ZSIsInVwZGF0ZVBhdGgiLCJyYXdXaWR0aCIsIklua0VkaXRvciIsImJhc2VIZWlnaHQiLCJiYXNlV2lkdGgiLCJjYW52YXNDb250ZXh0TWVudVRpbWVvdXRJZCIsImN1cnJlbnRQYXRoMkQiLCJkcmF3aW5nQUMiLCJoYXNTb21ldGhpbmdUb0RyYXciLCJpc0NhbnZhc0luaXRpYWxpemVkIiwib2JzZXJ2ZXIiLCJwb2ludGVyZG93bkFDIiwicmVhbFdpZHRoIiwicmVhbEhlaWdodCIsInJlcXVlc3RGcmFtZUNhbGxiYWNrIiwiYmV6aWVyUGF0aDJEIiwiYWxsUmF3UGF0aHMiLCJjdXJyZW50UGF0aCIsInRyYW5zbGF0aW9uWCIsInRyYW5zbGF0aW9uWSIsInVwZGF0ZU9wYWNpdHkiLCJmaXRUb0NvbnRlbnQiLCJyZWRyYXciLCJzZXRPcGFjaXR5IiwiY3JlYXRlT2JzZXJ2ZXIiLCJzZXRDYW52YXNEaW1zIiwiZGlzY29ubmVjdCIsInNldERpbWVuc2lvbnMiLCJhZGRQb2ludGVyZG93bkxpc3RlbmVyIiwicmVtb3ZlUG9pbnRlcmRvd25MaXN0ZW5lciIsImdldEluaXRpYWxCQm94Iiwic2V0U3Ryb2tlIiwic3RhcnREcmF3aW5nIiwiY2FudmFzUG9pbnRlcmxlYXZlIiwiY2FudmFzUG9pbnRlcm1vdmUiLCJjYW52YXNQb2ludGVydXAiLCJkcmF3UG9pbnRzIiwicGF0aDJEIiwibWFrZUJlemllckN1cnZlIiwic3RvcERyYXdpbmciLCJiZXppZXIiLCJnZW5lcmF0ZUJlemllclBvaW50cyIsInh5IiwibGFzdFBvaW50cyIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJiZXppZXJQb2ludHMiLCJjb250cm9sMSIsImNvbnRyb2wyIiwidXBkYXRlVHJhbnNmb3JtIiwiYWRkSW5rRWRpdG9ySWZOZWVkZWQiLCJjYW52YXNQb2ludGVyZG93biIsIlJlc2l6ZU9ic2VydmVyIiwiY29udGVudFJlY3QiLCJvYnNlcnZlIiwicm91bmRlZFdpZHRoIiwicm91bmRlZEhlaWdodCIsInNldFNjYWxlRmFjdG9yIiwiZ2V0UGFkZGluZyIsInNjYWxlRmFjdG9yVyIsInNjYWxlRmFjdG9ySCIsImJ1aWxkUGF0aDJEIiwidG9QREZDb29yZGluYXRlcyIsImZyb21QREZDb29yZGluYXRlcyIsInNlcmlhbGl6ZVBhdGhzIiwicDEwIiwicDExIiwicDIwIiwicDIxIiwicDMwIiwicDMxIiwicDQwIiwicDQxIiwiZ2V0QmJveCIsInByZXZUcmFuc2xhdGlvblgiLCJwcmV2VHJhbnNsYXRpb25ZIiwidW5zY2FsZWRQYWRkaW5nIiwiU3RhbXBFZGl0b3IiLCJiaXRtYXBJZCIsImJpdG1hcFByb21pc2UiLCJiaXRtYXBVcmwiLCJiaXRtYXBGaWxlIiwiYml0bWFwRmlsZU5hbWUiLCJyZXNpemVUaW1lb3V0SWQiLCJoYXNCZWVuQWRkZWRJblVuZG9TdGFjayIsInN1cHBvcnRlZFR5cGVzIiwic3VwcG9ydGVkVHlwZXNTdHIiLCJwYXN0ZUVkaXRvciIsImdldEFzRmlsZSIsImhhc0FsdFRleHRTdGF0cyIsImhhc05vQWx0VGV4dCIsImdldEJpdG1hcEZldGNoZWQiLCJmcm9tSWQiLCJnZXRCaXRtYXBEb25lIiwiYWx0X3RleHRfbW9kYWwiLCJhbHRfdGV4dF90eXBlIiwibWxHdWVzc0FsdFRleHQiLCJ1cGRhdGVBbHRUZXh0RGF0YSIsImlzRW5hYmxlZEZvciIsImNvcHlDYW52YXMiLCJndWVzcyIsImNoYW5uZWxzIiwiYWx0IiwiZ2V0Qml0bWFwIiwiYWNjZXB0IiwiZmlsZXMiLCJjbGljayIsIk1BWF9SQVRJTyIsImZhY3RvciIsImRyYXdCaXRtYXAiLCJtYXhEYXRhRGltZW5zaW9uIiwibWF4UHJldmlld0RpbWVuc2lvbiIsImJpdG1hcFdpZHRoIiwiYml0bWFwSGVpZ2h0Iiwib3V0cHV0U2NhbGUiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInNjYWxlQml0bWFwIiwiYm94RGltIiwiYm94RGltV2lkdGgiLCJib3hEaW1IZWlnaHQiLCJwYXR0ZXJuQ3R4IiwiZGF0YVdpZHRoIiwiZGF0YUhlaWdodCIsIm9mZnNjcmVlbkN0eCIsInByZXZXaWR0aCIsInByZXZIZWlnaHQiLCJzZXJpYWxpemVCaXRtYXAiLCJ0b1VybCIsInRvRGF0YVVSTCIsInN0cnVjdFBhcmVudCIsIl9zdHJ1Y3RUcmVlIiwiY2hhbmdlcyIsImlzU2FtZSIsImlzU2FtZUFsdFRleHQiLCJzdGFtcHMiLCJhcmVhIiwicHJldkRhdGEiLCJpc1NhbWVSZWN0IiwiaXNTYW1lUGFnZUluZGV4IiwiYWxsb3dDbGljayIsImFubm90YXRpb25MYXllciIsImNsaWNrQUMiLCJlZGl0b3JGb2N1c1RpbWVvdXRJZCIsImhhZFBvaW50ZXJEb3duIiwiaXNDbGVhbmluZ1VwIiwiaXNEaXNhYmxpbmciLCJ0ZXh0U2VsZWN0aW9uQUMiLCJfaW5pdGlhbGl6ZWQiLCJpc0ludmlzaWJsZSIsImRpc2FibGVUZXh0U2VsZWN0aW9uIiwidG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyIsImVuYWJsZVRleHRTZWxlY3Rpb24iLCJpc0NvbW1pdHRpbmciLCJhbm5vdGF0aW9uRWxlbWVudElkcyIsImVkaXRhYmxlcyIsImNoYW5nZWRBbm5vdGF0aW9ucyIsInJlc2V0QW5ub3RhdGlvbnMiLCJjdXJyZW50QWN0aXZlIiwidGV4dExheWVyUG9pbnRlckRvd24iLCJhdHRhY2giLCJkZXRhY2giLCJyZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIiLCJjdXJyZW50RWRpdG9yVHlwZSIsImNyZWF0ZU5ld0VkaXRvciIsImdldENlbnRlclBvaW50IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwib2xkUm90YXRpb24iLCJtYXBwaW5nIiwidG9VcGRhdGUiLCJfc3ZnRmFjdG9yeSIsInNldEJveCIsImNyZWF0ZVNWRyIsImNyZWF0ZUNsaXBQYXRoIiwicGF0aElkIiwiY2xpcFBhdGhVc2UiLCJpc1BhdGhVcGRhdGFibGUiLCJ1c2UiLCJtYXNrSWQiLCJ1c2UxIiwidXNlMiIsImNsb25lTm9kZSIsImdldFNWR1Jvb3QiLCJwZGZqc1ZlcnNpb24iLCJwZGZqc0J1aWxkIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fib3J0RXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25FZGl0b3JMYXllciIsIl9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSIsIl9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVHlwZSIsIl9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIiwiX193ZWJwYWNrX2V4cG9ydHNfX0Fubm90YXRpb25MYXllciIsIl9fd2VicGFja19leHBvcnRzX19Bbm5vdGF0aW9uTW9kZSIsIl9fd2VicGFja19leHBvcnRzX19Db2xvclBpY2tlciIsIl9fd2VicGFja19leHBvcnRzX19ET01TVkdGYWN0b3J5IiwiX193ZWJwYWNrX2V4cG9ydHNfX0RyYXdMYXllciIsIl9fd2VicGFja19leHBvcnRzX19GZWF0dXJlVGVzdCIsIl9fd2VicGFja19leHBvcnRzX19HbG9iYWxXb3JrZXJPcHRpb25zIiwiX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlS2luZCIsIl9fd2VicGFja19leHBvcnRzX19JbnZhbGlkUERGRXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX01pc3NpbmdQREZFeGNlcHRpb24iLCJfX3dlYnBhY2tfZXhwb3J0c19fT1BTIiwiX193ZWJwYWNrX2V4cG9ydHNfX091dHB1dFNjYWxlIiwiX193ZWJwYWNrX2V4cG9ydHNfX1BERkRhdGFSYW5nZVRyYW5zcG9ydCIsIl9fd2VicGFja19leHBvcnRzX19QREZEYXRlU3RyaW5nIiwiX193ZWJwYWNrX2V4cG9ydHNfX1BERldvcmtlciIsIl9fd2VicGFja19leHBvcnRzX19QYXNzd29yZFJlc3BvbnNlcyIsIl9fd2VicGFja19leHBvcnRzX19QZXJtaXNzaW9uRmxhZyIsIl9fd2VicGFja19leHBvcnRzX19QaXhlbHNQZXJJbmNoIiwiX193ZWJwYWNrX2V4cG9ydHNfX1JlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiIsIl9fd2VicGFja19leHBvcnRzX19UZXh0TGF5ZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIiwiX193ZWJwYWNrX2V4cG9ydHNfX1V0aWwiLCJfX3dlYnBhY2tfZXhwb3J0c19fVmVyYm9zaXR5TGV2ZWwiLCJfX3dlYnBhY2tfZXhwb3J0c19fWGZhTGF5ZXIiLCJfX3dlYnBhY2tfZXhwb3J0c19fYnVpbGQiLCJfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCIsIl9fd2VicGFja19leHBvcnRzX19mZXRjaERhdGEiLCJfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RG9jdW1lbnQiLCJfX3dlYnBhY2tfZXhwb3J0c19fZ2V0RmlsZW5hbWVGcm9tVXJsIiwiX193ZWJwYWNrX2V4cG9ydHNfX2dldFBkZkZpbGVuYW1lRnJvbVVybCIsIl9fd2VicGFja19leHBvcnRzX19nZXRYZmFQYWdlVmlld3BvcnQiLCJfX3dlYnBhY2tfZXhwb3J0c19faXNEYXRhU2NoZW1lIiwiX193ZWJwYWNrX2V4cG9ydHNfX2lzUGRmRmlsZSIsIl9fd2VicGFja19leHBvcnRzX19ub0NvbnRleHRNZW51IiwiX193ZWJwYWNrX2V4cG9ydHNfX25vcm1hbGl6ZVVuaWNvZGUiLCJfX3dlYnBhY2tfZXhwb3J0c19fc2V0TGF5ZXJEaW1lbnNpb25zIiwiX193ZWJwYWNrX2V4cG9ydHNfX3NoYWRvdyIsIl9fd2VicGFja19leHBvcnRzX192ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pdf/node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ })

};
;